<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux下socks5搭建和应用]]></title>
    <url>%2F2018%2F01%2F21%2F2018-01-21-223237-Linux%E4%B8%8Bsocks5%E6%90%AD%E5%BB%BA%E5%92%8C%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[socks介绍 SOCKS：防火墙安全会话转换协议 （Socks: Protocol for sessions traversal across firewall securely） SOCKS 协议提供一个框架，为在 TCP 和 UDP 域中的客户机/服务器应用程序能更方便安全地使用网络防火墙所提供的服务。 这个协议从概念上来讲是介于应用层和传输层之间的 “中介层（shim-layer）”，因而不提供如传递 ICMP 信息之类的网络层网关服务。 SOCKS5 是一个代理协议，它在使用TCP/IP协议通讯的前端机器和服务器机器之间扮演一个中介角色，使得内部网中的前端机器变得能够访问Internet网中的服务器，或者使通讯更加安全。 SOCKS5 服务器通过将前端发来的请求转发给真正的目标服务器， 模拟了一个前端的行为。在这里，前端和SOCKS5之间也是通过TCP/IP协议进行通讯，前端将原本要发送给真正服务器的请求发送给SOCKS5服务器，然后SOCKS5服务器将请求转发给真正的服务器。 安装socks5 解决依赖关系 1yum -y install pam-devel openldap-devel openssl-devel 编译安装 12345wget https://nchc.dl.sourceforge.net/project/ss5/ss5/3.8.9-8/ss5-3.8.9-8.tar.gztar xf ss5-3.8.9-8.tar.gz cd ss5-3.8.9/./configuremake &amp;&amp; make install 配置 配置备份 1mv /etc/opt/ss5/ss5.conf&#123;,.bak&#125; 修改认证方式/etc/opt/ss5/ss5.conf默认是无用户认证，需要使用-u 12auth 0.0.0.0/0 - upermit - 0.0.0.0/0 - 0.0.0.0/0 - - - - - 添加用户名密码/etc/opt/ss5/ss5.passwd每行一个 用户 密码，使用空格分隔 12test1 12345test2 56789 修改ss5启动的参数，自定义代理端口 /etc/sysconfig/ss5（如果不设置，默认是1080）此文件ss5启动时会主动加载 12# Add startup option hereSS5_OPTS=" -u root -b 0.0.0.0:10080" 创建服务控制脚本/usr/sbin/ss5_ctl.sh 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#!/bin/bash## chkconfig: 345 20 80# description: This script takes care of starting \# and stopping ss5#OS=`uname -s`if [ $OS = "Linux" ] || [ $OS = "SunOS" ]; then # Source function library. . /etc/rc.d/init.d/functions# Source networking configuration. . /etc/sysconfig/network# Check that networking is up. [ "$&#123;NETWORKING&#125;" = "no" ] &amp;&amp; exit 0 [ -f /usr/sbin/ss5 ] || exit 0fi# Test custom variablestest -f /etc/sysconfig/ss5 &amp;&amp; . /etc/sysconfig/ss5# See how we were called.case "$1" in start) # Start daemon. echo -n "Starting ss5... " if [ $OS = "Linux" ]; then daemon /usr/sbin/ss5 -t $SS5_OPTS touch /var/lock/subsys/ss5 else if [ $OS = "SunOS" ]; then /usr/sbin/ss5 -t touch /var/lock/subsys/ss5 else /usr/local/sbin/ss5 -t fi fi echo "done" ;; stop) # Stop daemon. echo "Shutting down ss5... " if [ $OS = "Linux" ] || [ $OS = "SunOS" ]; then killproc ss5 rm -f /var/lock/subsys/ss5 else killall ss5 fi rm -f /var/run/ss5/ss5.pid echo "done" ;; reload) # Reload configuration if [ $OS = "Linux" ] || [ $OS = "SunOS" ]; then echo -n "Reloading ss5... " killproc ss5 -1 else pkill -HUP ss5 fi echo "done reload" ;; restart) # Restart daemon echo -n "Restarting ss5... " $0 stop $0 start ;; status) if [ $OS = "Linux" ] || [ $OS = "SunOS" ]; then status ss5 fi ;; *) echo "Usage: ss5 &#123; start | stop | status | restart | reload &#125;" exit 1 ;;esacexit 0 服务控制 12ss5_ctl.sh start netstat -tunlp | grep ss5 应用应用场景：办公室使用的是电信网络，运维工程师需要在办公室使用SecureCRT来远程一台配置了移动IP的服务器。由于电信到移动跨运营商导致无法使用SecureCRT直接ssh远程。因此可以使用一台配置了ss5的服务器来做代理。前面已经说明了怎么配置，接下来补充一下SecureCRT如何使用ss5。 添加firewall打开SecureCRT，打开 Options =&gt; Global Options... 对应的session使用firewall，选择要ssh远程的的session，右键单击属性，选择防火墙]]></content>
      <categories>
        <category>代理</category>
      </categories>
      <tags>
        <tag>socks5</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用dialog创建交互式shell对话框]]></title>
    <url>%2F2018%2F01%2F21%2F2018-01-21-155425-%E4%BD%BF%E7%94%A8dialog%E5%88%9B%E5%BB%BA%E4%BA%A4%E4%BA%92%E5%BC%8Fshell%E5%AF%B9%E8%AF%9D%E6%A1%86%2F</url>
    <content type="text"><![CDATA[dialog是一个可以创建对话框的工具，需要手动安装，yum源安装即可。 系统默认自带whiptail也可实现对话框的创建 每个对话框提供的输出有两种形式： 将所有输出到stderr，不显示到屏幕； 使用退出状态码，OK为0，NO为1，ESC为255。 语法说明1Usage: dialog --common-options --boxType "Text" Height Width --box-specific-option --common-options 通用选项 --boxType 窗体类型 &quot;Text&quot;窗体的标题 Height 窗体的高度（字符个数） Width 窗体宽度（字符个数） 选项通用选项这个选项用来设置dialog box的背景、颜色和标题等。 --title &lt;title&gt;：窗体的标题 --backtitle &lt;backtitle&gt;：窗体的背景标题 --colors：使用颜色 \Z表示开始，\Zn表示结束。解读嵌入式\Z的对话框中的特殊文本序列，序列由下面的字符0-7, b，B, u, U等组成，恢复正常的设置使用\Zn。 --no-shadow：禁用窗体的阴影效果 --shadow：启用窗体的阴影效果 --insecure：输入部件的密码时，使用星号来代表每个字符。 --no-cancel：设置在输入框、菜单和复选框中不显cancel项。 --nook 没有ok键 --clear：完成清屏操作，在框体显示结束后，清除框体，这个参数只能单独使用，不能和别的参数联合使用。 --ok-label &lt;str&gt;：覆盖使用OK按钮标签，换做其它字符。 --cancel-label &lt;str&gt;：功能同上。 --begin &lt;y&gt; &lt;x&gt;：指定对话框左上角在屏幕上的坐标。 --timeout &lt;secs&gt;：超时（返回的错误代码），如果用户在指定的时间内没有给出相应动作，就按超时处理。 --defaultno：设定光标在yesno对话框的默认位置为no --default-item string ：设定在复选框中的默认值 --sleep &lt;secs&gt;：窗体的超时时间，如果用户没有在超时时间内进行选择，将会退出并返回一个错误码 --stderr：以标准错误方式输出。 --stdout：以标准方式输出。 --default-item &lt;str&gt;：设置在一份清单、表格或菜单中的默认项目，通常在框中的第一项是默认的。 窗体类型选项常见的对话框控件选项如下所示： --calendar：提供了一个日历，让你可以选择日期。 --checklist：允许你显示一个选项列表，每个选项都可以被单独的选择(复选框)。 --from：允许建立一个带标签的文本字段，并要求填写。 --fselect：提供一个路径，让你选择浏览的文件。 --gauge：显示一个表，呈现出完成的百分比，就是显示出进度。 --infobox：显示消息后，（没有等待响应）对话框立刻返回，但不清除屏幕(信息框)。 --inputbox：让用户输入文本(输入框)。 --inputmenu：提供一个可供用户编辑的菜单（可编辑的菜单框）。 --menu：显示一个列表供用户选择(菜单框)。 --msgbox：显示一条消息，并要求用户选择一个确定按钮(消息框)。 --pause：显示一个表格用来显示一个指定的暂停期的状态。 --passwordbox：显示一个输入框，它隐藏文本。 --passwordfrom：显示一个来源于标签并且隐藏的文本字段。 --radiolist：提供一个菜单项目组，只有一个项目，可以选择(单选框)。 --tailbox：在一个滚动窗口文件中使用tail命令来显示文本。 --tailboxbg：跟tailbox类似，但是在background模式下操作。 --textbox：在带有滚动条的文本框中显示文件的内容(文本框)。 --timebox：提供一个窗口，选择小时、分钟、秒。 --yesno：提供一个带有yes和no按钮的简单信息框(是/否框)。 使用示例创建消息框 语法 1dialog --title "&lt;message box title&gt;" --msgbox "&lt;text to show&gt;" &lt;height&gt; &lt;width&gt; 实例 1dialog --backtitle "Test the first message box" --title "Test Message Box" --colors --ok-label "YES" --msgbox "Create a message box with dialog. Choose \Z1YES\Zn to continue." 10 60 效果 创建输入框 格式 1dialog --inputbox text height width 示例 123#!/bin/bashuserName=$(dialog --backtitle "Add a user" --title "Username" --inputbox "Please input a username" 10 30 --stdout)echo "Username is:" $userName 效果 创建文本信息框 格式 1dialog --textbox file height width 示例 1dialog --textbox /etc/fstab 20 80 效果 创建yesno对话框 格式 1dialog --yesno text height width 示例 1dialog --title "yes/no" --no-shadow --yesno "Delete the file /tmp/test.txt?" 10 30 效果 创建一个菜单栏 格式 1dialog --menu text height width menu-height tag1 item1 tag2 item2 … 示例 12dialog --title "Pick a choice" --menu "Choose one" 12 35 5 A "Display the disk usage" B "Display the meminfo" C "Quit"# 进入菜单后按A、B、C可定位到某一个条目上，标准输出是tag 效果 创建文件选框 格式 1dialog --fselect filepath height width 示例 1dialog --title "Pick one file" --fselect /root/ 7 40 效果 创建复选框 格式 1dialog --checklist "Test" height width menu-height tag1 item1 tag2 item2 … 示例 1dialog --backtitle "Checklist" --checklist "Test" 20 50 10 Memory Memory_Size 1 Dsik Disk_Size 2 效果 创建密码框 格式 1dialog --passwordbox text height width [init] 示例 1dialog --title "Password" --passwordbox "Please give a password for the new user:" 10 35 密码暴露出来不安全，所以通常我们会加上一个安全选项--insecure，将每个字符用*来显示。 1dialog --title "Password" --insecure --passwordbox "Please give a password for the new user:" 10 30 效果 创建一个日历框 格式 1dialog --calendar "Date" height width day month year 示例 显示当前日期 1dialog --title "Calendar" --calendar "Date" 5 50 显示指定日期 1dialog --title "Calendar" --calendar "Date" 5 50 1 2 2013 效果 创建一个进度框 格式 1dialog --gauge text height width [&lt;percent&gt;] 示例 固定进度显示 1dialog --title "installation pro" --gauge "installation" 10 30 10 实时显示 1for i in &#123;1..100&#125; ;do echo $i;done | dialog --title "installation pro" --gauge "installation" 10 30 拷贝100个文件 1234567891011121314151617181920#!/bin/bashdeclare -i percent=0install -cd /tmp/test(for file in /etc/*;do if [ $&#123;percent&#125; -le 100 ];then cp -r $&#123;file&#125; /tmp/test/ 2&gt;/dev/null echo XXX # 两个XXX之间的内容替换标题 echo "Copy the file $&#123;file&#125; ... " echo XXX echo $&#123;percent&#125; fi ((percent=percent+1)) sleep 0.1done ) | dialog --title "Coping..." --gauge "Starting to copy files ... " 6 50 0 效果 创建表单 格式 1dialog --form text height width formheight [ label y x item y x flen ilen ] ... 其中：flen表示field length，定义了选定字段中显示的长度；ilen表示input-length, 定义了在外地输入的数据允许的长度。使用up/down（或ctrl/ N，ctrl/ P）在使用领域之间移动，使用tab键在窗口之间切换。 示例 12345dialog --title "Add a user" --form "Please input the infomation of new user:" 12 40 4 \ "Username:" 1 1 "" 1 15 15 0 \ "Full name:" 2 1 "" 2 15 15 0 \ "Home Dir:" 3 1 "" 3 15 15 0 \ "Shell:" 4 1 "" 4 15 15 0 效果 综合应用示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#! /bin/bashyesno() &#123; dialog --title "First screen" --backtitle "Test Program" --clear --yesno \ "Start this test program or not ? \nThis decesion have to make by you." 16 51 # yes is 0, no is 1 , esc is 255 result=$? if [ $result -eq 1 ] ; then exit 1; elif [ $result -eq 255 ]; then exit 255; fi username;&#125;username() &#123; cat /dev/null &gt;/tmp/test.username dialog --title "Second screen" --backtitle "Test Program" --clear --inputbox \ "Please input your username (default: hello) " 16 51 "hello" 2&gt;/tmp/test.username result=$? if [ $result -eq 1 ] ; then yesno; elif [ $result -eq 255 ]; then exit 255; fi password;&#125;password() &#123; cat /dev/null &gt;/tmp/test.password dialog --insecure --title "Third screen" --backtitle "Test Program" --clear --passwordbox \ "Please input your password (default: 123456) " 16 51 "123456" 2&gt;/tmp/test.password result=$? if [ $result -eq 1 ] ; then username; elif [ $result -eq 255 ]; then exit 255; fi occupation;&#125;occupation() &#123; cat /dev/null &gt;/tmp/test.occupation dialog --title "Forth screen" --backtitle "Test Program" --clear --menu \ "Please choose your occupation: (default: IT)" 16 51 3 \ IT "The worst occupation" \ CEO "The best occupation" \ Teacher "Not the best or worst" 2&gt;/tmp/test.occupation result=$? if [ $result -eq 1 ] ; then password; elif [ $result -eq 255 ]; then exit 255; fi finish;&#125;finish() &#123; dialog --title "Fifth screen" --backtitle "Test Program" --clear --msgbox \ "Congratulations! The test program has finished!\n Username: $(cat /tmp/test.username)\n Password: $(cat /tmp/test.password)\n Occupation: $(cat /tmp/test.occupation)" 16 51 result=$? if [ $result -eq 1 ] ; then occupation elif [ $result -eq 255 ]; then exit 255; fi&#125;yesno;]]></content>
  </entry>
  <entry>
    <title><![CDATA[chmod权限被改为000后的恢复]]></title>
    <url>%2F2018%2F01%2F20%2F2018-01-20-172607-chmod%E6%9D%83%E9%99%90%E8%A2%AB%E6%94%B9%E4%B8%BA000%E5%90%8E%E7%9A%84%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[方法一：使用库文件的管理程序调用chmod 1/lib64/ld-linux-x86-64.so.2 /bin/chmod 755 /bin/chmod 方法二：使用busybox的chmod授权 1busybox chmod 755 /bin/chmod 方法三：使用dd命令 1234567mv /bin/chmod /bin/chmod.origcp -a /bin/chown /bin/chmoddd if=/bin/chmod.orig of=/bin/chmod95+1 records in95+1 records out48712 bytes (49 kB) copied,0.00117323 s, 41.5 MB/s 方法四：使用facl额外授权 123setfacl -m u::rx /bin/chmod chmod 755 /bin/chmod setfacl -b /bin/chmod 方法五：复制一个可执行文件，然后使用chmod命令覆盖 123cp /bin/ls chmod\cp /bin/chmod .\cp -a chmod /bin/chmod 方法六：使用install命令的-m选项也可以设置权限 1install -ma+x /bin/chmod . 方法七：使用perl 1perl -e'chmod 0755, "/bin/chmod"' 方法八：使用Python 1python -c'import os; os.chmod("/bin/chmod", 0755)']]></content>
      <categories>
        <category>故障修复</category>
      </categories>
      <tags>
        <tag>故障修复</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS的lib库误操作和修复]]></title>
    <url>%2F2018%2F01%2F20%2F2018-01-20-164155-CentOS%E7%9A%84lib%E5%BA%93%E8%AF%AF%E6%93%8D%E4%BD%9C%E5%92%8C%E4%BF%AE%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[CentOS系统中，lib目录下的库对系统的正常运行起着非常关键的作用。一旦误操作将导致系统瘫痪。 /lib64被重命名故障表现由于操作失误，把/usr/lib64重命名成了/usr/lib64.bak，结果发现，在运行所有外置命令的时候报错： 1234567891011# mv命令无法使用-bash: /bin/mv: /lib64/ld-linux-x86-64.so.2: bad ELF interpreter: No such file or directory# cp命令无法使用-bash: /bin/cp: /lib64/ld-linux-x86-64.so.2: bad ELF interpreter: No such file or directory# ls命令无法使用-bash: /bin/ls: /lib64/ld-linux-x86-64.so.2: bad ELF interpreter: No such file or directory# ssh命令无法使用-bash: /usr/bin/ssh: /lib64/ld-linux-x86-64.so.2: bad ELF interpreter: No such file or directory 想使用mv把文件重命名回来已经不行了，就连重新ssh远程都远程不了。 修复方法方法一光盘修复，安装glibc，如果机器允许重启的话 方法二系统一般情况下会设置LD_LIBRARY_PATH， LD_PRELOAD这两个环境变量，来改变应用程序所调用库文件的路径。这两个环境变量只对应用程序有效，可能会对shell命令不起作用 因为默认的库文件路径/usr/lib64被改成了/usr/lib64.bak，因此尝试： 123export LD_LIBRARY_PATH=/usr/lib64.bakexport LD_PRELOAD=/usr/lib64.bakcp /usr/lib64.bak /usr/lib64 方法三 在一个正常的操作系统上&lt;我们可以发现/lib64/ld-linux-x86-64.so.2只是个软链，真实文件是/usr/lib64/ld-2.17.so，而且这个文件本身并不是库文件，可以简单的认为他是库文件的管理程序。 ld-linux-x86-64.so.2是操作系统的核心，并不受LD_LIBRARY_PATH环境变量的影响。如果想改变其调用方式，可以查看man文档 根据使用帮助，我们手动指定库路径进行调用cp命令 1/lib64/ld-linux-x86-64.so.2 --library-path /lib64.bak /bin/cp /lib64.bak /lib64 -afr 误删除/lib64/ld-linux-x86-64.so.2解决方法同上，删除的是软连接文件，链接回来即可 1/lib64/ld-2.17.so --library-path /lib64/ld-2.17.so /bin/ln -sv /lib64/ld-2.17.so /lib64/ld-linux-x86-64.so.2]]></content>
      <categories>
        <category>故障修复</category>
      </categories>
      <tags>
        <tag>故障修复</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[curl-7.57.0源码包编译安装和移植]]></title>
    <url>%2F2018%2F01%2F19%2F2018-01-19-214844-curl-7-57-0%E6%BA%90%E7%A0%81%E5%8C%85%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E5%92%8C%E7%A7%BB%E6%A4%8D%2F</url>
    <content type="text"><![CDATA[Linux系统中一般自带curl命令，大部分选项和参数基本能满足我们日常的测试需要。但是如果要使用一些新功能就有可能要是用编译安装的版本。本文编译安装的目的主要是让curl支持--dns-servers，实现DNS解析 Man Page：https://curl.haxx.se/docs/manpage.html 编译安装openssl要保证安装后的curl能兼容CentOS6以上系统针对https协议内容的访问，需要依赖较高版本的openssl 源码安装openssl需要perl编译环境 1yum -y install perl perl-devel 下载源码包并解压 123wget --no-check-certificate https://www.openssl.org/source/old/1.0.2/openssl-1.0.2m.tar.gz ;tar xf openssl-1.0.2m.tar.gz ;cd openssl-1.0.2m ; 编译安装 1234567./config -fPIC --prefix=/usr/local/openssl/ enable-shared# --prefix：指定安装目录# -fPIC:编译openssl的静态库# enable-shared:编译动态库make &amp;&amp; make install 版本查看 1/usr/local/openssl/bin/openssl version 库文件配置 12345678echo "/usr/local/openssl/lib/" &gt;&gt; /etc/ld.so.conf.d/openssl-1.0.2m.conf# 将库文件路径写入/etc/ld.so.conf文件中，方便调用库文件ldconfig# 在默认搜寻目录(/lib和/usr/lib)以及动态库配置文件/etc/ld.so.conf内所列的目录下，搜索出可共享的动态链接库ldconfig -p | grep '/usr/local/openssl/lib'# 打印出当前缓存文件所保存的所有共享库的名字并过滤openssl相关项 编译安装c-ares c-ares是一个C语言的异步DNS解析库，可以很方便的和使用者的事件循环统一起来，实现DNS的非阻塞异步解析，libcurl, libevent, gevent, nodejs都在使用 curl如果需要使用--dns-servers参数的话要在编译curl时对c-ares进行支持 12345678wget https://c-ares.haxx.se/download/c-ares-1.12.0.tar.gztar xf c-ares-1.12.0.tar.gz cd c-ares-1.12.0# 下载解压./configure --prefix=/usr/local/c-ares-1.12.0make &amp;&amp; make install# 编译安装 编译安装curl-7.57.0CURL 的官方安装文档，http://curl.haxx.se/docs/install.html 下载源码包并解压 123wget https://curl.haxx.se/download/curl-7.57.0.tar.bz2tar xf curl-7.57.0.tar.bz2 cd curl-7.57.0 编译安装 123./configure --prefix=/usr/local/curl-7.57.0/ --enable-ares=/usr/local/c-ares-1.12.0/ --with-ssl=/usr/local/openssl/ LIBS="-ldl -lrt "make &amp;&amp; make install# 需要依赖的库：libdl.so.2、librt.so.1，因此需要使用LABS参数指定库连接 版本查看 123456/usr/local/curl-7.57.0/bin/curl -Vcurl 7.57.0 (x86_64-pc-linux-gnu) libcurl/7.57.0 OpenSSL/1.0.2m c-ares/1.12.0Release-Date: 2017-11-29Protocols: dict file ftp ftps gopher http https imap imaps pop3 pop3s rtsp smb smbs smtp smtps telnet tftp Features: AsynchDNS Largefile NTLM NTLM_WB SSL TLS-SRP UnixSockets HTTPS-proxy 测试 123456789101112/usr/local/curl-7.57.0/bin/curl -I --dns-servers 8.8.8.8 www.baidu.comHTTP/1.1 200 OKServer: bfe/1.0.8.18Date: Fri, 19 Jan 2018 14:59:44 GMTContent-Type: text/htmlContent-Length: 277Last-Modified: Mon, 13 Jun 2016 02:50:25 GMTConnection: Keep-AliveETag: "575e1f71-115"Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transformPragma: no-cacheAccept-Ranges: bytes 创建软连接 1ln -sv /usr/local/curl-7.57.0/bin/curl /usr/local/sbin/curl7 curl-7.57.0编译好的源码包的移植编译好的包需要依赖很多库，为了解决移植后的库依赖的问题，我们可以在移植之前将所有依赖的库拷贝到程序的lib目录下 使用`ldd·命令列出动态库依赖关系 1234567891011[root@Test ~]$ ldd /usr/local/curl-7.57.0/bin/curl linux-vdso.so.1 =&gt; (0x00007fffb6df5000) libcurl.so.4 =&gt; /usr/local/curl-7.57.0/lib/libcurl.so.4 (0x00002ac39067a000) libssl.so.1.0.0 =&gt; /usr/local/curl-7.57.0/lib/libssl.so.1.0.0 (0x00002ac3908e3000) libcrypto.so.1.0.0 =&gt; /usr/local/curl-7.57.0/lib/libcrypto.so.1.0.0 (0x00002ac390b4f000) librt.so.1 =&gt; /usr/local/curl-7.57.0/lib/librt.so.1 (0x0000003184000000) libc.so.6 =&gt; /usr/local/curl-7.57.0/lib/libc.so.6 (0x0000003182400000) libcares.so.2 =&gt; /usr/local/c-ares-1.12.0/lib/libcares.so.2 (0x00002ac390f65000) libdl.so.2 =&gt; /usr/local/curl-7.57.0/lib/libdl.so.2 (0x0000003182800000) libpthread.so.0 =&gt; /usr/local/curl-7.57.0/lib/libpthread.so.0 (0x0000003182c00000) /lib64/ld-linux-x86-64.so.2 (0x0000003182000000) 拷贝相关的库到程序的lib目录 123cp /usr/local/openssl/lib/libssl.so.1.0.0 /usr/local/curl-7.57.0/lib/cp /usr/local/openssl/lib/libcrypto.so.1.0.0 /usr/local/curl-7.57.0/lib/cp /usr/local/c-ares-1.12.0/lib/libcares.so.2 /usr/local/curl-7.57.0/lib/ 创建可移植的压缩包 12cd /usr/local/tar -jcf curl-7.57.0.tar.bz2 curl-7.57.0 使用scp命令从本机移植到另外一台机器X，在X机器添加库搜索路径 12345678scp -P 22 curl-7.57.0.tar.bz2 XXX.XXX.XXX.XXX:/opt/ssh -p 22 XXX.XXX.XXX.XXX# 以下操作均在X机器上执行cd /opt/tar xf curl-7.57.0.tar.bz2 -C /usr/local/echo '/usr/local/curl-7.57.0/lib/' &gt; /etc/ld.so.conf.d/curl-7.57.0.confldconfig 测试 123456789101112/usr/local/curl-7.57.0/bin/curl -I --dns-servers 8.8.8.8 www.baidu.comHTTP/1.1 200 OKServer: bfe/1.0.8.18Date: Sat, 20 Jan 2018 08:16:53 GMTContent-Type: text/htmlContent-Length: 277Last-Modified: Mon, 13 Jun 2016 02:50:26 GMTConnection: Keep-AliveETag: "575e1f72-115"Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transformPragma: no-cacheAccept-Ranges: bytes 创建软连接 1ln -sv /usr/local/curl-7.57.0/bin/curl /usr/local/sbin/curl7]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>openssl</tag>
        <tag>curl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Dnsmasq搭建本地自有DNS服务器]]></title>
    <url>%2F2018%2F01%2F08%2F2018-01-08-001609-%E5%88%A9%E7%94%A8Dnsmasq%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E8%87%AA%E6%9C%89DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[简介Dnsmasq 提供 DNS 缓存和 DHCP 服务功能。 作为域名解析服务器(DNS)，dnsmasq可以通过缓存 DNS 请求来提高对访问过的网址的连接速度。 作为DHCP 服务器，dnsmasq 可以用于为局域网电脑分配内网ip地址和提供路由。 DNS和DHCP两个功能可以同时或分别单独实现。 dnsmasq轻量且易配置，适用于个人用户或少于50台主机的网络。此外它还自带了一个 PXE 服务器以及对邮件服务器的mx记录的支持，jabber的srv记录的支持等。 它提供了DNS功能和可选择的DHCP功能可以取代dhcpd服务和bind等服务，配置起来更简单，更适用于虚拟化和大数据环境的部署。 应用一般情况下，我们可以用bind解决dns的问题，dhcpd解决dhcp的问题，可用dnsmasq解决下面的一些维护问题： 1、局域网有很多机器希望使用一致的hosts文件，你需要经常维护这份列表。 2、你希望局域网的人访问某个域名时，拦截下来到指定的ip，做缓存节省带宽或者其它用途都可以。优先使用本地自定义dns。 3、阻止对某个域名的正常解析。 常见的应用： 同时提供DNS解析功能和DHCP地址分配功能 可以用于机房内网、公司内网、家庭内网等类似内部网络环境 基于DNSmasq，Web端基于Python语言和Tornado框架 架设本地DNS，在一定程度上，解决我们访问网速、广告拦截的问题 作为局域网机器批量IP维护使用，以及局域网解决特定网址域名禁止访问 安装运行环境 OS：CentOS Linux release 7.4.1708 (Core) Python：2.7.5 DnsMasq：2.76 rpm包安装 直接使用yum源即可安装 12yum -y install dnsmasqdnsmasq -v 加入系统服务 123systemctl enable dnsmasq systemctl daemon-reloadsystemctl start dnsmasq 源码包安装 下载解压 123wget http://www.thekelleys.org.uk/dnsmasq/dnsmasq-2.78.tar.xztar xf dnsmasq-2.78.tar.xz cd dnsmasq-2.78 配置安装路径 1vim Makefile 1PREFIX = /usr/local/dnsmasq 编译安装 1make &amp;&amp; make install 生成配置和软链接 1cp dnsmasq.conf.example /etc/dnsmasq.conf 1ln -s /usr/local/dnsmasq/sbin/dnsmasq /usr/sbin/ 1dnsmasq --version 配置 dnsmasq的主配置文件为 /etc/dnsmasq.conf ，这个文件包含大量的选项注释。 为了防止配置出错，我们可以先备份一份到本地或者服务器中。 主配置文件中默认使用include包含了/etc/dnsmasq.d/目录下除了rpm包以外的所有文件，我们也可以在不修改主配置文件的前提下，在这个目录下创建一个自定义的配置文件 警告： dnsmasq 默认启用其 DNS 服务器。如果不需要，必须明确地将其 DNS 端口设置为 0 禁用它： /etc/dnsmasq.d/dnsmasq.conf 1port=0 提示： 查看配置文件语法是否正确，可执行下列命令： 1dnsmasq --test 公用配置 要在单台主机上以守护进程方式启动dnsmasq做DNS(缓存)服务器，如果仅为本机使用则写上127.0.0.1，编辑/etc/dnsmasq.d/dnsmasq.conf，添加监听地址： 1listen-address=127.0.0.1 如果用此主机为局域网提供默认 DNS，请为该主机绑定固定 IP 地址，设置： 1listen-address=192.168.x.x 这种情况建议配置静态IP。多个ip地址设置： 1listen-address=127.0.0.1,192.168.x.x 改变Dnsmasq默认的uid和gid 12user=group= 如果你想Dnsmasq监听某个接口为dhcp、dns提供服务 1interface= 你还可以指定哪个接口你不想监听 1except-interface= 关于其日志记录的几个选项 12345678910111213log-queries # Log lots of extra information about DHCP transactions.#log-dhcp # Log to this syslog facility or file. (defaults to DAEMON)log-facility=/var/log/dnsmasq.log # 异步log，缓解阻塞。log-async=20# 自动加载其它目录下的配置文件#conf-dir=/etc/dnsmasq.d DNS（缓存）设置 dnsmasq能够缓存外部DNS记录，同时提供本地DNS解析或者作为外部DNS的代理，即dnsmasq会首先查找/etc/hosts等本地解析文件，然后再查找/etc/resolv.conf等外部nameserver配置文件中定义的外部DNS。所以说dnsmasq是一个DNS中继。DNS配置同样在dnsmasq.conf配置文件里。 同时在/etc/hosts文件中加入本地内网解析，这样一来每当内网机器查询时就会优先查询hosts文件，这就等于将/etc/hosts共享给全内网机器使用，从而解决内网机器互相识别的问题，比如像hadoop添加datanode节点时。相比逐台机器编辑hosts文件或者添加Bind记录，仅需要编辑一个/etc/hosts文件。 配置所有配置均在/etc/dnsmasq.d/mydnsmasq.conf中 resolv-fileLinux 处理 DNS 请求时有个限制，在 resolv.conf 中最多只能配置三个域名服务器（nameserver），我们完全可以使用resolv-file来作为变通方法，当然这只是其中的一个用途之一。 123resolv-file=/etc/resolv.dnsmasq.conf # 这个参数表示 dnsmasq 会从这个指定的文件中寻找上级 dns 服务器列表，而不是从本机的(resolv.conf)中读取dns服务器列表# 如果机器的地址是通过dhcp取得的话，该文件（resolv.conf）容易受到影响从而影响dnsmasq，因此配置此项避免影响 strict-order12strict-order# 系统首先寻找本地的 dnsmasq 服务器，取消注释的 strict-order 表示严格按照 resolv-file 文件中的顺序从上到下进行 DNS 解析, 直到第一个成功解析成功为止 negative caching参考链接：https://www.xieyidian.com/803 首先简单说一下DNS解析的相关流程。客户端在访问某个域名，例如”www.xieyidian.com”的时候，浏览器首先会将这个域名提交到客户端配置的DNS服务器上，由DNS服务器将其解析为可识别的IP地址，并返回客户端，随后客户端会使用解析到的IP地址访问。 一般情况下，在成功解析一个域名后，客户端的DNS缓存会将这个信息记录下来，这样在这条缓存记录的TTL（有效存活时间）范围内，如果需要再次访问这个域名，那么不需要重新提交到DNS解析，客户端即可使用缓存中记录的IP地址直接访问。然而这就存在一个问题，假设客户端访问一个不存在的域名，或者内部网络中的所有DNS服务器都无法解析该域名，自然，DNS服务器是解析不到任何记录的。但如果客户端因为某种缘故，例如中毒，导致需要在短时间内频繁访问这个不存在或无法解析的域名，又会怎么样？客户端可能会在每次尝试访问的时候都通过DNS解析这个不存在的域名，当然，每次的结果都是无法解析，或解析失败。 如果有大量客户端都有这种情况，无疑，这会对DNS服务器造成很大压力。 为了解决这种问题，现在的DNS技术中包含了这个叫做”Negative caching”的功能。简单来说，当客户端尝试通过DNS解析某个域名但解析失败后，客户端依然会在自己的缓存中记录相关的信息，但这里记录的并非解析结果，而是”Negative caching”。这样当客户端尝试再次访问不存在的域名时，因为本地的DNS缓存中已经有了相关的Negative caching记录，因此客户端不会频繁尝试通过DNS进行解析。 该功能的基本原理就是这样，详细信息请参考RFC 2308 12no-negcache# 取消注释意味着禁用negative caching local-ttl允许客户端缓存的时间，单位为秒 1local-ttl=60 no-hosts123no-hosts# 默认情况下这是注释掉的，dnsmasq 会首先寻找本地的 hosts 文件，再去寻找缓存下来的域名, 最后去上级 dns 服务器中寻找# 而addn-hosts可以使用额外的hosts文件。所以说dnsmasq是一个很不错的外部DNS中继。 listen-address12listen-address=127.0.0.1,192.168.0.1# 表示该 dnsmasq 服务可以在哪些地址上侦听，127那个地址即本机，对外提供服务的话要写上对应的网口所有的地址。 缓存大小12cache-size=8192# 设置缓存大小 debug12log-queries# 开启debug模式，记录客户端查询记录到/var/log/debug中 缓存测试需要注意的是，一旦自定义的配置文件放到/etc/dnsmasq.d/中，配置文件中指定的某些文件就不能再放到这个目录里下了，因为会被/etc/dnsmasq.conf的include加载报错 主配置/etc/dnsmasq.d/mydnsmasq.conf 123456789no-pollstrict-orderno-negcachecache-size=8192local-ttl=60no-hostsaddn-hosts=/etc/dnsmasq.hostsresolv-file=/etc/resolv.dnsmasq.conflisten-address=192.168.127.130 resolv配置/etc/dnsmasq.d/resolv.dnsmasq.conf 1nameserver 8.8.8.8 hosts配置/etc/dnsmasq.d/myhosts 1234510.94.0.67 us_zero0110.94.0.68 aws-nx10.94.0.69 awsire10.94.0.70 awsuk10.94.0.71 awsvirginia 测试 123456789101112dnsmasq --test# 语法检查systemctl restart dnsmasq# 服务重启dig @192.168.127.130 awsvirginia +short# 正向解析dig @192.168.127.130 -x 10.94.0.66# 反向解析 dig @192.168.127.130 www.baidu.com dig @192.168.127.130 www.baidu.com 比较两次结果中的 Query time，缓存成功的情况下，第二次的查询时间明显大幅度降低 DHCP服务器设置dnsmasq默认关闭DHCP功能，如果该主机需要为局域网中的其他设备提供IP和路由，应该对dnsmasq 配置文件/etc/dnsmasq.d/my-dnsmasq-dhcp.conf必要的配置如下： 1234567expand-hostsdomain=test-dnsmasq.cn# Dynamic range of IPs to make available to LAN pcdhcp-range=192.168.0.50,192.168.0.100,255.255.255.0,12hdhcp-option=3,192.168.0.1 以上配置选项开启了DHCP服务，并且设置domain为“test-dnsmasq.cn”。DHCP服务提供地址范围为 ‘192.168.0.50到 192.168.0.100’ 续订期为12个小时。最后的一个选项指定了默认网关。 使用技巧避免 OpenDNS 重定向 Google 请求要避免 OpenDNS 重定向所有 Google 请求到他们自己的搜索服务器，配置以下内容到 /etc/dnsmasq.conf： 1server=/www.google.com/X.X.X.X 添加自定义域 它可以将一个自定义域添加到主机中的（本地）网络 123local=/home.lan/domain=home.lan# 在这个例子中可以ping主机/设备 (例如:您的主机文件中的定义) hostname.home.lan. 取消扩展主机添加自定义域的主机条目：存在 12expand-hosts# 如果没有这个设置，你必须域添加到/etc/ hosts中的条目 生产环境中的DNS拦截使用 在cdn网络加速的生产环境中，通常使用了类似于Nginx这样的反向代理手段，通过加速网络向后端服务器获取资源。 假设我们想要使用curl命令做资源下载测试，并需要知道在使用普通网络和加速网络的下载速度对比。 环境说明： 服务器A：做下载测试的服务器 URL：https://s3-ap-southeast-1.amazonaws.com/download-speed-sg-test/20M.tar 代理服务器：Nginx服务器为192.168.123.45，加速网络环境的服务器 实现手段： 普通网络环境的下载。直接在服务器A进行下载即可 1/usr/local/bin/curl -4 -o /dev/nul https://s3-ap-southeast-1.amazonaws.com/download-speed-sg-test/20M.tar 加速网络环境的下载。 1、在服务器A启用dnsmasq，将URL对应的域名拦截，使用自定义hosts的方式指向Nginx服务器 /etc/dnsmasq.d/nginx-test.conf 123456no-pollstrict-orderno-negcachecache-size=8192local-ttl=60addn-hosts=/opt/test/dns_host.conf /opt/test/dns_host.conf 1193.192.168.123.45 s3-ap-southeast-1.amazonaws.com 2、下载测试使用新版本的curl选项中的--dns-servers选项指定dns进行下载 123/usr/local/bin/curl -4 -o /dev/null --dns-servers 127.0.0.1 https://s3-ap-southeast-1.amazonaws.com/download-speed-sg-test/20M.tar# 系统自带的curl命令不支持--dns-servers，因此如果有这样的需求就要编译新版本的curl来支持dns 由此以来，服务器A的资源下载请求被dnsmasq转向了Nginx服务器，从而进入加速网络获取资源 web端的配置Dnsmasq的WEB端：https://github.com/luxiaok/DNSmasqWeb 参数注释DNS服务器配置参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104# 如果你不想使用/etc/hosts，则取消下面的注释#no-hosts# 本地解析文件，如果你想读取其他类似/etc/hosts文件，则进行配置。hosts文件的强大之处还在于能够劫持解析，比如mirror.debian.org是Debian仓库所在，可将它解析成一个内网地址，搭建一个内网镜像站，可以很快的安装软件源。#addn-hosts=/etc/banner_add_hosts# 主机名扩展，自动的给hosts中的name增加一个域名# 例如，/etc/hosts中的db1将扩展成db1.freeoa.netexpand-hosts# Add local-only domains here, queries in these domains are answered from /etc/hosts or DHCP only.local=/freeoa.net/ # 强制使用完整的解析名，从不转发格式错误的域名domain-needed# 如果只使用dhcp服务，完全禁止DNS功能，则可将设置为0。#port=5353# 以下两个参数告诉Dnsmasq过滤一些查询：# 1.哪些公共DNS没有回答 # 2.哪些root根域不可达。# 从不转发不在路由地址中的域名#bogus-priv# 添加额外的上级DNS主机（nameserver）配置文件(默认用/etc/resolv.conf)，resolv-file配置Dnsmasq额外的向流的DNS服务器，如果不开启就使用linux主机默认的/etc/resolv.conf里的nameserver，通过下面的选项指定其他文件。#resolv-file=/etc/dnsmasq.d/upstream_dns.conf# 默认情况下Dnsmasq会发送查询到它的任何上游DNS服务器上，如果取消注释，则Dnsmasq会严格按照/etc/resolv.conf中的DNS Server顺序进行查询。#strict-order# 以下两个参数控制是否通过/etc/resolv.conf确定上游服务器，是否检测/etc/resolv.conf的变化，则取消注释。# 如果你不想Dnsmasq读取/etc/resolv.conf文件或者其他文件，获得它的servers。即不使用上级DNS主机配置文件(/etc/resolv.conf和resolv-file）#no-resolv如果你不允许Dnsmasq通过轮询/etc/resolv.conf或者其他文件来获取配置的改变，则取消注释。 #no-poll# 可以为特定的域名指定解析它专用的nameserver。一般是内部dns name server# server=/myserver.com/192.168.8.1# 增加一个name server，一般用于内网域名#server=/localnet/192.168.8.1# 设置一个反向解析，所有192.168.3.0/24的地址都到10.1.2.3去解析#server=/3.168.192.in-addr.arpa/10.1.2.3# 增加一个本地域名，会在/etc/hosts中进行查询#local=/localnet/# 同上，还支持ipv6#address=/www.thekelleys.org.uk/fe80::20d:60ff:fe36:f83# 增加查询yahoo google和它们的子域名到ff、search查找# Add the IPs of all queries to yahoo.com, google.com, and their# subdomains to the ff and search ipsets:#ipset=/yahoo.com/google.com/ff,search# 控制Dnsmasq和Server之间的查询从哪个网卡出去# server=10.1.2.3@eth1# 指定dnsmasq默认查询的上游服务器，此处以Google Public DNS为例。server=8.8.8.8server=8.8.4.4# 把所有.cn的域名全部通过114.114.114.114这台国内DNS服务器来解析server=/cn/114.114.114.114# 给*.apple.com和taobao.com使用专用的DNSserver=/taobao.com/223.5.5.5server=/.apple.com/223.6.6.6# 指定源地址携带10.1.2.3地址和192.168.8.1的55端口进行通讯# and this sets the source (ie local) address used to talk to# 10.1.2.3 to 192.168.8.1 port 55 (there must be a interface with that# IP on the machine, obviously).# server=10.1.2.3@192.168.8.1#55# 如果你想在某个端口只提供dns服务，则可以进行配置禁止dhcp服务#no-dhcp-interface=# 给设定一个默认的或给dhcp服务指定一个域名#domain=freeoa.net# 给dhcp的一个子域赋一个不同的域名#domain=wireless.thekelleys.org.uk,192.168.2.0/24# 同上，不过子域是一个范围了#domain=reserved.thekelleys.org.uk,192.68.3.100,192.168.3.200 # 设置DNS缓存大小(单位：DNS解析条数)cache-size=500# 增加一个域名，强制解析到所指定的地址上，强行指定domain的IP地址，dns欺骗address=/doubleclick.net/127.0.0.1address=/.phobos.apple.com/202.175.5.114# 默认情况下：#resolv-file指定dnsmasq从哪里获取上行DNS Server， 默认是从/etc/resolv.conf获取。配置 dnsmasq 的上游 dns 服务器，(因为这是一个 dns 缓存, 那么其还是需要有上级服务器进行一次域名解析的来源)#addn-hosts指定dnsmasq从哪个文件中读取“地址 域名”记录， 默认是系统文件/etc/hosts。配置系统的 dns 服务器, 将 dnsmasq 设置在首位寻找。#listen-address默认是监控在所有网卡上的，设置 dnsmasq 需要监听的 IP 地址。 DHCP服务器参数注释1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# 选定需要监听的网卡# Only listen to routers' LAN NIC. Doing so opens up tcp/udp port 53 to# localhost and udp port 67 to world:interface=&lt;LAN-NIC&gt;# dnsmasq will open tcp/udp port 53 and udp port 67 to world to help with# dynamic interfaces (assigning dynamic ips). Dnsmasq will discard world# requests to them, but the paranoid might like to close them and let the # kernel handle them:bind-interfaces设定可分配的ip地址段和租约时间# Dynamic range of IPs to make available to LAN pcdhcp-range=192.168.111.50,192.168.111.150,12h# 同上，不过给出了掩码#dhcp-range=192.168.8.50,192.168.8.150,255.255.255.0,12h#绑定某些机器的ip-mac地址对，使其具有固定的ip地址# If you’d like to have dnsmasq assign static IPs, bind the LAN computer's# NIC MAC address:dhcp-host=aa:bb:cc:dd:ee:ff,192.168.1.50dhcp-host=00:0e:7b:ca:1c:6e,daunbook,192.168.0.12# 为192.168.0.12设置主机名：dannbook# dhcp服务的静态绑定# dhcp-host=08:00:27:D1:CF:E2,192.168.8.201,infinite 无限租期dhcp-host=08:00:27:D1:CF:E2,192.168.8.201,db2dhcp-host=08:00:27:D6:F0:9F,192.168.8.202,db3# 注意:当为某一MAC地址同时静态分配主机名和IP时，如果写到两条dhcp-host选项里（如下所示），则只会生效后面的一条。正确的选项写法如上配置。dhcp-host=08:00:27:D1:CF:E2,192.168.8.201 dhcp-host=08:00:27:D1:CF:E2,db2dhcp-host=08:00:27:D1:CF:E2,192.168.8.201dhcp-host=08:00:27:D1:CF:E2,db2# 重新启动客户端网卡。由于之前测试中客户端网卡已经申请了DHCP租期。所以这里需要修改租期文件，让客户端重新获得IP和hostname。# 设置默认租期# Set the limit on DHCP leases, the default is 150#dhcp-lease-max=150# 租期保存文件#dhcp-leasefile=/var/lib/dnsmasq/dnsmasq.leases# 通过/etc/hosts来分配对应的hostname#dhcp-host=judge# 忽略下面MAC地址的DHCP请求#dhcp-host=11:22:33:44:55:66,ignore # dhcp所在的domaindomain=freeoa.net # 设置默认路由出口# dhcp-option遵循RFC 2132（Options and BOOTP Vendor Extensions),可以通过dnsmasq --help dhcp来查看具体的配置# 很多高级的配置，如iSCSI连接配置等同样可以由RFC 2132定义的dhcp-option中给出。# option 3为default routedhcp-option=3,192.168.8.1# 设置NTP Server.这是使用option name而非选项名来进行设置#dhcp-option=option:ntp-server,192.168.8.4,10.10.0.5 dnsmasq命令选项说明-T, –local-ttl= 当与从/ etc / hosts或在DHCP租约文件，默认设置的dnsmasq信息返回到本机ttl值为零，这意味着请求者不应本身缓存信息。此选项允许设定dhcp请求数据包的生存时间。这将减少在某些情况下过时的请求数据给客户端服务器造成的负载。 -x, –pid-file= 指定一个备用的路径来记录进程ID通常保存的目录为/ var/ dnsmasq.pid。 -v, –version 打印版本号。 -p, –port= 指定DNS的端口代替标准的DNS端口（53）。设置此为零完全禁用DNS功能，只留下DHCP和/或TFTP。-P,–edns-packet-max= 指定DNS转发支持的最大数据包大小。 默认是1280，这是以太网RFC2671建议的最大值。 -i, –interface= 只监听指定的接口。当此命令指定的接口被使用时，dnsmasq会自动添加本地接口到接口列表。 -I, –except-interface= 指定不监听的接口。 -2, –no-dhcp-interface= 不提供DHCP或TFTP在指定的接口，但提供DNS服务。-a,–listen-address= 侦听指定的IP地址。监听的接口和IP地址可同时指定。如果指定监听的IP地址而指定未监听接口的，dnsmasq不会自动监听去回环节口（loopback）。所以如果配置此选项一般要明确的给出监听地址的为127.0.0.1 -r, –resolv-file= 读取文件上的域名服务器的IP地址，dnsmasq可轮询多个resolv.conf文件的域名服务器。 -R, –no-resolv 不要读取/ etc / resolv.conf中。只得到命令行或配置文件中的dnsmasq上游域名服务器。 -c, –cache-size= 设置的dnsmasq的缓存大小。默认为150条。设置缓存大小为零禁用缓存。 -N, –no-negcache 禁用否定缓存。否定缓存允许dnsmasq记住从上游域名服务器上得到的“没有这样的域名”的查询结果，并对于相同的查询不再重复转发轮询上游服务器。 -0, –dns-forward-max= 设置DNS的查询并发的最大数量。默认值是150。 -F,–dhcp-range=[[net:]network-id,],[[,],][,] 启用DHCP服务器。地址将会给出了从范围到和静态定义的地址在DHCP主机选项给出。如果租用时间给出，然后租赁将会给予该时间长度。租用时间以秒或分钟（如4500）或时间（如1小时）或无限期“infinite”。最低租赁时间为两分钟。广播地址始终是可选的。-u,–user=指定用户ID，开始的dnsmasq通常必须为root身份。 -k, –keep-in-foreground不在后台进行fork，不运行debug模式 -K, –dhcp-authoritative当一个网络上只有确定的一台DHCP服务器时，此参数应该被设置成dhcp-authoritative。这样可以确保从未知主机发送的未知租约不会被忽略。这样就使得新的主机在任何情况下及时的得到租约请求相应。还有一个重要作用是，当服务器的租赁数据库丢失了，此参数可以允许dnsmasq重建租约数据库，而不用与每个客户主机逐一重新请求租约。 -X, –dhcp-lease-max= 限制的dnsmasq到DHCP租约规定的最大数目。默认为150。此限制是为了防止非法主机从服务器租赁大量的ip地址造成内存大量占用，从而形成DoS攻击。 –log-dhcp 额外的DHCP日志记录：记录所有的选项发送到DHCP客户端和用于确定他们的NetID标签。 -l, –dhcp-leasefile= 使用指定的文件存储DHCP的租赁信息。存储的信息包括客户端的MAC地址，ip地址，计算机名等。 -C, –conf-file=指定一个不同的配置文件。此配置文件选项也允许在配置文件中使用，以包含多个配置文件。 参考链接 http://www.freeoa.net/osuport/servap/dnsmasq-use-intro-refer_2480.html https://wiki.archlinux.org/index.php/Dnsmasq_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29]]></content>
      <categories>
        <category>Services</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>DHCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keepalived（6）实现基于多虚拟路由的master/master模型]]></title>
    <url>%2F2018%2F01%2F07%2F2018-01-07-211738-Keepalived%EF%BC%886%EF%BC%89%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E%E5%A4%9A%E8%99%9A%E6%8B%9F%E8%B7%AF%E7%94%B1%E7%9A%84master-master%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"></content>
      <categories>
        <category>keepalived</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
        <tag>ha</tag>
        <tag>keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keepalived（5）对某特定服务做高可用]]></title>
    <url>%2F2018%2F01%2F07%2F2018-01-07-211254-Keepalived%EF%BC%885%EF%BC%89%E5%AF%B9%E6%9F%90%E7%89%B9%E5%AE%9A%E6%9C%8D%E5%8A%A1%E5%81%9A%E9%AB%98%E5%8F%AF%E7%94%A8%2F</url>
    <content type="text"></content>
      <categories>
        <category>keepalived</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
        <tag>ha</tag>
        <tag>keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keepalived（4）配置Ipvs]]></title>
    <url>%2F2018%2F01%2F07%2F2018-01-07-204528-Keepalived%EF%BC%884%EF%BC%89%E9%85%8D%E7%BD%AEIpvs%2F</url>
    <content type="text"></content>
      <categories>
        <category>keepalived</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
        <tag>ha</tag>
        <tag>keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keepalived（3）在状态转换时进行通知]]></title>
    <url>%2F2018%2F01%2F07%2F2018-01-07-203907-Keepalived%EF%BC%883%EF%BC%89%E5%9C%A8%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E6%97%B6%E8%BF%9B%E8%A1%8C%E9%80%9A%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[要在状态转换是进行通知，需要定义通知脚本可以在vrrp_sync_group{}中定义，也可以在vrrp_instance{}中定义 脚本定义的两种方法通过man keepalived.conf命令可以查看通知脚本定义的两种方法 方法一12345678910111213141516171819 # notify scripts and alerts are optional # # filenames of scripts to run on transitions # can be unquoted (if just filename) # or quoted (if it has parameters) # The username and groupname specify the user and group # under which the scripts should be run. If username is # specified, the group defaults to the group of the user. # If username is not specified, they default to the # global script_user and script_group # to MASTER transition notify_master /path/to_master.sh [username [groupname]] # to BACKUP transition notify_backup /path/to_backup.sh [username [groupname]] # FAULT transition notify_fault "/path/fault.sh VG_1" [username [groupname]] 方法二12345678910111213 # for ANY state transition. # "notify" script is called AFTER the # notify_* script(s) and is executed # with 4 arguments provided by Keepalived # (so don't include parameters in the notify line). # arguments # $1 = "GROUP"|"INSTANCE" # $2 = name of the group or instance # $3 = target state of transition # ("MASTER"|"BACKUP"|"FAULT") # $4 = priority value notify /path/notify.sh [username [groupname]] 示例 由于要用到mail命令，因此需要保证mailx包是安装的 1234yum -y install mailxsed -ri '/^inet_interfaces = localhost$/s#localhost#all#' /etc/postfix/main.cfsystemctl enable postfix systemctl restart postfix 脚本/usr/local/keepalived/scripts/keepalived_notify.sh内容 需要chmod +x添加执行权限 所有Keepalived节点都应该创建此脚本 123456789101112131415161718192021222324252627282930#!/bin/bash#description: An example of notify script#vip=192.168.200.163contact='root@localhost'notify()&#123; mailsubject="`hostname` to be $1: $&#123;vip&#125; floating" mailbody="`date '+%F %H:%M:%S'`: vrrp transition, `hostname` changed to be $1" echo $｛mailbody｝ | mail -s "$&#123;mailsubject&#125;" $&#123;contact&#125;&#125;case "$1" in master) notify master exit 0 ;; backup) notify backup exit 0 ;; fault) notify fault exit 0 ;; *) echo 'Usage: `basename $0`&#123; master | backup | fault &#125;' exit 1 ;;esac 在所有Keepalived节点上配置/etc/keepalived/keepalived.conf 1234567vrrp_instance VI_1 &#123;# 省略部分内容# 。。。。。。 notify_master "/usr/local/keepalived/scripts/keepalived_notify.sh master" notify_backup "/usr/local/keepalived/scripts/keepalived_notify.sh backup" notify_fault "/usr/local/keepalived/scripts/keepalived_notify.sh fault"&#125; 重启服务 1ansible -i /etc/ansible/keepalived.hosts all -m shell -a 'systemctl restart keepalived' 测试 1ansible -i /etc/ansible/keepalived.hosts node1 -m shell -a 'touch /etc/keepalived/down' 分别在Keepalived节点使用mail命令查看邮件]]></content>
      <categories>
        <category>keepalived</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
        <tag>ha</tag>
        <tag>keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keepalived（2）配置实现IP漂移]]></title>
    <url>%2F2018%2F01%2F07%2F2018-01-07-203145-Keepalived%EF%BC%882%EF%BC%89%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0IP%E6%BC%82%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[IP漂移 这是一个Keepalived的单独使用配置实例。 基础环境配置为了配置方便，我们使用一个ansible服务器来批量操作多台节点，这里我们使用了两个节点：node1和node2来做效果演示 IP信息，三台节点时间要做同步 ansible：192.168.127.130 node1：192.168.127.133 node2：192.168.127.134 ansible对node的ssh互信配置 12345678# ansible serverssh-keygen -t rsa -C 'root@ansible' -N ''# 创建ssh密钥ssh-copy-id root@192.168.127.133ssh-copy-id root@192.168.127.134# 拷贝公钥，做到ssh互信 ansible针对Keepalived单独创建Inventory 12345678910# 创建Keepalived的Inventory# /etc/ansible/keepalived.hosts[node]node1 ansible_ssh_host=192.168.127.133node2 ansible_ssh_host=192.168.127.134[node:vars]ssh_ansible_port=22ssh_ansible_user=root 批量安装12345678ansible -i /etc/ansible/keepalived.hosts all -m yum -a 'name=keepalived state=present' # 使用yum安装Keepalivedansible -i /etc/ansible/keepalived.hosts all -m shell -a 'rpm -qc keepalived' # 查看生成的配置文件ansible -i /etc/ansible/keepalived.hosts all -m shell -a 'cp /etc/keepalived/keepalived.conf&#123;,.bak&#125;'# 配置文件备份 节点的配置按照如下做配置，其余配置不动 节点node1 123456789101112131415161718192021222324252627282930313233! Configuration File for keepalivedglobal_defs &#123; notification_email &#123; root@localhost # 收邮件人，可以定义多个 &#125; notification_email_from kaadmin@localhost # 发邮件人，这里可以伪装 smtp_server 127.0.0.1 # 发送邮件的服务器地址 smtp_connect_timeout 30 # 连接超时时间 router_id LVS_DEVEL vrrp_skip_check_adv_addr vrrp_strict vrrp_garp_interval 0 vrrp_gna_interval 0&#125;vrrp_instance VI_1 &#123; # 每一个vrrp_instance就是定义一个虚拟路由器的 state MASTER # 由初始状态状态转换为 MASTER 状态 interface eth0 virtual_router_id 51 # 虚拟路由的id号，一般不能大于255的 priority 100 # 初始化优先级 advert_int 1 # 初始化通告 authentication &#123; # 认证机制 auth_type PASS auth_pass 1111 # 密码 &#125; virtual_ipaddress &#123; # 虚拟地址vip 192.168.200.163/24 brd 192.168.200.254 dev eth0 192.168.200.164/24 brd 192.168.200.254 dev eth0 192.168.200.165/24 brd 192.168.200.254 dev eth0 192.168.200.166/24 brd 192.168.200.254 dev eth0 &#125;&#125; 节点node2配置；把node1配置文件复制到node2上一份，并修改初始状态和优先级需要修改的地方：state和priority 1234567891011121314151617vrrp_instance VI_1 &#123; # 每一个vrrp_instance就是标识一个虚拟路由器的 state BACKUP # 由初始状态状态转换为 BACKUP 状态 interface eth0 # 通过哪块网卡选举 virtual_router_id 51 # 虚拟路由的id号，一般不能大于255的 priority 90 # 初始化优先级，一定要比master的优先级要低 advert_int 1 # 初始化通告 authentication &#123; # 认证机制 auth_type PASS # 认证方式，PASS为明文 auth_pass 1111 # 密码 &#125; virtual_ipaddress &#123; # 虚拟地址（vip）池 192.168.200.163/24 brd 192.168.200.254 dev eth0 192.168.200.164/24 brd 192.168.200.254 dev eth0 192.168.200.165/24 brd 192.168.200.254 dev eth0 192.168.200.166/24 brd 192.168.200.254 dev eth0 &#125;&#125; 测试与验证12ansible -i /etc/ansible/keepalived.hosts all -m shell -a 'systemctl start keepalived'# 启动两个节点的Keepalived服务 12ansible -i /etc/ansible/keepalived.hosts all -m shell -a 'systemctl status keepalived'# 查看两个节点的Keepalived服务状态 12345678910111213141516171819202122232425node1 | SUCCESS | rc=0 &gt;&gt;● keepalived.service - LVS and VRRP High Availability Monitor Loaded: loaded (/usr/lib/systemd/system/keepalived.service; disabled; vendor preset: disabled) Active: active (running) since Wed 2018-01-10 21:16:31 CST; 4min 36s ago Process: 2638 ExecStart=/usr/sbin/keepalived $KEEPALIVED_OPTIONS (code=exited, status=0/SUCCESS) Main PID: 2639 (keepalived) CGroup: /system.slice/keepalived.service ├─2639 /usr/sbin/keepalived -D ├─2640 /usr/sbin/keepalived -D └─2641 /usr/sbin/keepalived -D# 省略部分内容......node2 | SUCCESS | rc=0 &gt;&gt;● keepalived.service - LVS and VRRP High Availability Monitor Loaded: loaded (/usr/lib/systemd/system/keepalived.service; disabled; vendor preset: disabled) Active: active (running) since Wed 2018-01-10 21:16:31 CST; 4min 36s ago Process: 3393 ExecStart=/usr/sbin/keepalived $KEEPALIVED_OPTIONS (code=exited, status=0/SUCCESS) Main PID: 3394 (keepalived) CGroup: /system.slice/keepalived.service ├─3394 /usr/sbin/keepalived -D ├─3395 /usr/sbin/keepalived -D └─3396 /usr/sbin/keepalived -D # 省略部分内容...... 12ansible -i /etc/ansible/keepalived.hosts all -m shell -a 'ip addr show dev eth0 | egrep "inet"'# 查看两个节点上的VIP 123456789node1 | SUCCESS | rc=0 &gt;&gt; inet 192.168.127.133/24 brd 192.168.127.255 scope global dynamic eth0 inet 192.168.200.163/24 brd 192.168.200.254 scope global eth0 inet 192.168.200.164/24 brd 192.168.200.254 scope global secondary eth0 inet 192.168.200.165/24 brd 192.168.200.254 scope global secondary eth0 inet 192.168.200.166/24 brd 192.168.200.254 scope global secondary eth0node2 | SUCCESS | rc=0 &gt;&gt; inet 192.168.127.134/24 brd 192.168.127.255 scope global dynamic eth0 12345ansible -i /etc/ansible/keepalived.hosts node1 -m shell -a 'systemctl stop keepalived' # 停掉node1的Keepalived服务ansible -i /etc/ansible/keepalived.hosts all -m shell -a 'ip addr show dev eth0 | egrep "inet"'# 再次查看两个节点上的VIP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980node2 | SUCCESS | rc=0 &gt;&gt; inet 192.168.127.134/24 brd 192.168.127.255 scope global dynamic eth0 inet 192.168.200.163/24 brd 192.168.200.254 scope global eth0 inet 192.168.200.164/24 brd 192.168.200.254 scope global secondary eth0 inet 192.168.200.165/24 brd 192.168.200.254 scope global secondary eth0 inet 192.168.200.166/24 brd 192.168.200.254 scope global secondary eth0node1 | SUCCESS | rc=0 &gt;&gt; inet 192.168.127.133/24 brd 192.168.127.255 scope global dynamic eth0``` ## vrrp_script使用范例可以在配置文件中手动通过 vrrp_script 定义一个外围的检测机制，并在 vrrp_instance 中通过定义 track_script 来追踪脚本执行过程，实现节点转移- keepalived会定时执行脚本并对脚本执行的结果进行分析，动态调整vrrp_instance的优先级。 - 如果脚本执行结果为0，并且weight配置的值大于0，则优先级相应的增加 - 如果脚本执行结果非0，并且weight配置的值小于0，则优先级相应的减少 - 其他情况，维持原本配置的优先级，即配置文件中priority对应的值。- 这里需要注意的是： - 1） 优先级“不会”不断的提高或者降低，当track的对象恢复时，又是一致的 - 2） 可以编写多个检测脚本并为每个检测脚本设置不同的weight - 3） 不管提高优先级还是降低优先级，最终优先级的范围是在[1,254]，不会出现优先级小于等于0或者优先级大于等于255的情况- 这样可以做到利用脚本检测业务进程的状态，并动态调整优先级从而实现主备切换。实验测试在两个节点上的`/etc/keepalived/keepalived.conf`中做如下的修改``` bash! Configuration File for keepalivedglobal_defs &#123; notification_email &#123; root@localhost # 收邮件人，可以定义多个 &#125; notification_email_from kaadmin@localhost # 发邮件人，这里可以伪装 smtp_server 127.0.0.1 # 发送邮件的服务器地址 chk_maintainace smtp_connect_timeout 30 # 连接超时时间 router_id LVS_DEVEL vrrp_skip_check_adv_addr vrrp_strict vrrp_garp_interval 0 vrrp_gna_interval 0&#125;# ----------------------------------------------------------------vrrp_script chk_maintainace &#123; # 检测机制的脚本名称为chk_maintainace script "/usr/local/keepalived/scripts/chk_down.sh" # 可以是个脚本路径，也可以是脚本命令 interval 1 # 每隔1秒中检测一次 weight -20 # 优先级减20，设置的太小可能会不生效&#125;# ----------------------------------------------------------------vrrp_instance VI_1 &#123; # 每一个vrrp_instance就是定义一个虚拟路由器的 state MASTER # 由初始状态状态转换为 MASTER 状态 interface eth0 virtual_router_id 51 # 虚拟路由的id号，一般不能大于255的 priority 100 # 初始化优先级 advert_int 1 # 初始化通告 authentication &#123; # 认证机制 auth_type PASS auth_pass 1111 # 密码 &#125; virtual_ipaddress &#123; # 虚拟地址vip 192.168.200.163/24 brd 192.168.200.254 dev eth0 192.168.200.164/24 brd 192.168.200.254 dev eth0 192.168.200.165/24 brd 192.168.200.254 dev eth0 192.168.200.166/24 brd 192.168.200.254 dev eth0 &#125; # ---------------------------------------------------------------- track_script &#123; # 调用外围脚本，追踪外围脚本执行过程 chk_maintainace &#125; # ----------------------------------------------------------------&#125; 脚本/usr/local/keepalived/scripts/chk_down.sh内容 123456789#!/bin/bashDown_File='/etc/keepalived/down'if test -e $&#123;Down_File&#125; ;then exit 1else exit 0fi 测试 12ansible -i /etc/ansible/keepalived.hosts all -m shell -a 'ip addr show dev eth0 | egrep "inet"'# 查看两个节点上的VIP 123456789node1 | SUCCESS | rc=0 &gt;&gt; inet 192.168.127.133/24 brd 192.168.127.255 scope global dynamic eth0 inet 192.168.200.163/24 brd 192.168.200.254 scope global eth0 inet 192.168.200.164/24 brd 192.168.200.254 scope global secondary eth0 inet 192.168.200.165/24 brd 192.168.200.254 scope global secondary eth0 inet 192.168.200.166/24 brd 192.168.200.254 scope global secondary eth0node2 | SUCCESS | rc=0 &gt;&gt; inet 192.168.127.134/24 brd 192.168.127.255 scope global dynamic eth0 12345ansible -i /etc/ansible/keepalived.hosts node1 -m shell -a 'touch /etc/keepalived/down'# 在node1上创建普通文件down，node2不动ansible -i /etc/ansible/keepalived.hosts all -m shell -a 'systemctl restart keepalived'# 两个节点均重启Keepalived服务 12ansible -i /etc/ansible/keepalived.hosts all -m shell -a 'ip addr show dev eth0 | egrep "inet"'# 查看两个节点上的VIP 123456789node1 | SUCCESS | rc=0 &gt;&gt; inet 192.168.127.133/24 brd 192.168.127.255 scope global dynamic eth0node2 | SUCCESS | rc=0 &gt;&gt; inet 192.168.127.134/24 brd 192.168.127.255 scope global dynamic eth0 inet 192.168.200.163/24 brd 192.168.200.254 scope global eth0 inet 192.168.200.164/24 brd 192.168.200.254 scope global secondary eth0 inet 192.168.200.165/24 brd 192.168.200.254 scope global secondary eth0 inet 192.168.200.166/24 brd 192.168.200.254 scope global secondary eth0 12345ansible -i /etc/ansible/keepalived.hosts node1 -m shell -a 'rm -f /etc/keepalived/down'# 在node1上删除普通文件down，node2不动ansible -i /etc/ansible/keepalived.hosts all -m shell -a 'ip addr show dev eth0 | egrep "inet"'# 查看两个节点上的VIP 123456789node1 | SUCCESS | rc=0 &gt;&gt; inet 192.168.127.133/24 brd 192.168.127.255 scope global dynamic eth0 inet 192.168.200.163/24 brd 192.168.200.254 scope global eth0 inet 192.168.200.164/24 brd 192.168.200.254 scope global secondary eth0 inet 192.168.200.165/24 brd 192.168.200.254 scope global secondary eth0 inet 192.168.200.166/24 brd 192.168.200.254 scope global secondary eth0node2 | SUCCESS | rc=0 &gt;&gt; inet 192.168.127.134/24 brd 192.168.127.255 scope global dynamic eth0]]></content>
      <categories>
        <category>keepalived</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
        <tag>ha</tag>
        <tag>keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keepalived（1）安装配置]]></title>
    <url>%2F2018%2F01%2F07%2F2018-01-07-195142-Keepalived%EF%BC%881%EF%BC%89%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[安装本文基于 CentOS Linux release 7.4.1708 安装和配置 yum安装1yum -y install keepalived 源码包编译安装官方下载链接：http://www.keepalived.org/download.html 123456cd /opt/wget http://www.keepalived.org/software/keepalived-1.4.0.tar.gztar xf keepalived-1.4.0.tar.gz cd keepalived-1.4.0./configure make &amp;&amp; make install 配置环境配置由于keepalived服务之间需要使用VRRP协议进行通信，因此需要进行防火墙配置 123iptables -I INPUT -d 224.0.0.0/8 -j ACCEPTiptables -I INPUT -p vrrp -j ACCEPTiptables -I OUTPUT -p vrrp -j ACCEPT 配置文件说明 配置文件路径 1/etc/keepalived/keepalived.conf Keeaplived的配置包含三部分 全局配置，配置邮件等 VRRPD配置，配置VRRP实例 LVS配置，配置LVS的应用服务器 若只是单独使用keepalived，通过IP漂移实现服务的高可用，则只需要配置前两部分就可以；若结合LVS使用，实现LVS负载均衡层的高可用、应用服务层的状态监控，则还需要配置第三部分。]]></content>
      <categories>
        <category>keepalived</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
        <tag>ha</tag>
        <tag>keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keepalived简介]]></title>
    <url>%2F2018%2F01%2F07%2F2018-01-07-195124-Keepalived%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[KeepalivedKeepalived是一款免费开源的，用C编写的类似于layer3, 4 &amp; 7交换机制软件，具备我们平时说的第3层、第4层和第7层交换机的功能。 主要提供 loadbalancing（负载均衡）和high-availability（高可用）功能。负载均衡实现需要依赖Linux的虚拟服务内核模块（ipvs），而高可用是通过VRRP协议实现多台机器之间的故障转移服务。 对LVS应用服务层的应用服务器集群进行状态监控：若应用服务器不可用，则keepalived将其从集群中摘除，若应用服务器恢复，则keepalived将其重新加入集群中。 通过IP漂移，实现服务的高可用：服务器集群共享一个虚拟IP，同一时间只有一个服务器占有虚拟IP并对外提供服务，若该服务器不可用，则虚拟IP漂移至另一台服务器并对外提供服务； Keepalived体系结构 上图是Keepalived的功能体系结构，大致分两层： 内核空间：主要包括IPVS（IP虚拟服务器，用于实现网络服务的负载均衡）和NETLINK（提供高级路由及其他相关的网络功能）两个部份。 用户空间： WatchDog：负载监控checkers和VRRP进程的状况 VRRP Stack：负载负载均衡器之间的失败切换FailOver，如果只用一个负载均稀器，则VRRP不是必须的。 Checkers：负责真实服务器的健康检查healthchecking，是keepalived最主要的功能。换言之，可以没有VRRP Stack，但健康检查healthchecking是一定要有的。 IPVS wrapper：用户发送设定的规则到内核ipvs代码 Netlink Reflector：用来设定vrrp的vip地址等。 Keepalived原理之VRRPVRRP技术白皮书：http://www.h3c.com/cn/d_200802/335873_30003_0.htm 注意： 为了方便个人查找和阅读，这里将白皮书中的可能用到的部分内容做了摘要 Keepalived的实现基于VRRP，而VRRP是为了解决静态路由的高可用。 技术优点VRRP（Virtual Router Redundancy Protocol，虚拟路由器冗余协议），它保证当主机的下一跳路由器出现故障时，由另一台路由器来代替出现故障的路由器进行工作，从而保持网络通信的连续性和可靠性。 简化网络管理。在具有多播或广播能力的局域网（如以太网）中，借助VRRP能在某台设备出现故障时仍然提供高可靠的缺省链路，有效避免单一链路发生故障后网络中断的问题，而无需修改动态路由协议、路由发现协议等配置信息，也无需修改主机的默认网关配置。 适应性强。VRRP报文封装在IP报文中，支持各种上层协议。 网络开销小。VRRP只定义了一种报文——VRRP通告报文，并且只有处于Master状态的路由器可以发送VRRP报文。 VRRP协议介绍相关术语 虚拟路由器：由一个Master路由器和多个Backup路由器组成。主机将虚拟路由器当作默认网关。 VRID：虚拟路由器的标识。有相同VRID的一组路由器构成一个虚拟路由器。 Master路由器：虚拟路由器中承担报文转发任务的路由器。 Backup路由器：Master路由器出现故障时，能够代替Master路由器工作的路由器。 虚拟IP地址：虚拟路由器的IP地址。一个虚拟路由器可以拥有一个或多个IP地址。 IP地址拥有者：接口IP地址与虚拟IP地址相同的路由器被称为IP地址拥有者。 虚拟MAC地址：一个虚拟路由器拥有一个虚拟MAC地址。虚拟MAC地址的格式为00-00-5E-00-01-{VRID}。通常情况下，虚拟路由器回应ARP请求使用的是虚拟MAC地址，只有虚拟路由器做特殊配置的时候，才回应接口的真实MAC地址。 优先级：VRRP根据优先级来确定虚拟路由器中每台路由器的地位。 非抢占方式：如果Backup路由器工作在非抢占方式下，则只要Master路由器没有出现故障，Backup路由器即使随后被配置了更高的优先级也不会成为Master路由器。 抢占方式：如果Backup路由器工作在抢占方式下，当它收到VRRP报文后，会将自己的优先级与通告报文中的优先级进行比较。如果自己的优先级比当前的 Master 路由器的优先级高，就会主动抢占成为Master路由器；否则，将保持Backup状态。 虚拟路由器简介 VRRP将局域网内的一组路由器划分在一起，形成一个VRRP备份组，它在功能上相当于一台虚拟路由器，使用虚拟路由器号进行标识。以下使用虚拟路由器代替VRRP备份组进行描述。 虚拟路由器有自己的虚拟IP地址（VIP）和虚拟MAC地址，它的外在表现形式和实际的物理路由器完全一样。局域网内的主机将虚拟路由器的IP地址设置为默认网关，通过虚拟路由器与外部网络进行通信。 虚拟路由器是工作在实际的物理路由器之上的。它由多个实际的路由器组成，包括一个Master路由器和多个Backup路由器。Master路由器正常工作时，局域网内的主机通过Master与外界通信。当Master路由器出现故障时，Backup路由器中的一台设备将成为新的 Master 路由器，接替转发报文的工作，如图2所示。 VRRP工作过程(1) 虚拟路由器中的路由器根据优先级选举出Master。Master路由器通过发送免费ARP报文，将自己的虚拟MAC地址通知给与它连接的设备或者主机，从而承担报文转发任务； (2) MASTER 路由器周期性以IP组播（组播地址：224.0.0.18）形式发送VRRP报文，以公布其配置信息（优先级等）和工作状况，与 BACKUP 保持心跳连接； (3) 如果 MASTER 路由器出现故障（或 BACKUP 接收不到VRRP协议包），虚拟路由器中的 BACKUP 路由器将根据优先级重新选举新的 MASTER； (4) 虚拟路由器状态切换时， MASTER 路由器由一台设备切换为另外一台设备，新的 MASTER 路由器只是简单地发送一个携带虚拟路由器的MAC地址和虚拟IP地址信息的免费ARP报文，这样就可以更新与它连接的主机或设备中的ARP相关信息。网络中的主机感知不到 MASTER 路由器已经切换为另外一台设备。 (5) BACKUP 路由器的优先级高于 MASTER 路由器时，由 BACKUP 路由器的工作方式（抢占方式和非抢占方式）决定是否重新选举Master。 由此可见，为了保证 MASTER 路由器和 BACKUP 路由器能够协调工作，VRRP需要实现以下功能： MASTER 路由器的选举； MASTER 路由器状态的通告； 同时，为了提高安全性，VRRP还提供了认证功能； VRRP优先级别 VRRP每个节点是有自己的优先级的，一般优先级是从0-255，数字越大优先级越高。因此可以这么定义：假如要有一初始化的状态，其中一节点优先级100另一节点优先级99，那么毫无疑问，谁的优先级高谁就是主节点。 所有的节点刚启动后上线都是 BACKUP 状态，需通过选举的方式选择 MASTER，如果其他节点没有响应则将自己提升为 MASTER 通告机制：如果节点之间 MASTER 出现故障，其会自动转移当前角色，这时我们的管理员应该知道其已切换角色keepalived支持邮件发送机制，如果其状态发生改变的话可以通过邮件方式发送给管理员，使管理员第一时间可以查看其活动状态，方便之后的运维工作 Keepalived工作原理Keepalived的作用是检测服务器的状态，如果有一台服务器死机或工作出现故障，Keepalived将检测到并将有故障的服务器从系统中剔除，当服务器工作正常后Keepalived自动将服务器加入到服务器群中，这些工作全部自动完成，不需要人工干涉，需要人工做的只是修复故障的服务器。 核心组件： vrrp的实现 virtual_server：基于vrrp作为所谓通告机制之上的 vrrp_script：以外部脚本方式进行检测 Layer3，4&amp;7工作在IP/TCP协议栈的IP层，TCP层，及应用层，原理分别如下： Layer3：Keepalived使用Layer3的方式工作式时，Keepalived会定期向服务器群中的服务器发送一个ICMP的数据包（既我们平时用的Ping），如果发现某台服务的IP地址没有激活，Keepalived便报告这台服务器失效，并将它从服务器群中剔除，这种情况的典型例子是某台服务器被非法关机。Layer3的方式是以服务器的IP地址是否有效作为服务器工作正常与否的标准。 Layer4：Layer4主要以TCP端口的状态来决定服务器工作正常与否。如web server的服务端口一般是80，如果Keepalived检测到80端口没有启动，则Keepalived将把这台服务器从服务器群中剔除。 Layer7：工作在具体的应用层，比Layer3，Layer4要复杂一点，在网络上占用的带宽也要大一些。Keepalived将根据用户的设定检查服务器程序的运行是否正常，如果与用户的设定不相符，则Keepalived将把服务器从服务器群中剔除。]]></content>
      <categories>
        <category>keepalived</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
        <tag>ha</tag>
        <tag>keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux查看操作系统位数的几种方法]]></title>
    <url>%2F2017%2F12%2F30%2F2017-12-30-140810-Linux%E6%9F%A5%E7%9C%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%8D%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[getconf命令12[ltj@centos-7.3 ~]$ getconf LONG_BIT64 12[ltj@test ~]$ getconf LONG_BIT32 内置系统环境变量HOSTTYPE12[ltj@centos-7.3 ~]$ echo $HOSTTYPE x86_64 12[ltj@test ~]$ echo $HOSTTYPE i686 uname命令 x86_64表示64位系统， i686 i386表示32位系统。 i686 只是i386的一个子集，支持的cpu从Pentium 2 (686)开始，之前的型号不支持。 1234[ltj@centos-7.3 ~]$ uname -aLinux centos-7.3 3.10.0-514.el7.x86_64 #1 SMP Tue Nov 22 16:42:41 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux[ltj@centos-7.3 ~]$ uname -mx86_64 arch命令12[ltj@centos-7.3 ~]$ arch x86_64 12[ltj@test ~]$ archi686 file命令123[ltj@centos-7.3 ~]$ file /bin/ls/bin/ls: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=3d705971a4c4544545cb78fd890d27bf792af6d4, stripped# 系统为64位 123[ltj@test ~]$ file /bin/ls /bin/ls: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), for GNU/Linux 2.6.9, dynamically linked (uses shared libs), for GNU/Linux 2.6.9, stripped# 系统为32位 查看CPU信息可确定是否支持64bit计算lm ： long mode，如果能搜索到则说明支持，否则不支持 1egrep '^flags.*\&lt;lm\&gt;' /proc/cpuinfo]]></content>
      <categories>
        <category>Linux命令</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell用法整理]]></title>
    <url>%2F2017%2F12%2F29%2F2017-12-29-160710-shell%E7%94%A8%E6%B3%95%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[使用set和eval取当前的运行级别源码出自CentOS6.X系统sshd服务脚本：/etc/init.d/sshd 1runlevel=$(set -- $(runlevel); eval "echo \$$#" ) 解析 将runlevel命令执行结果通过set –根据分隔符IFS，把值依次赋给位置参数($1,$2,$3…) 123456789[ltj@centos6 ~]$ runlevel N 3[ltj@centos6 ~]$ set -- $(runlevel)[ltj@centos6 ~]$ echo $1N[ltj@centos6 ~]$ echo $23[ltj@centos6 ~]$ echo $1 $2N 3 $#取得位置参数的个数为两个 12[ltj@centos6 ~]$ echo $#2 要取的数值为第二个即最后一个，使用$2即可取得第二个位置参数，这里的2使用$#来代替 由于$$代表当前命令的PID，因此需要转义$即\$$# 要用eval做二次扫描，把echo的字符串当做命令解析，第二次解析$2的值为3 不进行解析的话$2只能当做纯字符串输出 12345678910[ltj@centos6 ~]$ echo $$# 29826## 这里$$输出了进程pid，然后输出#[ltj@centos6 ~]$ echo \$$#$2# 等同于 echo $2[ltj@centos6 ~]$ eval "echo \$$#"3 判断变量是否为整数 方法一：使用expr做计算，判断命令执行返回值 12expr $1 + 1 &amp;&gt;/dev/null[ $? -eq 0 ] &amp;&amp; echo "int" || echo "not int" 方法二：使用变量字符串替换的结果做条件判断 1234num=2[ -n $&#123;num&#125; -a "$&#123;num&#125;" = "$&#123;num//[^0-9]/&#125;" ] &amp;&amp; echo "int" || echo "not int"# 或[ -n $&#123;num&#125; -a -z "$&#123;num//[0-9]/&#125;" ] &amp;&amp; echo "int" || echo "not int" 方法三：使用shell正则做条件判断 12345678check_int()&#123; local char=$1 if [[ $char =~ ^[1-9][0-9]*$ ]];then return 0 else return 1 fi&#125; 匹配指定格式的文件名 源码出自CentOS6.X系统的命令脚本：/usr/bin/ssh-copy-id 这里的expr最好使用绝对路径 123456L_ID_FILE="~/.ssh/test.pub" if expr "$L_ID_FILE" : ".*\.pub$" &gt;/dev/null ; then PUB_ID_FILE="$L_ID_FILE"else PUB_ID_FILE="$L_ID_FILE.pub"fi 解析：此处使用到了expr的表达式expr STRING : REGEXP 示例： 12345[ltj@centos6 ~]$ a=test.txt[ltj@centos6 ~]$ expr $a : ".*\.txt$"8[ltj@centos6 ~]$ expr $a : ".*\.txta$"0 字串STRING中一旦被正则表达式REGEXP，就返回匹配到的字符串的长度，否则返回0 判断字符串是否不为空test &quot;string&quot;等同于[ &quot;string&quot; ]等同于[ -n &quot;string&quot; ] 123456[ltj@centos6 ~]$ test "fdsa" &amp;&amp; echo not null || echo 0not null[ltj@centos6 ~]$ test "" &amp;&amp; echo not null || echo 0 0[ltj@centos6 ~]$ test " " &amp;&amp; echo not null || echo 0not null 使用rename实现批量改文件名 将后缀名.conf改为.conf.bak 12345[ltj@centos-7.3 ~]$ lsopenvpn1.conf openvpn2.conf openvpn3.conf openvpn4.conf openvpn5.conf openvpn6.conf[ltj@centos-7.3 ~]$ rename .conf&#123;,.bak&#125; openvpn*.conf[ltj@centos-7.3 ~]$ lsopenvpn1.conf.bak openvpn2.conf.bak openvpn3.conf.bak openvpn4.conf.bak openvpn5.conf.bak openvpn6.conf.bak 将后缀名.conf.bak改为.conf 12345[ltj@centos-7.3 ~]$ lsopenvpn1.conf.bak openvpn2.conf.bak openvpn3.conf.bak openvpn4.conf.bak openvpn5.conf.bak openvpn6.conf.bak[ltj@centos-7.3 ~]$ rename .conf.bak .conf openvpn*.conf.bak[ltj@centos-7.3 ~]$ lsopenvpn1.conf openvpn2.conf openvpn3.conf openvpn4.conf openvpn5.conf openvpn6.conf 使用内置命令type取命令的路径1234[ltj@centos6 ~]$ type -path ssh/usr/bin/ssh[ltj@centos6 ~]$ which ssh/usr/bin/ssh 检查域名是否被干扰思路： 向根请求解析指定的域名，正常情况下根不会返回任何A记录，只会返回它所属下一级域的NS记录 如果dig +short返回的值为空则说明域名未被干扰， 如果返回一个A记录的IP地址，说明域名在请求解析的途中被拦截或干扰 1234srcip=192.168.2.56name="www.baidu.com"answer=$(dig +short -b $&#123;srcip&#125; @a.root-servers.net. $&#123;name&#125; 2&gt;/dev/null)test -z "$&#123;answer&#125;" &amp;&amp; echo "ok" || echo "not ok"]]></content>
      <categories>
        <category>shell脚本</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux生成随机数的多种方法]]></title>
    <url>%2F2017%2F12%2F28%2F2017-12-28-104610-Linux%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[通过内部系统变量$RANDOM1echo $RANDOM 若超过5位可以加个固定10位整数，然后进行求余。 生成400000~500000的随机数：12345678910111213141516#!/bin/bash function rand()&#123; min=$1 max=$(($2-$min+1)) # 生成0-32767之间的整数随机数 # num=$(echo $RANDOM) # 若要生成5位数以上的随机数，则需要加个固定10位整数，然后进行求余，如下： num=$(($RANDOM+1000000000)) #增加一个10位的数再求余 echo $(($num%$max+$min)) &#125; rnd=$(rand 300000 600000) echo $rnd exit 0 使用awk的随机函数1awk 'BEGIN&#123;srand();print rand()*1000000&#125;' 1awk 'function irand(min, max)&#123;max= max - min + 1;num= rand() * 1000000000;return int(num % max + min);&#125;!a[$1]++&#123;print $1,irand(1,30) &#125;' filename 使用openssl产生随机数openssl rand 用于产生指定长度个bytes的随机字符。-base64或-hex对随机字符串进行base64编码或用hex格式显示。 12openssl rand -base64 8 | md5sum | cut -c1-8 #八位字母和数字的组合，3a61800eopenssl rand -base64 8 | cksum | cut -c1-8 #八位数字，10784736 通过时间获得随机数（date）123date +%s%N #生成19位数字，1287764807051101270date +%s%N | cut -c6-13 #取八位数字，21793709date +%s%N | md5sum | head -c 8 #八位字母和数字的组合，87022fda 生成1~50的随机数：12345678910111213#!/bin/bash function rand()&#123; min=$1 max=$(($2-$min+1)) num=$(date +%s%N) echo $(($num%$max+$min)) &#125; rnd=$(rand 1 50) echo $rnd exit 0 通过系统内唯一数据生成随机数 /dev/random存储系统当前运行的环境的实时数据，可以看作系统某时候的唯一值数据，提供优质随机数。 /dev/urandom是非阻塞的随机数产生器，读取时不会产生阻塞，速度更快、安全性较差的随机数发生器。 123456789101112head -n 10 /dev/urandom | md5sum | head -c 10#d5d0203ac1strings -n 8 /dev/urandom | head -n 1#生成全字符的随机字符串，&lt;5(K^7&amp;Lsed -e 's/[^a-zA-Z0-9]//g' /dev/urandom | strings -n 8 | head -n 1#生成数字加字母的随机字符串，znDllOWB# 其中 strings -n设置字符串的字符数，head -n设置输出的行数。head -200 /dev/urandom| cksum |cut -d" " -f1 #urandom的数据很多使用cat会比较慢，在此使用head读200行，cksum将读取文件内容生成唯一的表示整型数据，cut以” “分割然后得到分割的第一个字段数据 读取linux的uuid码 UUID码全称是通用唯一识别码 (Universally Unique Identifier, UUID) UUID格式是：包含32个16进制数字，以“-”连接号分为五段，形式为8-4-4-4-12的32个字符。 linux的uuid码也是由内核提供的，在/proc/sys/kernel/random/uuid这个文件内。 cat /proc/sys/kernel/random/uuid 每次获取到的数据都会不同。 12345cat /proc/sys/kernel/random/uuid| cksum | cut -f1 -d" " #获取不同的随机整数，2478530622cat /proc/sys/kernel/random/uuid| cksum | cut -f1 -d" "#数字加字母的随机数，cbec400c 使用linux uuid 生成100~500随机数： 12345678910111213#!/bin/bash function rand()&#123; min=$1 max=$(($2-$min+1)) num=$(cat /proc/sys/kernel/random/uuid | cksum | awk -F ' ' '&#123;print $1&#125;') echo $(($num%$max+$min)) &#125; rnd=$(rand 100 500) echo $rnd exit 0 从元素池中随机抽取取123pool=(a b c d e f g h i j k l m n o p q r s t 1 2 3 4 5 6 7 8 9 10)num=$&#123;#pool[*]&#125;result=$&#123;pool[$((RANDOM%num))]&#125; 用于生成一段特定长度的有数字和字母组成的字符串，字符串中元素来自自定义的池子。 1234567891011121314151617181920#!/bin/bash length=8 i=1 seq=(0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z) num_seq=$&#123;#seq[@]&#125; while [ "$i" -le "$length" ] do seqrand[$i]=$&#123;seq[$((RANDOM%num_seq))]&#125; let "i=i+1" done echo "The random string is:" for j in $&#123;seqrand[@]&#125; do echo -n $j done echo 使用mkpasswd需要安装expect 12345mkpasswd # vd69jI/uXmkpasswd -l 13 # 十三位密码：rm22&#125;akbWQcen 参考链接： http://os.51cto.com/art/201403/431110.htm http://www.jb51.net/article/57949.htm]]></content>
      <categories>
        <category>shell脚本</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>随机数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim中一键添加版权信息及常用配置]]></title>
    <url>%2F2017%2F12%2F27%2F2017-12-27-082310-vim%E4%B8%AD%E4%B8%80%E9%94%AE%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9D%83%E4%BF%A1%E6%81%AF%E5%8F%8A%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[简述 在使用vim编写shell程序的时候，我们经常需要在程序首部加入程序的作者、创建时间、程序功能的描述等信息。 这类信息中经常会发生变化的是文件名和最后修改时间，其他信息基本不变。 为了更方便的添加这类信息，我们对vim进行对快捷键映射的配置 另外附上一份对vim的常用配置列表，以便查阅。根据自己的使用习惯做相应的配置 效果示例 风格一 1234567891011#!/usr/bin/env bash# ******************************************************# FileName : test1.sh# Author : Li Tingjie# Create Time : # Last modified : 2016-01-15 00:04:10# Mail : 2234351300@qq.com# Version : 0.0.1# Description : # CopyRight : # ****************************************************** 风格二 12345678910111213#!/usr/bin/env bash:&lt;&lt;:------------------------------------------------ FileName : test2.sh Author : Li Tingjie Create Time : Last modified : 2016-01-15 00:28:44 Mail : 2234351300@qq.com Version : 0.0.1 Description : CopyRight : ------------------------------------------------: 版权信息配置 如果只是针对当前用户做配置，则编辑~/.vimrc加入配置 如果针对所有用户做配置，则编辑/etc/vimrc加入配置 两种风格的配置不能同时加入，否则会冲突 配置中映射的快捷键为F8，也自定义自己习惯的快捷键 配置完成后 在command mode下按快捷键即可添加版权信息 保存退出前按下快捷键更新Last modified 文件名修改后，下次编辑使用快捷键更新FileName 风格一的配置12345678910111213141516171819202122232425262728293031323334353637383940map &lt;F8&gt; :call TitleDet()&lt;cr&gt;function AddTitle() call append(0,"\#!/usr/bin/env bash") call append(1,"# ******************************************************") call append(2,"# FileName : ".expand("%:t")) call append(3,"# Author : Li Tingjie") call append(4,"# Create Time : ") call append(5,"# Last modified : ".strftime("%Y-%m-%d %H:%M:%S")) call append(6,"# Mail : 2234351300@qq.com") call append(7,"# Version : 0.0.1") call append(8,"# Description : ") call append(9,"# CopyRight : ") call append(10,"# ******************************************************") call append(11,"") echohl WarningMsg | echo "Successful in adding copyright." | echohl Noneendf function UpdateTitle() normal m' execute '/Last modified/s@:.*$@\=strftime(": %Y-%m-%d %H:%M:%S")@' normal '' normal mk execute '/FileName/s@:.*$@\=": ".expand("%:t")@' execute "noh" normal 'k echohl WarningMsg | echo "Successful in updating the copyright." | echohl Noneendfunctionfunction TitleDet() let n=1 while n &lt; 10 let line = getline(n) if line =~ '^\#\s*\S*Last\smodified\S*.*$' call UpdateTitle() return endif let n = n + 1 endwhile call AddTitle()endfunction 风格二的配置123456789101112131415161718192021222324252627282930313233343536373839404142map &lt;F8&gt; :call TitleDet()&lt;cr&gt;function AddTitle() call append(0,"\#!/usr/bin/env bash") call append(1,":&lt;&lt;:") call append(2,"------------------------------------------------") call append(3," FileName : ".expand("%:t")) call append(4," Author : Li Tingjie") call append(5," Create Time : ") call append(6," Last modified : ".strftime("%Y-%m-%d %H:%M")) call append(7," Mail : 2234351300@qq.com") call append(8," Version : 0.0.1") call append(9," Description : ") call append(10," CopyRight : ") call append(11,"------------------------------------------------") call append(12,":") call append(13,"") echohl WarningMsg | echo "Successful in adding copyright." | echohl Noneendf function UpdateTitle() normal m' execute '/Last modified/s@:.*$@\=strftime(": %Y-%m-%d %H:%M:%S")@' normal '' normal mk execute '/FileName/s@:.*$@\=": ".expand("%:t")@' execute "noh" normal 'k echohl WarningMsg | echo "Successful in updating the copyright." | echohl Noneendfunctionfunction TitleDet() let n=1 while n &lt; 10 let line = getline(n) if line =~ '^\s*\S*Last\smodified\S*.*$' call UpdateTitle() return endif let n = n + 1 endwhile call AddTitle()endfunction 插件 目前已经有插件实现了上述功能 在安装插件更方便的情况下可以选择安装插件 插件传送门 常用的vim配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677" *************** vim常用的基本设置 ***************set nocompatible " 不使用vi的键盘模式，而是vim自己的"syntax enable " 开启语法高亮功能syntax on " 语法高亮支持set nu " 显示行号"set rnu " 显示相对行号set wrap " 当一行文字很长时自动换行"set nowrap " 当一行文字很长时取消自动换行set showmatch " 当光标移动到一个括号时高亮显示对应的另一个括号set showcmd " 回显输入的命令set showmode " 显示当前的模式set ruler " 在编辑过程中右下角显示光标的行列信息"set nocp " 让Vim工作在不兼容模式下set shortmess=atI " 启动时不显示捐助乌干达儿童的提示set so=6 " 上下滚行时空余6行set autoindent " 自动套用上一行的缩进方式set smartindent " 智能缩进set mouse=a " 开启鼠标支持set laststatus=2 " 总是显示状态行set backspace=indent,eol,start " 对退格键提供更好的支持set ts=4 " 设置tab长度为4set sts=4 " 设置制表符宽度set shiftwidth=4 " 设置缩进空格数set expandtab " 用空格代替tab键set smarttab " 更加智能的tab键set paste " 粘贴保留格式，避免粘贴时排版错乱，设置此项后自动缩进将失效set hid " 当buffer被丢弃时隐藏它set encoding=utf-8 " 默认使用utf-8编码格式set fileencodings=utf-8,cp936,gb18030,big5,euc-kr,latin1 " 自动判断编码时 依次尝试一下编码"set ffs=unix,dos,mac " 设置文件类型set ffs=unixset hlsearch " 高亮搜索内容set ignorecase " 搜索模式里忽略大小写set smartcase " 如果搜索字符串里包含大写字母，则禁用 ignorecaseset incsearch " 显示搜索的动态匹配效果set lazyredraw " 解决某些类型的文件由于syntax导致vim反应过慢的问题set ttyfast " 平滑地变化set cc=80 " 第80字符处显示分隔符set foldmethod=indent " 折叠方式set nofoldenable " 不自动折叠set foldcolumn=1 " 在行号前空出一列的宽度set t_Co=256 " 设置256真彩色set history=1000 " 设置历史记录条数"set autoread " 当文件在外部被修改时自动载入"set cindent " 使用c语言的缩进格式"set whichwrap+=&lt;,&gt;,h,l " 允许backspace和光标键跨越行边界"set cmdheight=2 " 显示两行命令行"set list lcs=tab:\?\ ,trail:? " 显示tab键为?，并且显示每行结尾的空格为'?'" 一些备用字符:?┆┇┊┋???" 格式化状态行显示的内容set statusline=[%t]\ %y\ %m%=%&#123;&amp;fileencoding&#125;\ [%&#123;&amp;ff&#125;]\ [%l,\ %c]\ [%L]\ [%p%%]" ************** 备份设置 ****************"set nobackup " 不进行备份"set nowb " 重新载入文件时不要备份"set noswapfile " 不使用swf文件，可能导致错误无法恢复" *************** 关闭错误声音 **************"set noerrorbells"set novisualbell"set t_vb=" **************** 设置vim主题外观 ***************"set background=light " 设置vim背景为浅色set background=dark " 设置vim背景为深色"set cursorline " 突出显示当前行"set cursorcolumn " 突出显示当前列set cul nocuc " 突出显示当前行但不突出显示当前列"colorscheme molokai " 设置molokai高亮主题"colorscheme desert " 设置desert高亮主题"let g:solarized_termcolors=256"colorscheme solarized " 设置solarized高亮主题]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell实现netmask掩码和cidr掩码位转换]]></title>
    <url>%2F2017%2F12%2F26%2F2017-12-26-134510-shell%E5%AE%9E%E7%8E%B0netmask%E6%8E%A9%E7%A0%81%E5%92%8Ccidr%E6%8E%A9%E7%A0%81%E4%BD%8D%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[利用规律进行口算netmask转CIDR例如：255.255.192.0 255.0.0.0、255.255.0.0、255.255.255.0、255.255.255.255 以上四种一看便知分别是8、16、24、32 例子中去掉所有255.的字符和.及其后面的字符，得到了192 用256减去192，得到了64，也就是2的6次方 XXX.XXX.192.XXX 24-6=18 192在第一段，用8减 192在第二段，用16减 192在第三段，用24减 192在第四段，用32减 CIDR转netmask例如：20==&gt;255.255.240.0 根据上面的进行反推 8、16、24、32可直接转换 24-20=4 小于8则用8减 大于8小于16则用16减 大于16小于24则用24减 大于24小于32则用32减 求得2的N次幂，即：2的4次方得到16，256-16=240 255.255.XXX.0，这里的XXX是240 小于8则是XXX.0.0.0 大于8小于16则255.XXX.0.0 大于16小于24则255.255.XXX.0 大于24小于32则255.255.255.XXX 使用自带命令ipcalc 常用选项 12345-b, --broadcast Display calculated broadcast address-h, --hostname Show hostname determined via DNS-m, --netmask Display default netmask for IP (class A, B, or C)-n, --network Display network address-p, --prefix Display network prefix 使用示例 123456$ ipcalc -pmnb 222.58.15.18/29NETMASK=255.255.255.248PREFIX=29BROADCAST=222.58.15.23NETWORK=222.58.15.16 perl开发的ipcalc 官网：http://jodies.de/ipcalc 示例 1234567891011$ ipcalc 192.168.0.1/24 Address: 192.168.0.1 11000000.10101000.00000000. 00000001Netmask: 255.255.255.0 = 24 11111111.11111111.11111111. 00000000Wildcard: 0.0.0.255 00000000.00000000.00000000. 11111111=&gt;Network: 192.168.0.0/24 11000000.10101000.00000000. 00000000HostMin: 192.168.0.1 11000000.10101000.00000000. 00000001HostMax: 192.168.0.254 11000000.10101000.00000000. 11111110Broadcast: 192.168.0.255 11000000.10101000.00000000. 11111111Hosts/Net: 254 Class C, Private Internet 来自openwrt的shell脚本 内容来源于：openwrt 1234567891011121314151617181920#!/bin/bashmask2cdr ()&#123; # Assumes there's no "255." after a non-255 byte in the mask local x=$&#123;1##*255.&#125; set -- 0^^^128^192^224^240^248^252^254^ $(( ($&#123;#1&#125; - $&#123;#x&#125;)*2 )) $&#123;x%%.*&#125; x=$&#123;1%%$3*&#125; echo $(( $2 + ($&#123;#x&#125;/4) ))&#125;cdr2mask ()&#123; # Number of args to shift, 255..255, first non-255 byte, zeroes set -- $(( 5 - ($1 / 8) )) 255 255 255 255 $(( (255 &lt;&lt; (8 - ($1 % 8))) &amp; 255 )) 0 0 0 [ $1 -gt 1 ] &amp;&amp; shift $1 || shift echo $&#123;1-0&#125;.$&#123;2-0&#125;.$&#123;3-0&#125;.$&#123;4-0&#125;&#125;# examples:mask2cdr 255.255.255.0cdr2mask 24 思路说明mask2cdr() To get the CIDR prefix from a dot-decimal netmask like this one:要从像下面这样的点分十进制掩码获得CIDR子网掩码 1255.255.192.0 you first have to convert the four octets to binary and then count the most significant bits (i.e. the number of leading ones):首先你必须转换成四个八位二进制，而且算出占了1的位数 111111111.11111111.11000000.00000000 # 18 ones = /18 in CIDR This function does that rather creatively. First, we strip off all of the leading 255 octets (i.e. the octets that are all ones in binary) and store the results in variable x:这个函数确实极具创造性。首先，我们将传入函数的的第一个位置参数（即点分十进制子网掩码）去掉所有开头的255，然后复制给变量x 1local x=$&#123;1##*255.&#125; This step uses parameter expansion, which the entire script relies on pretty heavily. If we continue with our example netmask of 255.255.192.0, we now have the following values:这一步我们使用参数扩展，整个脚本对此有很强的依赖性。如果我们根据刚刚的例子继续看，会得到如下值 12$1: 255.255.192.0 $x: 192.0 Next we set three variables: $1, $2, and $3. These are called positional parameters; they are much like ordinary named variables but are typically set when you pass arguments to a script or function. We can set the values directly using set –, for example:接下来我们设置了三个变量：$1，$2和$3，他们都是位置参数，和普通变量大同小异，但是当你将参数传给一个脚本或者函数时他们是很典型的设置。我们可以直接使用set --来设定变量的值，列如： 1set -- foo bar # $1 = foo, $2 = bar I prefer using named variables over positional parameters since it makes scripts easier to read and debug, but the end result is the same. We set $1 to:相比较位置参数，我更喜欢使用定义好的变量，因为这样使得脚本更容易阅读和调试bug，但是最终的结果都是相同的，我们把位置参数$1设置为： 10^^^128^192^224^240^248^252^254^ This is really just a table to convert certain decimal values to binary and count the number of 1 bits. We’ll come back to this later.这其实只是一个用来转换十进制到二进制，统计1bits数量的一个表。我们稍后将会回顾这里 We set $2 to我们将位置参数$2设置为： 1$(( ($&#123;#1&#125; - $&#123;#x&#125;)*2 )) This looks complex, but it is really just counting the number of 1 bits we stripped off in the first command. It breaks down to this:这个看起来有些复杂，但是其实只是计算我们从第一个命令中去掉（二进制数中八个位都占了1的位）的数量。它划分成了这样： 12(number of chars in $1 - number of chars in $x) * 2# 如果传递给函数的子网掩码是255.255.255.192的话，那么其实就是（15-3）*2=24 which in our case works out to在我们的情况下，其实就是这样： 1(13 - 5) * 2 = 16 We stripped off two octets so we get 16. Makes sense.我们去除了两个（在二进制都占了1的位数=8）8位因此得到了16 We set $3 to:我们将位置参数$3设置为： 1$&#123;x%%.*&#125; which is the value of $x with everything after the first . stripped off. In our case, this is 192.从刚开始到现在$x的值，在我们的情况下已经赋值为192 We need to convert this number to binary and count the number of 1 bits in it, so let’s go back to our “conversion table.” We can divide the table into equal chunks of four characters each:我们需要将这个数字转换为二进制并计算占了1的位的数量，让我们回到我们的“转换表”。我们可以把表分成每个块的字符数等于四的块： 10^^^ 128^ 192^ 224^ 240^ 248^ 252^ 254^ In binary, the above numbers are:转换为二进制就是 1200000000 10000000 11000000 11100000 11110000 11111000 11111100 11111110# 0 ones 1 one 2 ones 3 ones ... If we count from the left, each four-character block in the table corresponds to an additional 1 bit in binary. We’re trying to convert 192, so let’s first lop off the rightmost part of the table, from 192 on, and store it in x:如果我们从左边数，表中的每个四字符的块对应一个额外 占了1的位 的二进制数。我们正试图转换 192 ，所以让我们先剔除掉从192开头的了最右边的表，并赋值给x ： 1x=$&#123;1%%$3*&#125; The value of $x is now$x的值现在就是 10^^^128^ which contains two four-character blocks, or two 1 bits in binary.包含了两个4字符的块或者说是两个占了1位的二进制 Now we just need to add up the 1 bits from our leading 255 octets (16 total, stored in variable $2) and the 1 bits from the previous step (2 total):现在我们只需要把之前算的两个（二进制下都为1的）八位组，（16个，赋值给位变量 $ 2 ），加上从第二步的表中算出$x在二进制中占了1的位的数2 1echo $(( $2 + ($&#123;#x&#125;/4) )) where其中 1$&#123;#x&#125;/4 is the number of characters in $x divided by four, i.e. the number of four-character blocks in $x.是$x的字符数除以四（每四个字符是一个块） Output:输出结果 18 cdr2mask()Let’s keep running with our previous example, which had a CIDR prefix of 18. We use set – to set positional parameters $1 through $9: 123456789$1: $(( 5 - ($1 / 8) )) # 5 - (18 / 8) = 3 [integer math]$2: 255$3: 255$4: 255$5: 255$6: $(( (255 &lt;&lt; (8 - ($1 % 8))) &amp; 255 )) # (255 &lt;&lt; (8 - (18 % 8))) &amp; 255 = 192$7: 0$8: 0$9: 0 Let’s examine the formulas used to set $1 and $6 a little closer. $1 is set to: 1$(( 5 - ($1 / 8) )) The maximum and minimum possible values for a CIDR prefix are 32 for netmask 111111111.11111111.11111111.11111111 and 0 for netmask 100000000.00000000.00000000.00000000 The above formula uses integer division, so the possible results range from 1 to 5: 125 - (32 / 8) = 15 - ( 0 / 8) = 5 $6 is set to: 1$(( (255 &lt;&lt; (8 - ($1 % 8))) &amp; 255 )) Let’s break this down for our example CIDR prefix of 18. First we take the modulus and do some subtraction: 18 - (18 % 8) = 6 Next we bitwise shift 255 by this value: 1255 &lt;&lt; 6 This is the same as pushing six 0 bits onto the end of 255 in binary: 111111111000000 Finally, we bitwise AND this value with 255: 1211111111000000 &amp;00000011111111 # 255 which gives 100000011000000 or simply 111000000 Look familiar? This is the third octet in our netmask in binary: 1211111111.11111111.11000000.00000000 ^------^ In decimal, the value is 192. Next we shift the positional parameters based on the value of $1: 1[ $1 -gt 1 ] &amp;&amp; shift $1 || shift In our case, the value of $1 is 3, so we shift the positional parameters 3 to the left. The previous value of $4 becomes the new value of $1, the previous value of $5 becomes the value of $2, and so on: 123456$1: 255$2: 255$3: 192$4: 0$5: 0$6: 0 These values should look familiar: they are the decimal octets from our netmask (with a couple of extra zeros tacked on at the end). To get the netmask, we simply print out the first four with dots in between them: 1echo $&#123;1-0&#125;.$&#123;2-0&#125;.$&#123;3-0&#125;.$&#123;4-0&#125; The -0 after each parameter says to use 0 as the default value if the parameter is not set. Output: 255.255.192.0]]></content>
      <categories>
        <category>shell拓展</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>子网掩码</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用dig命令写一个定时解析脚本]]></title>
    <url>%2F2017%2F12%2F25%2F2017-12-25-121210-%E4%BD%BF%E7%94%A8dig%E5%91%BD%E4%BB%A4%E5%86%99%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E8%A7%A3%E6%9E%90%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[写在前面： 写这个脚本是因为工作中需要收集一些域名的IP地址 解析和收集的过程中发现有些域名解析的IP地址不固定，从而造成地址收集比较棘手 环境依赖 需要保证所需包是安装的 12rpm -q bind-utilsyum -y install bind-utils 脚本内容1234567891011121314151617181920212223242526272829303132333435363738#!/bin/bashDNS_IP="10.99.31.71"# 要请求哪个DNS服务器进行域名解析serverListfile=$1# 将要解析的域名放到一个文件，answerFile=""# Answer_file="/tmp/google.res"# 域名解析的结果存放的文件路径# 如果不指定，默认会输出到/tmp/下的一个和脚本名一样，且后缀为.res的文件IP_filter()&#123; /bin/egrep '^(\b([1-9][0-9]?|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5]))(\.([0-9]|[1-9][0-9]|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5])\b)&#123;3&#125;'&#125;# 定义一个过滤IP的函数#------------------------------------------------scriptName=`/bin/basename $0`if /usr/bin/expr "$&#123;scriptName&#125;" : ".*\.sh$" &gt;/dev/null ;then if [[ ! -f $1 ]]; then echo -e "\n\tUsage : $(basename $0) filename\n" echo -e "\n\t必须指定一个域名列表文件\n" exit 3 fi outFilename=$(basename $&#123;serverListfile&#125;) answerFile="/tmp/$(echo $&#123;outFilename&#125; | cut -d "." -f 1).res"else echo -e "\n\t脚本必须以 '.sh' 结尾 \n" exit 3fi/bin/gawk '!a[$0]++' &lt; &lt;(IP_filter &lt; &lt;(/usr/bin/dig @$&#123;DNS_IP&#125; -f $&#123;serverListfile&#125; +short) ) | \/bin/sort -t "." -k 1.1,1n -k 2,2.0n -k 3.1,3.0n -k 4,4n &gt;&gt; $&#123;answerFile&#125;/bin/gawk '!a[$0]++' $&#123;answerFile&#125; | /bin/sort -t "." -k 1.1,1n -k 2,2.0n -k 3.1,3.0n -k 4,4n -o $&#123;answerFile&#125; 计划任务配置 确保手动执行无误 加入计划任务，每隔5分钟解析一次即可 1*/5 * * * * root /root/dig_cron.sh /root/namelist &amp;&gt;/dev/null]]></content>
      <categories>
        <category>shell脚本</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让谷歌TCP-BBR拥塞算法为TCP加速]]></title>
    <url>%2F2017%2F12%2F24%2F2017-12-24-110110-%E8%AE%A9%E8%B0%B7%E6%AD%8CTCP-BBR%E6%8B%A5%E5%A1%9E%E7%AE%97%E6%B3%95%E4%B8%BATCP%E5%8A%A0%E9%80%9F%2F</url>
    <content type="text"><![CDATA[BBR简述 Google 开源了其 TCP BBR 拥塞控制算法，并提交到了 Linux 内核，从 4.9 开始，Linux 内核已经用上了该算法。 目的是要尽量跑满带宽，并且尽量不要有排队的情况。 可以起到单边加速TCP连接的效果。 TCP BBR致力于解决两个问题 在有一定丢包率的网络链路上充分利用带宽 降低网络链路上的 buffer 占用率，从而降低延迟 BBR算法的优势 https://www.zhihu.com/question/53559433 一键配置脚本 用于CentOS系列6、7版本的系统 脚本自动升级内核使用yum安装，可能下载较慢，可手动下载rpm包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281#!/usr/bin/env bash:&lt;&lt;:------------------------------------------------ FileName : google_bbr_centos.sh Author : Li Tingjie Create Time : 2017-05-09 15:09:16 Last modified : 2017-11-26 17:56:25 Mail : 2234351300@qq.com Version : 0.0.1 Description : CopyRight :------------------------------------------------:# Set up a default search path.PATH="/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/sbin:/usr/local/bin:/root/bin"export PATH# Make sure umask is saneumask 022# terminal sequence to set color to a 'success' color (currently: green)SETCOLOR_SUCCESS="echo -en \\033[0;32m"# terminal sequence to set color to a 'failure' color (currently: red)SETCOLOR_FAILURE="echo -en \\033[0;31m"# terminal sequence to set color to a 'warning' color (currently: yellow)SETCOLOR_WARNING="echo -en \\033[0;33m"# terminal sequence to reset to the default color.SETCOLOR_NORMAL="echo -en \\033[0;39m"# Log that something succeededecho_info()&#123; echo -en "[ "; $&#123;SETCOLOR_SUCCESS&#125;; echo -en " Info "; $&#123;SETCOLOR_NORMAL&#125;; echo -en " ] "; echo "$@"&#125;# Log that something Errorecho_error()&#123; echo -en "[ "; $&#123;SETCOLOR_FAILURE&#125;; echo -en " Error "; $&#123;SETCOLOR_NORMAL&#125;; echo -en " ] "; echo "$@"&#125;# Log a warningecho_warning()&#123; echo -en "[ "; $&#123;SETCOLOR_WARNING&#125;; echo -en " Warning "; $&#123;SETCOLOR_NORMAL&#125;; echo -en " ] "; echo "$@"&#125;bbr_sysctl_config()&#123; sed -i '/net.core.default_qdisc/d' /etc/sysctl.conf sed -i '/net.ipv4.tcp_congestion_control/d' /etc/sysctl.conf echo "net.core.default_qdisc = fq" &gt;&gt; /etc/sysctl.conf echo "net.ipv4.tcp_congestion_control = bbr" &gt;&gt; /etc/sysctl.conf sysctl -p &gt;/dev/null 2&gt;&amp;1&#125;get_os() &#123; [ -f /etc/redhat-release ] &amp;&amp; awk '&#123;print ($1,$3~/^[0-9]/?$3:$4)&#125;' /etc/redhat-release &amp;&amp; return [ -f /etc/os-release ] &amp;&amp; awk -F'[= "]' '/PRETTY_NAME/&#123;print $3,$4,$5&#125;' /etc/os-release &amp;&amp; return [ -f /etc/lsb-release ] &amp;&amp; awk -F'[="]+' '/DESCRIPTION/&#123;print $2&#125;' /etc/lsb-release &amp;&amp; return&#125;get_char() &#123; SAVEDSTTY=`stty -g` stty -echo stty cbreak dd if=/dev/tty bs=1 count=1 2&gt; /dev/null stty -raw stty echo stty $SAVEDSTTY&#125;clearecho "------------- System Information --------------"echoecho " OS : $(get_os)"echo " Arch : $(uname -m) $(getconf LONG_BIT) Bit"echo " Kernel : $(uname -r)"echoecho "-----------------------------------------------"echo " Auto upgrade latest kernel and turn on TCP BBR"echo "-----------------------------------------------"echoecho "Press any key to start...or Press Ctrl+C to cancel"char=$(get_char)echo#------------------------------------------------# Test the operator is root or not#------------------------------------------------if test "$&#123;EUID&#125;" -ne 0 -o "$&#123;USER&#125;" != "root";then echo_error "Only root can run this script ... " exit 5else echo_info "Operator is root "fi#************************************************#------------------------------------------------ # Check network is rechable or not#------------------------------------------------dstname="www.baidu.com"if (ping $&#123;dstname&#125; -c 3 -i 0.01 -w 2 -q 1&gt;/dev/null 2&gt;&amp;1)then echo_info "Network is rechable "else RETVAL=$? echo_error "Network is unreachable , please check " exit 5fi#************************************************#------------------------------------------------# Check your OS is Redhat release or not #------------------------------------------------rla="$(egrep -i "centos|red hat|redhat" /etc/issue)"rlb="$(egrep -i "centos|red hat|redhat" /proc/version)"if [ -f /etc/centos-release -o -n "$&#123;rla&#125;" -o -n "$&#123;rlb&#125;" ]; then echo_info "OS is Redhat release" else echo_error "Only support for CentOS" exit 5fi#************************************************#------------------------------------------------# Check bbr status#------------------------------------------------conGestion="$(set -- $(sysctl -n net.ipv4.tcp_available_congestion_control);echo $1)"# Get the congestion_control from Kernel parameterbbrmodules="$(lsmod | fgrep tcp_bbr)"# Show the status of tcp_bbr module in the Linux Kernelif [ "$&#123;conGestion&#125;" = "bbr" -a -n "$&#123;bbrmodules&#125;" ];then echo_info "TCP BBR has been installed. Nothing to do..." exit 5fi#************************************************#------------------------------------------------# Check version of kernel is newer or not#------------------------------------------------kernelRelease="$(uname -r)"newORold=$(set -- $&#123;kernelRelease%%-*&#125; 4.9;test "$(echo -e "$1\n$2" | sort -rV | head -1)" == "$1" &amp;&amp; echo newer || echo older )if test "$&#123;newORold&#125;" == 'newer';then echo_info "Version of your kernel is greater than 4.9 , directly setting TCP BBR..." bbr_sysctl_config echo_info "Setting TCP BBR ..." echo_info 'Complete ! ' exit 5fi#************************************************#------------------------------------------------# Install elrepo#------------------------------------------------OS_X="`grep -Po '(?&lt;=\brelease )[\d]' /etc/redhat-release`"if test ! -z "$&#123;OS_X//[0-9]/&#125;";then echo_error "Not available for your system :("else echo_info "Installing elrepo"firpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.orgcase $OS_X in 6) rpm -Uvh http://www.elrepo.org/elrepo-release-6-8.el6.elrepo.noarch.rpm ;; 7) rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm ;; *) echo_error "Not support for CentOS$&#123;OS_X&#125;" exit 5 ;;esacif [ ! -s /etc/yum.repos.d/elrepo.repo ]; then echo_error "Install elrepo failed , please check " exit 5fi#************************************************#------------------------------------------------# Upgrade kernel#------------------------------------------------yum --enablerepo=elrepo-kernel -y install kernel-ml kernel-ml-develecho_info "Query package :"echo '------------------------------------------------'rpm -qa kernel-mlecho '------------------------------------------------'echoif [ $? -ne 0 ]; then echo_error "Install latest kernel failed, please check it." exit 5fi#************************************************#------------------------------------------------# config for grub#------------------------------------------------case $OS_X in 6) if [ ! -s "/boot/grub/grub.conf" ]; then echo_error "/boot/grub/grub.conf wrong, please check it." exit 5 fi echo_info "List of kernel that is available" echo '------------------------------------------------' awk '/title/&#123;$1="";print&#125;' /etc/grub.conf echo '------------------------------------------------' echo sed -ri 's/^default=.*/default=0/g' /boot/grub/grub.conf ;; 7) if [ ! -s "/boot/grub2/grub.cfg" ]; then echo_error "/boot/grub2/grub.cfg wrong, please check it." exit 5 fi echo_info "List of kernel that is available" echo '------------------------------------------------' awk -F'[\047]+' '/^menuentry/&#123;print $2&#125;' /boot/grub2/grub.cfg echo '------------------------------------------------' echo grub_default_kernel=$(awk -F'[\047]+' '/^menuentry/&#123;print "\047"$2"\047";exit&#125;' /boot/grub2/grub.cfg) echo "grub2-set-default 0" echo grub2-set-default 0 echo "grub2-mkconfig -o /boot/grub2/grub.cfg" echo grub2-mkconfig -o /boot/grub2/grub.cfg ;; *) echo_error "Not support for CentOS$&#123;OS_X&#125;" exit 5 ;;esac#************************************************bbr_sysctl_config#------------------------------------------------# Waitting for reboot#------------------------------------------------echoecho_warning "The system needs to reboot."echo read -p 'Do you want to restart system ? [yes/no] ' yesOrnocase "$&#123;yesOrno&#125;" in y|Y|[yY][eE]|[yY][eE][sS]) reboot ;; n|N|[nN][oO]) echo_info "Reboot has been canceled..." exit 5 ;;esac#************************************************ 7系统内核查看 查看可用内核 1awk -F'[\047]+' '/^menuentry/&#123;print $2&#125;' /boot/grub2/grub.cfg 查看当前内核 1uname -r 修改开机时默认使用的内核 123grub2-set-default 'CentOS Linux (4.14.2-1.el7.elrepo.x86_64) 7 (Core)'# 或使用索引号0、1、2.....grub2-set-default 0 查看内核修改结果 1grub2-editenv list 重新生成 grub2 的配置文件 1grub2-mkconfig -o /boot/grub2/grub.cfg grub操作帮助 http://fedoraproject.org/wiki/GRUB_2/zh-cn]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>bbr</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用safe-rm避免rm命令误删文件]]></title>
    <url>%2F2017%2F12%2F23%2F2017-12-23-121010-%E4%BD%BF%E7%94%A8safe-rm%E9%81%BF%E5%85%8Drm%E5%91%BD%E4%BB%A4%E8%AF%AF%E5%88%A0%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言 在Linux系统下，超级用户如果使用rm -rf / ，那就相当于系统自杀，会造成业务灾难。 根据最新的POSIX.1-2008标准，rm -fr /命令是不会被执行的，而是应该打印错误信息。但是老的POSIX.1-2004标准则无此定义，那么这个有什么意义呢？在Linux中，我们所使用的rm、touch、mkdir、cp、mv等命令都是由coreutils这个核心工具提供的，coreutils 5.2稳定版于2004年2月19日发布，而现在coreutils工具在CentOS6上都已经是8.22版本了（CentOS7是8.4版本，Debian8是8.23版本）。只有你的coreutils的版本足够高（5.2版本以上），才可以”安全地”使用rm -fr /这个指令，老版本的rm还是存在此问题的。 以下是针对CentOS6和CentOS7的验证 123456789[root@CentOS-6.8 ~]# uname -r2.6.32-642.el6.x86_64[root@CentOS-6.8 ~]# rpm -qi coreutils | grep -i versionVersion : 8.4 Vendor: CentOS[root@CentOS-6.8 ~]# [root@CentOS-6.8 ~]# rm -fr /rm: it is dangerous to operate recursively on `/'rm: use --no-preserve-root to override this failsafe 1234567[root@CentOS7 ~]# uname -r4.14.14-1.el7.elrepo.x86_64[root@CentOS7 ~]# rpm -qi coreutils | grep -i versionVersion : 8.22[root@CentOS7 ~]# rm -fr /rm: it is dangerous to operate recursively on ‘/’rm: use --no-preserve-root to override this failsafe 提示的意思是 12rm: 在"/" 进行递归操作十分危险rm: 使用 --no-preserve-root 选项跳过安全模式 即便是这样，也无法避免重要文件被误删的情况，因为root用户是有绝对权限的。很多系统正常运行要依赖各种各样的文件，一旦其中任意一个文件被误删将会造成严重的影响，最明显的表现是各种命令无法正常使用，系统服务无法正常运行… 为了避免种误删除操作，我们可以尝试很多办法，回收站机制、给重要目录设置权限、替换rm命令等；再做过这些尝试后，个人认为替换rm命令比较简单直接，用safe-rm来替换rm便可以满足大部分需求 safe-rm及安装safe-rm的主页：https://launchpad.net/safe-rm safe-rm 是一个开源软件用来替代不太安全的rm，可以在/etc/safe-rm.conf中配置路径黑名单，定义哪些不能被safe-rm删除。将safe-rm 更名为 rm 并放在 $PATH 中比 原rm 程序靠前的位置。一些脚本中使用完全路径/bin/rm则不会受此影响。 下载Safe-rm 软件包，解压后会得到一个 safe-rm 可执行文件，将这个文件拷贝到系统的二进制可执行程序目录下，但是要保证这个路径在rm命令路径前面 1234567891011121314[root@CentOS7 ~] '#' wget https://launchpad.net/safe-rm/trunk/0.12/+download/safe-rm-0.12.tar.gz[root@CentOS7 ~] '#' tar xf safe-rm-0.12.tar.gz cd safe-rm-0.12[root@CentOS7 safe-rm-0.12] '#' echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/netpas/bin[root@CentOS7 safe-rm-0.12] '#' [root@CentOS7 safe-rm-0.12] '#' which rmalias rm='rm -i' /usr/bin/rm[root@CentOS7 safe-rm-0.12] '#' cp -a safe-rm /usr/local/sbin/ [root@CentOS7 safe-rm-0.12] '#' ln -sv /usr/local/sbin/safe-rm /usr/local/sbin/rm‘/usr/local/sbin/rm’ -&gt; ‘/usr/local/sbin/safe-rm’[root@CentOS7 safe-rm-0.12] '#' safe-rm的配置safe-rm 命令使用两个配置文件： 全局配置/etc/safe-rm.conf 用户配置~/.safe-rm 配置的时候只需要将重要文件或者目录的完整路径输入进去就可以了，每条以回车分隔。例如： 1/test 注意： 这样写可以避免test目录被删除，但无法避免test目录下的文件被删除 12/test/test/* 注意： 这样写可以避免test目录和test目录下的普通文件被删除，但无法避免test目录下链接文件被删除。所以像/lib或/lib64这种目录，下面会有很多对库文件的链接文件，使用safe-rm并不能保护文件。 建议： 作为运维人员，应当严格要求自己，养成良好的维护、操作、及时备份的习惯]]></content>
      <categories>
        <category>杂货铺</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iptables实现不连续地址的SNAT(源地址转换)]]></title>
    <url>%2F2017%2F12%2F22%2F2017-12-22-080610-iptables%E5%AE%9E%E7%8E%B0%E4%B8%8D%E8%BF%9E%E7%BB%AD%E5%9C%B0%E5%9D%80%E7%9A%84SNAT-%E6%BA%90%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[摘要 一台配置了私网地址的服务器在互联网中要想直接私网访问公网肯定是不可能的，因此需要做源地址转换配置。 源地址转换实质上就是将来源是私网的地址段，在去访问目标服务器时转换成对应的物理网卡上的公网地址 基于iptables可实现SNAT，在配置的过程中可能有的地址是连续的，有的地址不是连续的，因此需要针对不同情况做不同的配置 什么是连续，什么是不连续 连续指的是从头到尾都连续，而不连续指的是只要出现任意两个地址间互相不连续就视为不连续地址。下面是生产环境中经常遇到的几个例子 连续 204.110.13.77 204.110.13.78 204.110.13.79 204.110.13.80 204.110.13.81 204.110.13.82 204.110.13.77 如果某块网卡上只配置了一个IP地址视为连续地址 不连续 第一种：208.90.123.205 208.90.123.209 208.90.123.213 第二种：208.90.123.212 208.90.123.213 208.90.123.217 第三种：204.110.13.88 204.110.13.89 204.110.13.90 204.110.13.91 208.90.123.205 208.90.123.206 208.90.123.209 对连续的地址做SNAT配置12iptables -t nat -I POSTROUTING -o eth0 -s 10.0.0/8 -j SNAT --to 204.110.13.77-204.110.13.82iptables -t nat -I POSTROUTING -o eth0 -s 192.168.0.0/16 -j SNAT --to 204.110.13.77-204.110.13.82 对不连续的地址做SNAT配置CentOS5系统的配置 示例1 12iptables -t nat -I POSTROUTING -o eth0 -s 10.0.0.0.8 -j SAME --to 208.90.123.205 --to 208.90.123.209 --to 208.90.123.213 --nodstiptables -t nat -I POSTROUTING -o eth0 -s 192.168.0.0/16 -j SAME --to 208.90.123.205 --to 208.90.123.209 --to 208.90.123.213 --nodst 示例2 12iptables -t nat -I POSTROUTING -o eth0 -s 10.0.0.0.8 -j SAME --to 204.110.13.88-204.110.13.89 --to 204.110.13.90-204.110.13.91 --to 208.90.123.205-208.90.123.206 --to 208.90.123.209 --nodstiptables -t nat -I POSTROUTING -o eth0 -s 192.168.0.0/16 -j SAME --to 204.110.13.88-204.110.13.89 --to 204.110.13.90-204.110.13.91 --to 208.90.123.205-208.90.123.206 --to 208.90.123.209 --nodst CentOS6及以上系统的配置 6以及6以上系列的系统不再支持’–to –to’这种方式，因此我们使用了针对数据包做负载均衡的方式 针对不连续的两个地址进行SNAT（源地址转换），需要修改的是“–every ”后面的数值n，不连续的地址为5则n为5，”–to“后的IP则依次修改 示例1 12345678910111213141516# SNAT#-----------------------------------------------------------------iptables -t nat -A POSTROUTING -o eth0 -s 10.0.0.0/8 -m state --state NEW -m statistic --mode nth --every 2 --packet 0 -j SNAT --to 115.231.107.117iptables -t nat -A POSTROUTING -o eth0 -s 10.0.0.0/8 -m state --state NEW -m statistic --mode nth --every 2 --packet 1 -j SNAT --to 122.224.152.132# 以上命令的作用是：新建立的会话中每两个中的第一个包转换成115.231.107.117，第二个包转换成122.224.152.132 iptables -t nat -A POSTROUTING -o eth1 -s 10.0.0.0/8 -m state --state NEW -m statistic --mode nth --every 2 --packet 0 -j SNAT --to 124.160.121.78iptables -t nat -A POSTROUTING -o eth1 -s 10.0.0.0/8 -m state --state NEW -m statistic --mode nth --every 2 --packet 1 -j SNAT --to 124.160.121.81iptables -t nat -A POSTROUTING -o eth2 -s 10.0.0.0/8 -m state --state NEW -m statistic --mode nth --every 2 --packet 0 -j SNAT --to 112.17.39.157iptables -t nat -A POSTROUTING -o eth2 -s 10.0.0.0/8 -m state --state NEW -m statistic --mode nth --every 2 --packet 1 -j SNAT --to 112.17.39.155 iptables -t nat -A POSTROUTING -o eth0 -s 10.0.0.0/8 -j SNAT --to 122.224.152.132# 这一条可以看作是一个default，选择其中一个地址即可 iptables -t nat -A POSTROUTING -o eth1 -s 10.0.0.0/8 -j SNAT --to 124.160.121.78iptables -t nat -A POSTROUTING -o eth2 -s 10.0.0.0/8 -j SNAT --to 112.17.39.155 示例2 12345678910# SNAT#-----------------------------------------------------------------iptables -t nat -A POSTROUTING -o eth0 -s 10.0.0.0/8 -m state --state NEW -m statistic --mode nth --every 3 --packet 0 -j SNAT --to 222.186.39.35iptables -t nat -A POSTROUTING -o eth0 -s 10.0.0.0/8 -m state --state NEW -m statistic --mode nth --every 3 --packet 1 -j SNAT --to 222.186.39.40-222.186.39.41iptables -t nat -A POSTROUTING -o eth0 -s 10.0.0.0/8 -m state --state NEW -m statistic --mode nth --every 3 --packet 2 -j SNAT --to 222.186.39.44# 其中40-41是连续的，我们就可以把这个用横线连接起来，放到其中的一个--to后面 iptables -t nat -A POSTROUTING -o eth0 -s 10.0.0.0/8 -j SNAT --to 222.186.39.40-222.186.39.41iptables -t nat -A POSTROUTING -o eth0 -s 192.168.0.0/16 -j SNAT --to 222.186.39.40-222.186.39.41#-----------------------------------------------------------------]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7网卡名称的修改]]></title>
    <url>%2F2017%2F12%2F18%2F2017-12-18-084910-CentOS7%E7%BD%91%E5%8D%A1%E5%90%8D%E7%A7%B0%E7%9A%84%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[说明 生产环境中，可能由于某些需要将要对托管于机房的服务器进行割接、带宽扩容等操作，为了能让网卡更容易让运维人员和机房识别，避免拔错网线等操作导致业务中断，在服务器上架前就应该对所有网卡按照eth0、eth1…等依次编号，并贴上网卡标签。 一般情况下，板载网卡(目前多数服务器为板载双网卡)的MAC地址相差1，其余外接网卡则是在使用ip addr show 或ifconfig -a命令查看时，靠近板载网卡的外接网卡显示在另一块外接网卡的上面。 在CentOS7系列系统中，网卡命名方式有所不同 使用ip命令查看目前网卡信息 123456789101112131415161718[root@Test ~]$ ip a 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo inet6 ::1/128 scope host 2: ens32: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 00:50:56:39:b5:c6 brd ff:ff:ff:ff:ff:ff inet6 fe80::e349:3059:2d58:c589/64 scope link 3: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 00:50:56:39:b5:c7 brd ff:ff:ff:ff:ff:ff inet 172.20.35.2/22 brd 172.20.35.255 scope global dynamic ens33 inet6 fe80::d9b6:fc5b:da94:a526/64 scope link 4: ens34: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 00:50:56:3f:ef:47 brd ff:ff:ff:ff:ff:ff inet6 fe80::5043:4dc:eec2:582d/64 scope link 5: ens35: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 00:0c:29:87:80:67 brd ff:ff:ff:ff:ff:ff inet6 fe80::c308:1eca:83e4:11c/64 scope link 00:50:56:39:b5:c6 和 00:50:56:39:b5:c7 MAC地址相差为1，因此可以大致断定网卡ens33和ens34为板载网卡，网卡名顺序应该改为 eth0 和 eth1，剩下两块网卡为外接网卡，命名为 eth2 和 eth3 配置创建一个自定义rules文件：/etc/udev/rules.d/70-mynet.rules，按照顺序将MAC地址与网卡名称绑定 1234SUBSYSTEM=="net", ACTION="add", DRIVERS=="?*", ATTR&#123;address&#125;=="00:50:56:39:b5:c6", ATTR&#123;dev_id&#125;=="0x0", ATTR&#123;type&#125;=="1", KERNEL=="eth*", NAME="eth0"SUBSYSTEM=="net", ACTION="add", DRIVERS=="?*", ATTR&#123;address&#125;=="00:50:56:39:b5:c7", ATTR&#123;dev_id&#125;=="0x0", ATTR&#123;type&#125;=="1", KERNEL=="eth*", NAME="eth1"SUBSYSTEM=="net", ACTION="add", DRIVERS=="?*", ATTR&#123;address&#125;=="00:50:56:3f:ef:47", ATTR&#123;dev_id&#125;=="0x0", ATTR&#123;type&#125;=="1", KERNEL=="eth*", NAME="eth2"SUBSYSTEM=="net", ACTION="add", DRIVERS=="?*", ATTR&#123;address&#125;=="00:0c:29:87:80:67", ATTR&#123;dev_id&#125;=="0x0", ATTR&#123;type&#125;=="1", KERNEL=="eth*", NAME="eth3" 更改网卡配置文件，配置DEVICE和NAME，并加入HWADDR(必配选项) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384==&gt; ifcfg-eth0 &lt;==TYPE=EthernetBOOTPROTO=noneDEFROUTE=yesPEERDNS=yesPEERROUTES=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_PEERDNS=yesIPV6_PEERROUTES=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=eth0UUID=a805585c-c69a-4885-8f83-16d67754dccbDEVICE=eth0ONBOOT=yesHWADDR=00:50:56:39:b5:c6==&gt; ifcfg-eth1 &lt;==TYPE=EthernetBOOTPROTO=noneDEFROUTE=yesPEERDNS=yesPEERROUTES=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_PEERDNS=yesIPV6_PEERROUTES=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=eth1UUID=6d524d10-ee00-460e-af9c-61e57c833e75DEVICE=eth1ONBOOT=yesHWADDR=00:50:56:39:b5:c7IPADDR=172.20.35.2NETMASK=255.255.252.0BROADCAST=172.20.35.255NETWORK=172.20.32.0GATEWAY=172.20.32.7==&gt; ifcfg-eth2 &lt;==TYPE=EthernetBOOTPROTO=noneDEFROUTE=yesPEERDNS=yesPEERROUTES=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_PEERDNS=yesIPV6_PEERROUTES=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=eth2UUID=cfefc668-986c-4c4f-b673-66d4463a56e5DEVICE=eth2ONBOOT=yesHWADDR=00:50:56:3f:ef:47==&gt; ifcfg-eth3 &lt;==TYPE=EthernetBOOTPROTO=noneDEFROUTE=yesPEERDNS=yesPEERROUTES=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_PEERDNS=yesIPV6_PEERROUTES=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=eth3UUID=1aa05d79-80f3-4550-bc57-9dc64a4c8ebfDEVICE=eth3ONBOOT=yesHWADDR=00:0c:29:87:80:67 重启完成后验证]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>网卡配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7网卡一致性命名规则]]></title>
    <url>%2F2017%2F12%2F17%2F2017-12-17-165610-CentOS7%E7%BD%91%E5%8D%A1%E4%B8%80%E8%87%B4%E6%80%A7%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[说明参考：https://access.redhat.com/documentation/zh-CN/Red_Hat_Enterprise_Linux/7/html/Networking_Guide/ch-Consistent_Network_Device_Naming.html 一致性网络设备命名，即Consistent Network Device Naming 服务器通常有多块网卡，有板载集成的，同时也有插在PCIe插槽的。Linux系统的命名原来是eth0,eth1这样的形式，但是这个编号往往不一定准确对应网卡接口的物理顺序。为解决这类问题，dell开发了biosdevname方案。systemd v197版本中将dell的方案作了进一步的一般化拓展。目前的Centos既支持dell的biosdevname，也支持systemd的方案。 在CentOS 7 中，udev 支持大量不同的命名方案。默认是根据固件、拓扑及位置信息分配固定名称。这样做的优点是命名可完全自动进行，并可预期，即使添加或删除硬件后也会保留其名称（不会出现重复枚举的情况），同时可顺利更换损坏的硬件。不足之处是，相比传统的名称，比如 eth0 或 wlan0，这些名称有时会比较难理解。例如：enp5s0。 命名方案层级结构默认情况下，systemd 会使用以下策略，采用支持的命名方案为接口命名： 方案 1：如果固件或 BIOS 信息适用且可用，则使用整合了为板载设备提供索引号的固件或 BIOS 的名称（例如：eno1），否则请使用方案 2。 方案 2：如果固件或 BIOS 信息适用且可用，则使用整合了为 PCI 快速热插拔插槽提供索引号的固件或 BIOS 名称（例如 ens1），否则请使用方案 3。 方案 3：如果硬件连接器物理位置信息可用，则使用整合了该信息的名称（例如：enp2s0），否则请使用方案 5。 方案 4： 默认不使用整合接口 MAC 地址的名称（例如：enx78e7d1ea46da），但用户可选择使用此方案。 方案 5：传统的不可预测的内核命名方案，在其他方法均失败后使用（例如： eth0）。这个策略（如上所述）是默认策略。如果该系统已启用 biosdevname，则会使用该方案。注：启用 biosdevname 需要添加 biosdevname=1 作为内核命令行参数（Dell 系统除外），此时只要安装 biosdevname，就会默认使用该方案。如果用户已添加 udev 规则，该规则会更改内核设备名称，则会优先使用这些规则。 了解设备重命名过程设备命名过程如下： /usr/lib/udev/rules.d/60-net.rules 文件中的规则会让 udev 帮助工具 /lib/udev/rename_device 查看所有 /etc/sysconfig/network-scripts/ifcfg-suffix 文件。如果发现包含 HWADDR 条目的 ifcfg 文件与某个接口的 MAC 地址匹配，它会将该接口重命名为 ifcfg 文件中由 DEVICE 指令给出的名称。 /usr/lib/udev/rules.d/71-biosdevname.rules 中的规则让 biosdevname 根据其命名策略重命名该接口，即在上一步中没有重命名该接口、已安装 biosdevname、且在 boot 命令行中将 biosdevname=0 作为内核命令给出。 /lib/udev/rules.d/75-net-description.rules 中的规则让 udev 通过检查网络接口设备，填写内部 udev 设备属性值 ID_NET_NAME_ONBOARD、ID_NET_NAME_SLOT、ID_NET_NAME_PATH。注：有些设备属性可能处于未定义状态。 /usr/lib/udev/rules.d/80-net-name-slot.rules 中的规则让 udev 重命名该接口，优先顺序如下：ID_NET_NAME_ONBOARD、ID_NET_NAME_SLOT、ID_NET_NAME_PATH。并提供如下信息：没有在步骤 1 或 2 中重命名该接口，同时未给出内核参数 net.ifnames=0。如果一个参数未设定，则会按列表的顺序设定下一个。如果没有设定任何参数，则不会重命名该接口。 第 3 步和第4 步采用命名规则 1、2、3，可自选方案 4 。 步在 第 8.6 节 “使用 biosdvname 保持网络设备命名一致” 中有详细论述。 了解可预期网络接口设备名称根据接口类型以两个字母开头： en 代表以太网， wl 代表无线局域网（WLAN）， ww 代表无线广域网（WWAN）。 名称有以下类型：表 设备名称类型 所有多功能 PCI 设备都在其设备名称中包含 [f] 号，其中包括 function 0 设备。 在 USB 设备中会组成集线器端口号完整链。如果该名称超过 15 个字符上限，则无法导出该名称。 已取消 USB configuration descriptors == 1 和 USB interface descriptors == 0（如果只有一个 USB 配置或接口存在，则默认值为 configuration == 1 及 interface == 0）。 使用 BIOSDVNAME 保持网络设备命名一致通过 biosdevname udev 帮助程序实施此功能，可将所有内嵌网络接口名称、PCI 卡网络接口名称、以及现有 eth[0123…] 的虚拟功能网络接口名称改为新的命名规范，如 表 8.3 “biosdevname 命名惯例” 所示。注：除非使用 Dell 系统，或特别明确说明启用 biosdevname，否则会优先使用 systemd 命名惯例。 系统要求biosdevname 程序使用来自系统BIOS 的信息，特别是 SMBIOS 中包含。type 9（系统插槽）和 type 41（板载设备扩展信息）字段。如果系统的 BIOS 没有 SMBIOS 版本 2.6 或更高版本和这个数据，则不会使用新的命名规则。大多数老硬件不支持这个功能，因为缺少有正确 SMBIOS 版本的 BIOS 和字段信息。有关 BIOS 和 MSBIOS 版本信息，请联络您的硬件销售商。 必须安装 biosdevname 软件包方可或使用这个功能。要安装这个软件包，请作为 root 用户运行以下命令： 1yum install biosdevname 启用和禁用该功能要禁用这个功能，请在安装过程中及安装后，在 boot 命令行中使用以下选项： 1biosdevname=0 要启用这个功能，请在安装过程中及安装后，在 boot 命令行中使用以下选项： 1biosdevname=1 除非系统达到最低要求，否则会忽略这个选项，同时系统会使用 systemd 命名方案。 如果指定 biosdevname 安装选项，那么它就必须在该系统的声明周期内作为其引导选项使用。 控制网络设备名称选择可以如下方式控制设备命名： 根据网络接口设备识别 在 ifcfg 文件中使用 HWADDR 指令设定 MAC 地址，这样就可由 udev 识别。会从 DEVICE 指令提供的字符串中提取该名称，根据惯例，该名称应使用与 ifcfg 相同的后缀。例如：ifcfg-eth0。 通过打开或关闭 biosdevname 可使用由 biosdevname 提供的名称（如果 biosdevname 可确定）。 通过打开或关闭 systemd-udev 的命名方案 可使用由 systemd-udev 提供的名称（如果 systemd-udev 可确定）。 禁用一致网络设备命名请选择以下方法之一禁用一致网络设备命名： 通过屏蔽默认策略中的 udev 规则文件，禁止分配固定名称，以便重新使用不可预期的内核名称。可为 /dev/null 生成一个符号链接完成“屏蔽”。请作为 root 用户运行以下命令： 1ln -s /dev/null /etc/udev/rules.d/80-net-name-slot.rules 创建自己的手动命名方案。例如：将接口命名为 “internet0”、“dmz0” 或 “lan0”。要创建自己的 udev 规则文件，并为那些设备设置 NAME 属性。确定在使用默认策略文件前使用该文件。例如：将其命名为 /etc/udev/rules.d/70-my-net-names.rules。 修改策略文件，使其选择不同的命名方案后。例如：默认根据接口的 MAC 地址命名所有接口。作为 root 复制默认策略文件，如下： 1cp /usr/lib/udev/rules.d/80-net-name-slot.rules /etc/udev/rules.d/80-net-name-slot.rules 在 /etc/udev/rules.d/ 目录中编辑文件，并根据需要修改。 在 GRUB 2 菜单的内核命令行中添加以下指令： 1net.ifnames=0 更新所有 GRUB 2 内核菜单条目，作为 root 用户输入以下命令： 1grubby --update-kernel=ALL --args=net.ifnames=0]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>网卡配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 7 网卡配置文件说明]]></title>
    <url>%2F2017%2F12%2F17%2F2017-12-17-164910-CentOS7%E7%BD%91%E5%8D%A1%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[摘要 Redhat Linux的网络配置，基本上是通过修改几个配置文件来实现的，虽然也可以用ifconfig来设置IP，用route来配置默认网关，用hostname来配置主机名，但是重启后会丢失。 在RedHat中，系统网络设备的配置文件保存在/etc/sysconfig/network-scripts目录下，ifcfg-eth0包含第一块网卡的配置信息，ifcfg-eth1包含第二块网卡的配置信息。在启动时，系统通过读取这个配置文件决定某个网卡是否启动和如何配置 选项及其说明 下面是/etc/sysconfig/network-scripts/ifcfg-eth0文件中可以配置的选项及对应说明 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859TYPE=Ethernet# 网络类型,Ethernet(以太网)BOOTPROTO=static# 引导协议;# BOOTPROTO=&#123;static|none|dhcp|bootp&#125;# 指定静态地址使用static或none;# 从DHCP服务器获取地址使用dhcp;# 从中心服务器上获得IP地址使用bootp(DHCP前身)DEFROUTE=yes# default route，是否将此设备设为默认路由,如果有多个网卡则只能有一个为yesPEERDNS=yes# 是否在BOOTPROTO为dhcp时接受由DHCP服务器指定的DNS地址覆盖本地(/etc/resolv.conf)的DNS;# 不会立即生效,但重启网络服务或主机都会生效；PEERROUTES=yesIPV4_FAILURE_FATAL=no# 如果ipv4配置失败是否禁用该设备IPV6INIT=no# 是否启用IPv6的接口IPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_PEERDNS=yesIPV6_PEERROUTES=yesIPV6_FAILURE_FATAL=no# 如果ipv6配置失败是否禁用该设备IPV6_ADDR_GEN_MODE=stable-privacyNM_CONTROLLED=no # 是否由Network Manager服务托管USERCTL=no# 是否允许普通用户控制此接口ARPCHECK=yes# 是否检查ARPNAME=eth0# 网络连接的名字UUID=7aa5daf3-244d-4e83-9fd8-27a4df21289a# 用来标识网卡的唯一识别码，MTU=1500# 最大传输单元DEVICE=eth0# 设备名称HWADDR=0c:c4:7a:91:fe:16# 硬件地址/MAC地址ONBOOT=yes# 是否在网络服务启动时启动网卡IPADDR=183.60.153.176# IP地址NETMASK=255.255.255.128# 子网掩码PREFIX=25# 子网掩码NETWORK=183.60.153.128# 网络地址BROADCAST=183.60.153.255# 广播地址GATEWAY=183.60.153.129# 网关(默认路由)DNS1=8.8.8.8# 首选DNSDNS2=114.114.114.114# 备用DNS]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>网卡配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cobbler无人值守安装CentOS 7.4]]></title>
    <url>%2F2017%2F12%2F14%2F2017-12-14-102253-Cobbler%E6%97%A0%E4%BA%BA%E5%80%BC%E5%AE%88%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[在看Cobbler之前请先看一下Kickstart无人值守安装 。了解Cobbler的实现原理。 Cobbler是独立的，不需要先安装Kickstart然后再安装Cobbler Cobbler介绍 Cobbler是一个Linux服务器快速网络安装的服务，而且在经过调整也可以支持网络安装windows。 该工具使用python开发，小巧轻便（才15k行python代码），可以通过网络启动(PXE)的方式来快速安装、重装物理服务器和虚拟机，同时还可以管理DHCP，DNS，TFTP、RSYNC以及yum仓库、构造系统ISO镜像。 Cobbler可以使用命令行方式管理，也提供了基于Web的界面管理工具(cobbler-web)，还提供了API接口，可以方便二次开发使用。 Cobbler是较早前的kickstart的升级版，优点是比较容易配置，还自带web界面比较易于管理。 Cobbler内置了一个轻量级配置管理系统，但它也支持和其它配置管理系统集成，如Puppet，暂时不支持SaltStack。 Cobbler客户端Koan支持虚拟机安装和操作系统重新安装，使重装系统更便捷。 cobbler官网 官方手册 Cobbler集成的服务 PXE服务支持 DHCP服务管理 DNS服务管理(可选bind,dnsmasq) 电源管理 Kickstart服务支持 YUM仓库管理 TFTP(PXE启动时需要) Apache(提供kickstart的安装源，并提供定制化的kickstart配置) Cobbler的基本工作流程 Server端 123456789第一步，启动Cobbler服务第二步，进行Cobbler错误检查，执行cobbler check命令第三步，进行配置同步，执行cobbler sync命令第四步，复制相关启动文件文件到TFTP目录中第五步，启动DHCP服务，提供地址分配第六步，DHCP服务分配IP地址第七步，TFTP传输启动文件第八步，Server端接收安装信息第九步，Server端发送ISO镜像与Kickstart文件 Client端 123456789第一步，客户端以PXE模式启动第二步，客户端获取IP地址第三步，通过TFTP服务器获取启动文件第四步，进入Cobbler安装选择界面第五步，客户端确定加载信息第六步，根据配置信息准备安装系统第七步，加载Kickstart文件第八步，传输系统安装的其它文件第九步，进行安装系统 系统环境配置准备 虚拟环境配置 虚拟机版本：VMware® Workstation 14 Pro 需要搭建DHCP服务器，但在同一局域网多个DHCP服务会有冲突，因此虚拟机使用NAT模式 最好使用全新系统，yum源保持默认即可，否则可能出现依赖关系上的错误 当前使用系统版本 12[root@Cobbler ~]# cat /etc/redhat-release CentOS Linux release 7.4.1708 (Core) IP地址信息 12[root@Cobbler ~]# ip addr show dev eth0 | awk -F '[/ ]+' '/inet /&#123;print $3&#125;'192.168.127.128 系统配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# Disable IPv6 networkFile="/etc/sysconfig/network"confList=(NETWORKING_IPV6=no NOZEROCONF=yes)for var in $&#123;confList[@]&#125;;do if egrep -qs "$&#123;var%%=*&#125;=" $&#123;networkFile&#125;;then sed -ri "s#($&#123;var%%=*&#125;=).*#\1$&#123;var##*=&#125;#" $&#123;networkFile&#125; else echo "$&#123;var&#125;" &gt;&gt; $&#123;networkFile&#125; fidonesed -ri '/(net.ipv6.conf.all.disable_ipv6|net.ipv6.conf.default.disable_ipv6) *= */d' /etc/sysctl.confecho 'net.ipv6.conf.all.disable_ipv6 = 1' &gt;&gt; /etc/sysctl.confecho 'net.ipv6.conf.default.disable_ipv6 = 1' &gt;&gt; /etc/sysctl.conf sysctl -p# Set languagelangfile='/etc/locale.conf'export LANG="en_US.UTF-8";sed -ri '/LANG/s/=.*/="en_US.UTF-8"/' $&#123;langfile&#125;# Turn off selinuxsetenforce 0fileList=(/etc/sysconfig/selinux /etc/selinux/config)for f in $&#123;fileList[@]&#125;;do sed -ri 's/(^SELINUX=).*/\1disabled/' $&#123;f&#125;done# Disable the DNS function of sshdegrep -q '^UseDNS no' /etc/ssh/sshd_config || \sed -ri '/#UseDNS /aUseDNS no' /etc/ssh/sshd_config# Turn off some services/usr/bin/systemctl stop firewalld.service;/usr/bin/systemctl disable firewalld.service;/usr/bin/systemctl is-enabled firewalld.service;# Add firewall policyIPT='/sbin/iptables'# ---------------------------------------for chain in INPUT OUTPUT FORWARD;do $&#123;IPT&#125; -t filter -P $&#123;chain&#125; ACCEPT &amp;&gt;/dev/nulldoneunset chain# ---------------------------------------for chain in PREROUTING POSTROUTING OUTPUT;do $&#123;IPT&#125; -t nat -P $&#123;chain&#125; ACCEPT &amp;&gt;/dev/nulldoneunset chain# ---------------------------------------for chain in PREROUTING INPUT FORWARD OUTPUT POSTROUTING;do $&#123;IPT&#125; -t mangle -P $&#123;chain&#125; ACCEPT &amp;&gt;/dev/nulldoneunset chain# ---------------------------------------for table in filter nat mangle;do $&#123;IPT&#125; -F -t $&#123;table&#125; &amp;&gt;/dev/null $&#123;IPT&#125; -X -t $&#123;table&#125; &amp;&gt;/dev/nulldone# Get epelrepocurl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo 安装Cobbler yum安装 1yum -y install cobbler cobbler-web pykickstart httpd dhcp tftp-server 包说明 123456cobbler #cobbler程序包cobbler-web #cobbler的web服务包pykickstart #cobbler检查kickstart语法错误httpd #Apache web服务dhcp #dhcp服务tftp-server #tftp服务 安装文件说明 123456789101112131415161718192021222324[root@cobbler ~]# rpm -ql cobbler # 查看安装的文件，下面列出部分。/etc/cobbler # 配置文件目录/etc/cobbler/settings # cobbler主配置文件，yaml格式，cobbler是python写的程序。/etc/cobbler/dhcp.template # dhcp服务的配置模板/etc/cobbler/tftpd.template # tftp服务的配置模板/etc/cobbler/rsync.template # rsync服务的配置模板/etc/cobbler/iso # iso模板配置文件目录/etc/cobbler/pxe # pxe模板文件目录/etc/cobbler/power # 电源的配置文件目录/etc/cobbler/users.conf # web服务授权配置文件/etc/cobbler/users.digest # web访问的用户名密码配置文件/etc/cobbler/dnsmasq.template # DNS服务的配置模板/etc/cobbler/modules.conf # cobbler模块配置文件/var/lib/cobbler # cobbler数据目录/var/lib/cobbler/config # 配置文件/var/lib/cobbler/kickstarts # 默认存放kickstart文件/var/lib/cobbler/loaders # 存放的各种引导程序/var/www/cobbler # 系统安装镜像目录/var/www/cobbler/ks_mirror # 导入的系统镜像列表/var/www/cobbler/images # 导入的系统镜像启动文件/var/www/cobbler/repo_mirror # yum源存储目录/var/log/cobbler # 日志目录/var/log/cobbler/install.log # 客户端系统安装日志/var/log/cobbler/cobbler.log # cobbler日志 Cobbler检测依赖关系说明 Cobbler的运行依赖于dhcp、tftp、rsync及dns服务 dhcp可由dhcpd（isc）提供，也可由dnsmasq提供； tftp可由tftp-server程序包提供，也可由cobbler功能提供； rsync有rsync程序包提供，dns可由bind提供，也可由dnsmasq提供； Cobbler可自行管理这些服务中的部分甚至是全部，但需要配置文件/etc/cobbler/settings中的manange_dhcp、manager_tftpd、manager_rsync、manager_dns分别来进行定义 由于各种服务都有着不同的实现方式，如若需要进行自定义，需要通过修改/etc/cobbler/modules.conf配置文件中各服务的模块参数的值来实现。 服务运行状态检查 httpd服务状态检查 12345678910111213141516171819202122[root@Cobbler ~]# systemctl start httpd[root@Cobbler ~]# systemctl status httpd● httpd.service - The Apache HTTP Server Loaded: loaded (/usr/lib/systemd/system/httpd.service; disabled; vendor preset: disabled) Active: active (running) since Thu 2017-12-14 20:27:59 CST; 5s ago Docs: man:httpd(8) man:apachectl(8) Main PID: 1425 (httpd) Status: "Processing requests..." CGroup: /system.slice/httpd.service ├─1425 /usr/sbin/httpd -DFOREGROUND ├─1426 (wsgi:cobbler_w -DFOREGROUND ├─1427 /usr/sbin/httpd -DFOREGROUND ├─1428 /usr/sbin/httpd -DFOREGROUND ├─1429 /usr/sbin/httpd -DFOREGROUND ├─1430 /usr/sbin/httpd -DFOREGROUND └─1431 /usr/sbin/httpd -DFOREGROUNDDec 14 20:27:58 Cobbler systemd[1]: Starting The Apache HTTP Server...Dec 14 20:27:59 Cobbler httpd[1425]: AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 172.20.35.110. Set the '...his messageDec 14 20:27:59 Cobbler systemd[1]: Started The Apache HTTP Server.Hint: Some lines were ellipsized, use -l to show in full. cobblerd服务状态检查 12345678910111213141516[root@Cobbler ~]# systemctl status cobblerd● cobblerd.service - Cobbler Helper Daemon Loaded: loaded (/usr/lib/systemd/system/cobblerd.service; disabled; vendor preset: disabled) Active: inactive (dead)[root@Cobbler ~]# systemctl start cobblerd[root@Cobbler ~]# systemctl status cobblerd● cobblerd.service - Cobbler Helper Daemon Loaded: loaded (/usr/lib/systemd/system/cobblerd.service; disabled; vendor preset: disabled) Active: active (running) since Thu 2017-12-14 20:29:27 CST; 5s ago Process: 1461 ExecStartPost=/usr/bin/touch /usr/share/cobbler/web/cobbler.wsgi (code=exited, status=0/SUCCESS) Main PID: 1460 (cobblerd) CGroup: /system.slice/cobblerd.service └─1460 /usr/bin/python2 -s /usr/bin/cobblerd -FDec 14 20:29:27 Cobbler systemd[1]: Starting Cobbler Helper Daemon...Dec 14 20:29:27 Cobbler systemd[1]: Started Cobbler Helper Daemon. 配置Cobbler检查cobbler配置存在的问题并依次解决 12345678910111213[root@Cobbler ~]# cobbler check The following are potential configuration items that you may want to fix:1 : The 'server' field in /etc/cobbler/settings must be set to something other than localhost, or kickstarting features will not work. This should be a resolvable hostname or IP for the boot server as reachable by all machines that will use it.2 : For PXE to be functional, the 'next_server' field in /etc/cobbler/settings must be set to something other than 127.0.0.1, and should match the IP of the boot server on the PXE network.3 : change 'disable' to 'no' in /etc/xinetd.d/tftp4 : Some network boot-loaders are missing from /var/lib/cobbler/loaders, you may run 'cobbler get-loaders' to download them, or, if you only want to handle x86/x86_64 netbooting, you may ensure that you have installed a *recent* version of the syslinux package installed and can ignore this message entirely. Files in this directory, should you want to support all architectures, should include pxelinux.0, menu.c32, elilo.efi, and yaboot. The 'cobbler get-loaders' command is the easiest way to resolve these requirements.5 : enable and start rsyncd.service with systemctl6 : debmirror package is not installed, it will be required to manage debian deployments and repositories7 : The default password used by the sample templates for newly installed machines (default_password_crypted in /etc/cobbler/settings) is still set to 'cobbler' and should be changed, try: "openssl passwd -1 -salt 'random-phrase-here' 'your-password-here'" to generate new one8 : fencing tools were not found, and are required to use the (optional) power management features. install cman or fence-agents to use themRestart cobblerd and then run 'cobbler sync' to apply changes. 修改/etc/cobbler/settings文件中的server参数的值为提供cobbler服务的主机相应的IP地址或主机名，如server: 192.168.127.128 12cp /etc/cobbler/settings&#123;,.bak&#125;sed -ri 's#^server: 127.0.0.1#server: 192.168.127.128#' /etc/cobbler/settings 修改/etc/cobbler/settings文件中的next_server参数的值为提供PXE服务的主机相应的IP地址，如next_server: 192.168.127.128。server，pxe服务器的IP由于这里使用的是同一台机器，所以填Cobbler服务器的IP即可 1sed -ri 's#^next_server: 127.0.0.1#next_server: 192.168.127.128#' /etc/cobbler/settings 修改/etc/xinetd.d/tftp`文件中的disable参数修改为disable = no` 1234cp /etc/xinetd.d/tftp&#123;,.bak&#125; sed -ri '/disable(\t| )*=/s#yes#no#g' /etc/xinetd.d/tftpsystemctl enable tftp.socketsystemctl start tftp.socket 执行 cobbler get-loaders命令即可 123456789101112131415[root@Cobbler ~]# cobbler get-loaderstask started: 2017-12-15_233004_get_loaderstask started (id=Download Bootloader Content, time=Fri Dec 15 23:30:04 2017)path /var/lib/cobbler/loaders/README already exists, not overwriting existing content, use --force if you wish to updatepath /var/lib/cobbler/loaders/COPYING.elilo already exists, not overwriting existing content, use --force if you wish to updatepath /var/lib/cobbler/loaders/COPYING.yaboot already exists, not overwriting existing content, use --force if you wish to updatepath /var/lib/cobbler/loaders/COPYING.syslinux already exists, not overwriting existing content, use --force if you wish to updatepath /var/lib/cobbler/loaders/elilo-ia64.efi already exists, not overwriting existing content, use --force if you wish to updatepath /var/lib/cobbler/loaders/yaboot already exists, not overwriting existing content, use --force if you wish to updatepath /var/lib/cobbler/loaders/pxelinux.0 already exists, not overwriting existing content, use --force if you wish to updatepath /var/lib/cobbler/loaders/menu.c32 already exists, not overwriting existing content, use --force if you wish to updatepath /var/lib/cobbler/loaders/grub-x86.efi already exists, not overwriting existing content, use --force if you wish to updatepath /var/lib/cobbler/loaders/grub-x86_64.efi already exists, not overwriting existing content, use --force if you wish to update*** TASK COMPLETE ***[root@Cobbler ~]# 启动rsyncd服务 123456789101112131415161718[root@Cobbler ~]# systemctl enable rsyncd Created symlink from /etc/systemd/system/multi-user.target.wants/rsyncd.service to /usr/lib/systemd/system/rsyncd.service.[root@Cobbler ~]# systemctl status rsyncd● rsyncd.service - fast remote file copy program daemon Loaded: loaded (/usr/lib/systemd/system/rsyncd.service; enabled; vendor preset: disabled) Active: inactive (dead)[root@Cobbler ~]# systemctl start rsyncd [root@Cobbler ~]# systemctl status rsyncd ● rsyncd.service - fast remote file copy program daemon Loaded: loaded (/usr/lib/systemd/system/rsyncd.service; enabled; vendor preset: disabled) Active: active (running) since Thu 2017-12-14 21:36:45 CST; 4s ago Main PID: 1617 (rsync) CGroup: /system.slice/rsyncd.service └─1617 /usr/bin/rsync --daemon --no-detachDec 14 21:36:45 Cobbler systemd[1]: Started fast remote file copy program daemon.Dec 14 21:36:45 Cobbler systemd[1]: Starting fast remote file copy program daemon...Dec 14 21:36:45 Cobbler rsyncd[1617]: rsyncd version 3.0.9 starting, listening on port 873 安装debmirror 12yum -y install debmirrorsed -ri '/^(@dists=|@arches).*/s/^/#/g' /etc/debmirror.conf 生成密码来取代默认的密码，更安全 123openssl passwd -1 -salt litingjie 123456$1$litingji$qUWL9htxlLybWLhSuyL8g/sed -ri 's#^(default_password_crypted:).*#\1 "$1$litingji$qUWL9htxlLybWLhSuyL8g/"#' /etc/cobbler/settings 安装cman fence-agents 1yum -y install cman fence-agents 其他配置的修改 用cobbler管理DHCP 1sed -ri 's#^(manage_dhcp:).*#\1 1#g' /etc/cobbler/settings 防止循环装系统，适用于服务器第一启动项是PXE启动 1sed -ri '/^pxe_just_once:.*/s#0#1#g' /etc/cobbler/settings 重启服务，再次检查 123systemctl restart cobblerd.service[root@Cobbler ~]# cobbler checkNo configuration problems found. All systems go. 配置DHCP 修改cobbler的dhcp模版文件/etc/cobbler/dhcp.template，这个模板会覆盖dhcp本身的配置文件。 123456789101112131415161718192021222324subnet 192.168.127.0 netmask 255.255.255.0 &#123; option routers 192.168.127.2; option domain-name-servers 192.168.127.2; option subnet-mask 255.255.255.0; range dynamic-bootp 192.168.127.130 192.168.127.230; default-lease-time 21600; max-lease-time 43200; next-server $next_server; class "pxeclients" &#123; match if substring (option vendor-class-identifier, 0, 9) = "PXEClient"; if option pxe-system-type = 00:02 &#123; filename "ia64/elilo.efi"; &#125; else if option pxe-system-type = 00:06 &#123; filename "grub/grub-x86.efi"; &#125; else if option pxe-system-type = 00:07 &#123; filename "grub/grub-x86_64.efi"; &#125; else if option pxe-system-type = 00:09 &#123; filename "grub/grub-x86_64.efi"; &#125; else &#123; filename "pxelinux.0"; &#125; &#125;&#125; 同步cobbler的配置，可以看到同步做了哪些操作 1cobbler sync 配置开机启动 为了保证所有服务在开机之后都运行起来直接可以投入使用，需要加入系统服务开机自启 1for s in dhcpd rsyncd tftp httpd cobblerd ;do systemctl start $&#123;s&#125;;systemctl enable $&#123;s&#125;; done Cobbler的命令行管理 获取usage 123456[root@Cobbler ~]# cobblerusage=====cobbler &lt;distro|profile|system|repo|image|mgmtclass|package|file&gt; ... [add|edit|copy|getks*|list|remove|rename|report] [options|--help]cobbler &lt;aclsetup|buildiso|import|list|replicate|report|reposync|sync|validateks|version|signature|get-loaders|hardlink&gt; [options|--help] 选项说明 12345678cobbler check 核对当前设置是否有问题cobbler list 列出所有的cobbler元素cobbler report 列出元素的详细信息cobbler sync 同步配置到数据目录,更改配置最好都要执行下cobbler reposync 同步yum仓库cobbler distro 查看导入的发行版系统信息cobbler system 查看添加的系统信息cobbler profile 查看配置信息 镜像导入 挂载镜像 12[root@Cobbler ~]# mount /dev/cdrom /mnt/mount: /dev/sr0 is write-protected, mounting read-only 导入镜像 123456789101112131415161718192021222324[root@Cobbler ~]# cobbler import --path=/mnt/ --name=CentOS_7.4.1708_x86_64 --arch=x86_64task started: 2017-12-14_223147_importtask started (id=Media import, time=Thu Dec 14 22:31:47 2017)Found a candidate signature: breed=redhat, version=rhel6Found a candidate signature: breed=redhat, version=rhel7Found a matching signature: breed=redhat, version=rhel7Adding distros from path /var/www/cobbler/ks_mirror/CentOS_7.4.1708_x86_64-x86_64:creating new distro: CentOS_7.4.1708-x86_64trying symlink: /var/www/cobbler/ks_mirror/CentOS_7.4.1708_x86_64-x86_64 -&gt; /var/www/cobbler/links/CentOS_7.4.1708-x86_64creating new profile: CentOS_7.4.1708-x86_64associating reposchecking for rsync repo(s)checking for rhn repo(s)checking for yum repo(s)starting descent into /var/www/cobbler/ks_mirror/CentOS_7.4.1708_x86_64-x86_64 for CentOS_7.4.1708-x86_64processing repo at : /var/www/cobbler/ks_mirror/CentOS_7.4.1708_x86_64-x86_64need to process repo/comps: /var/www/cobbler/ks_mirror/CentOS_7.4.1708_x86_64-x86_64looking for /var/www/cobbler/ks_mirror/CentOS_7.4.1708_x86_64-x86_64/repodata/*comps*.xmlKeeping repodata as-is :/var/www/cobbler/ks_mirror/CentOS_7.4.1708_x86_64-x86_64/repodata*** TASK COMPLETE ***# --path 镜像路径# --name 为安装源定义一个名字# --arch 指定安装源是32位、64位、ia64, 目前支持的选项有: x86│x86_64│ia64# 安装源的唯一标示就是根据name参数来定义，本例导入成功后，安装源的唯一标示就是：CentOS_7.4.1708_x86_64，如果重复，系统会提示导入失败。 查看镜像列表 12[root@Cobbler ~]# cobbler distro list CentOS_7.4.1708-x86_64 镜像存放目录 12345[root@Cobbler ~]# cd /var/www/cobbler/ks_mirror/[root@Cobbler ks_mirror]# lsCentOS_7.4.1708_x86_64-x86_64 config[root@Cobbler ks_mirror]# ls CentOS_7.4.1708_x86_64-x86_64/CentOS_BuildTag EFI EULA GPL images isolinux LiveOS Packages repodata RPM-GPG-KEY-CentOS-7 RPM-GPG-KEY-CentOS-Testing-7 TRANS.TBL 配置ks文件 拷贝模板 在第一次导入系统镜像后，Cobbler会给镜像指定一个默认的kickstart自动安装文件在/var/lib/cobbler/kickstarts/下的sample_end.ks 12[root@Cobbler ks_mirror]# cd /var/lib/cobbler/kickstarts/[root@Cobbler kickstarts]# cp sample_end.ks CentOS_7.4.1708-x86_64.cfg 元素查看 123456789101112131415161718[root@Cobbler kickstarts]# cobbler listdistros: CentOS_7.4.1708-x86_64profiles: CentOS_7.4.1708-x86_64systems:repos:images:mgmtclasses:packages:files: 配置内容vim /var/lib/cobbler/kickstarts/CentOS_7.4.1708-x86_64.cfg 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104# This kickstart file should only be used with EL &gt; 5 and/or Fedora &gt; 7.# For older versions please use the sample.ks kickstart file.#platform=x86, AMD64, or Intel EM64T# System authorization information#auth --useshadow --enablemd5authconfig --enableshadow --passalgo=sha512# System bootloader configurationbootloader --location=mbr --driveorder=sda --append="nomodeset crashkernel=auto rhgb quiet"# Partition clearing informationclearpart --all --initlabel# Use text mode installtext# Firewall configurationfirewall --disabled# Run the Setup Agent on first bootfirstboot --disable# System keyboardkeyboard us# System languagelang en_US.UTF-8# Use network installationurl --url=$tree# If any cobbler repo definitions were referenced in the kickstart profile, include them here.$yum_repo_stanza# Network information$SNIPPET('network_config')# Reboot after installationreboot# Installation logging levellogging --level=info#Root passwordrootpw --iscrypted $default_password_crypted# System servicesservices --disabled="NetworkManager"services --disabled="postfix"# SELinux configurationselinux --disabled# Do not configure the X Window Systemskipx# System timezonetimezone Asia/Shanghai# Install OS instead of upgradeinstall# Clear the Master Boot Recordzerombr# Allow anaconda to partition the system as needed#autopartpart /boot --fstype="xfs" --asprimary --size=200part swap --fstype="swap" --asprimary --size=2000part / --fstype="xfs" --asprimary --size=18279%pre$SNIPPET('log_ks_pre')$SNIPPET('kickstart_start')$SNIPPET('pre_install_network_config')# Enable installation monitoring$SNIPPET('pre_anamon')%end%packages@^minimal@compat-libraries@core@developmentkexec-toolstreewgetopenssh-clientsglibcgmpbzip2bind-utilsnet-toolsmtr lrzsznmaptcpdumpdos2unix%end%post --nochroot$SNIPPET('log_ks_post_nochroot')%end%post$SNIPPET('log_ks_post')# Start yum configuration$yum_config_stanza# End yum configuration$SNIPPET('post_install_kernel_options')$SNIPPET('post_install_network_config')$SNIPPET('func_register_if_enabled')$SNIPPET('download_config_files')$SNIPPET('koan_environment')$SNIPPET('redhat_register')$SNIPPET('cobbler_register')# Enable post-install boot notification$SNIPPET('post_anamon')# Start final steps$SNIPPET('kickstart_done')# End final steps%end 查看安装镜像文件信息 123456789101112131415161718[root@Cobbler ~]# cobbler distro report --name=CentOS_7.4.1708-x86_64Name : CentOS_7.4.1708-x86_64Architecture : x86_64TFTP Boot Files : &#123;&#125;Breed : redhatComment : Fetchable Files : &#123;&#125;Initrd : /var/www/cobbler/ks_mirror/CentOS_7.4.1708_x86_64-x86_64/images/pxeboot/initrd.imgKernel : /var/www/cobbler/ks_mirror/CentOS_7.4.1708_x86_64-x86_64/images/pxeboot/vmlinuzKernel Options : &#123;&#125;Kernel Options (Post Install) : &#123;&#125;Kickstart Metadata : &#123;'tree': 'http://@@http_server@@/cblr/links/CentOS_7.4.1708-x86_64'&#125;Management Classes : []OS Version : rhel7Owners : ['admin']Red Hat Management Key : &lt;&lt;inherit&gt;&gt;Red Hat Management Server : &lt;&lt;inherit&gt;&gt;Template Files : &#123;&#125; 查看指定的profile设置 123456789101112131415161718192021222324252627282930313233[root@Cobbler ~]# cobbler profile report --name=CentOS_7.4.1708-x86_64Name : CentOS_7.4.1708-x86_64TFTP Boot Files : &#123;&#125;Comment : DHCP Tag : defaultDistribution : CentOS_7.4.1708-x86_64Enable gPXE? : 0Enable PXE Menu? : 1Fetchable Files : &#123;&#125;Kernel Options : &#123;'biosdevname': '0', 'net.ifnames': '0'&#125;Kernel Options (Post Install) : &#123;&#125;Kickstart : /var/lib/cobbler/kickstarts/CentOS_7.4.1708-x86_64.cfgKickstart Metadata : &#123;&#125;Management Classes : []Management Parameters : &lt;&lt;inherit&gt;&gt;Name Servers : []Name Servers Search Path : []Owners : ['admin']Parent Profile : Internal proxy : Red Hat Management Key : &lt;&lt;inherit&gt;&gt;Red Hat Management Server : &lt;&lt;inherit&gt;&gt;Repos : []Server Override : &lt;&lt;inherit&gt;&gt;Template Files : &#123;&#125;Virt Auto Boot : 1Virt Bridge : xenbr0Virt CPUs : 1Virt Disk Driver Type : rawVirt File Size(GB) : 5Virt Path : Virt RAM (MB) : 512Virt Type : kvm 编辑profile，修改关联的ks文件 1cobbler profile edit --name=CentOS_7.4.1708-x86_64 --kickstart=/var/lib/cobbler/kickstarts/CentOS_7.4.1708-x86_64.cfg 修改安装系统的内核参数 在CentOS7系统有一个地方变了，就是网卡名变成eno*这种形式 为了运维标准化，我们需要将它变成我们常用的eth0 123cobbler profile edit --name=CentOS_7.4.1708-x86_64 --kopts='net.ifnames=0 biosdevname=0'cobbler profile report --name=CentOS_7.4.1708-x86_64# 可以看到Kickstart那里的配置cfg文件地址被改变了 开机画面显示的修改，编辑/etc/cobbler/pxe/pxedefault.template 123MENU TITLE Cobbler | http://cobbler.github.io/# 改为自定义title，如下MENU TITLE Cobbler | Cobbler Install 同步Cobbler数据，每次修改完都需要同步 1cobbler sync 常见问题与处理tftp启动异常 参考链接：https://docs.fedoraproject.org/en-US/Fedora/23/html/Installation_Guide/pxe-tftpd.html 123[root@Cobbler ~]# netstat -tunlp | grep 69[root@Cobbler ~]# systemctl start tftpA dependency job for tftp.service failed. See 'journalctl -xe' for details. 解决方法 1234567891011# Start and enable the tftp socket. systemd will automatically start the// tftpd service when required. # 开始并允许tftp服务，系统会自动启动tftp服务所需的服务[root@Cobbler ~]# systemctl enable tftp.socket[root@Cobbler ~]# systemctl start tftp.socket [root@Cobbler ~]# systemctl start tftp[root@Cobbler ~]# netstat -tunlp | grep 69 udp 0 0 0.0.0.0:69 0.0.0.0:* 1/systemd [root@Cobbler ~]# chmod +x /etc/rc.d/rc.local [root@Cobbler ~]# echo systemctl enable tftp.socket &gt;&gt; /etc/rc.d/rc.local[root@Cobbler ~]# echo systemctl start tftp.socket &gt;&gt; /etc/rc.d/rc.local 引导选择干扰自动化 客户机引导时出现选择页面，local 和CentOS_7.4.1708-x86_64，干扰自动部署 解决方法：编辑/var/lib/tftpboot/pxelinux.cfg/default 将local对应的LABEL注释掉 修改TIMEOUT为 10，即1秒 修改ONTIMEOUT为对应的LabelCentOS_7.4.1708-x86_64 客户机引导之后出现异常 报错表现 12umount: /run/initramfs/squashfs: not mounted/sbin/dmsquash-live-root: line 273: printf: write error: No space left on device 解决方法 内存不足，扩充内存至1G以上即可]]></content>
      <categories>
        <category>系统安装</category>
      </categories>
      <tags>
        <tag>系统安装</tag>
        <tag>无人值守</tag>
        <tag>cobbler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Haproxy配置实例]]></title>
    <url>%2F2017%2F12%2F06%2F2017-12-06-170110-Haproxy%E9%85%8D%E7%BD%AE%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[haproxy是一款功能强大、灵活好用反向代理软件，提供了高可用、负载均衡、后端服务器代理的功能，它在7层负载均衡方面的功能很强大(支持cookie track, header rewrite等等)，支持双机热备，支持虚拟主机，拥有非常不错的服务器健康检查功能，当其代理的后端服务器出现故障, HAProxy会自动将该服务器摘除，故障恢复后再自动将该服务器加入;同时还提供直观的监控页面，可以清晰实时的监控服务集群的运行状况。 负载均衡http服务器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#---------------------------------------------------------------------# Global settings#---------------------------------------------------------------------global # to have these messages end up in /var/log/haproxy.log you will # need to: # # 1) configure syslog to accept network log events. This is done # by adding the '-r' option to the SYSLOGD_OPTIONS in # /etc/sysconfig/syslog # # 2) configure local2 events to go to the /var/log/haproxy.log # file. A line like the following can be added to # /etc/sysconfig/syslog # # local2.* /var/log/haproxy.log # log 127.0.0.1 local2 chroot /var/lib/haproxy pidfile /var/run/haproxy.pid maxconn 4000 user haproxy group haproxy daemondefaults mode http log global option httplog option dontlognull option http-server-close option forwardfor except 127.0.0.0/8 option redispatch retries 3 timeout http-request 10s timeout queue 1m timeout connect 10s timeout client 1m timeout server 1m timeout http-keep-alive 10s timeout check 10s maxconn 30000listen stats mode http bind 0.0.0.0:1080 stats enable stats hide-version stats uri /haproxyadmin?stats stats realm Haproxy\ Statistics stats auth admin:admin stats admin if TRUEfrontend http-in bind *:80 mode http log global option httpclose option logasap option dontlognull capture request header Host len 20 capture request header Referer len 60 default_backend serversfrontend healthcheck bind :1099 mode http option httpclose option forwardfor default_backend serversbackend servers balance roundrobin server websrv1 192.168.10.11:80 check maxconn 2000 server websrv2 192.168.10.12:80 check maxconn 2000 负载均衡MySQL服务器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#---------------------------------------------------------------------# Global settings#---------------------------------------------------------------------global # to have these messages end up in /var/log/haproxy.log you will # need to: # # 1) configure syslog to accept network log events. This is done # by adding the '-r' option to the SYSLOGD_OPTIONS in # /etc/sysconfig/syslog # # 2) configure local2 events to go to the /var/log/haproxy.log # file. A line like the following can be added to # /etc/sysconfig/syslog # # local2.* /var/log/haproxy.log # log 127.0.0.1 local2 chroot /var/lib/haproxy pidfile /var/run/haproxy.pid maxconn 4000 user haproxy group haproxy daemondefaults mode tcp log global option httplog option dontlognull retries 3 timeout http-request 10s timeout queue 1m timeout connect 10s timeout client 1m timeout server 1m timeout http-keep-alive 10s timeout check 10s maxconn 600listen stats mode http bind 0.0.0.0:1080 stats enable stats hide-version stats uri /haproxyadmin?stats stats realm Haproxy\ Statistics stats auth admin:admin stats admin if TRUEfrontend mysql bind *:3306 mode tcp log global default_backend mysqlserversbackend mysqlservers balance leastconn server dbsrv1 192.168.10.11:3306 check port 3306 intval 2 rise 1 fall 2 maxconn 300 server dbsrv2 192.168.10.12:3306 check port 3306 intval 2 rise 1 fall 2 maxconn 300]]></content>
      <categories>
        <category>Haproxy</category>
      </categories>
      <tags>
        <tag>Haproxy</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Haproxy实现状态监控页面]]></title>
    <url>%2F2017%2F12%2F05%2F2017-12-05-082710-Haproxy%E5%AE%9E%E7%8E%B0%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[Haproxy监控页面12345678910listen stats #关联前端和后端定义一个完整的代理 mode http #设置代理协议 bind 0.0.0.0:1080 #绑定相应的端口 stats enable #开启Haproxy统计状态 stats refresh 3s #统计页面自动刷新时间间隔 stats hide-version #隐藏代理服务器版本 stats uri /haproxyadmin?stats #访问的url stats realm Haproxy\ Statistics #统计页面认证时提示内容信息 stats auth admin:123456 #设置登录用户和密码 stats admin if TRUE #如果认证通过，则就可以打开stats 加入配置，重启服务后访问http://192.168.127.130:1080//haproxyadmin?stats]]></content>
      <categories>
        <category>Haproxy</category>
      </categories>
      <tags>
        <tag>Haproxy</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Haproxy配置文件参数说明]]></title>
    <url>%2F2017%2F12%2F04%2F2017-12-04-223110-Haproxy%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[官方文档：http://www.haproxy.org/#docs 配置HAProxy配置文件格式Haproxy的配置处理3类来主要参数来源： 最优先处理的命令行参数； global配置段，用于设定全局配置参数； proxy相关配置段，如defaults、listen、frontend和backend； 时间格式一些包含了值的参数表示时间，如超时时长。这些值一般以毫秒为单位，但也可以使用其它的时间单位后缀。 us: 微秒(microseconds)，即1/1000000秒； ms: 毫秒(milliseconds)，即1/1000秒； s: 秒(seconds)； m: 分钟(minutes)； h：小时(hours)； d: 天(days)； 例子下面的例子配置了一个监听在所有接口的80端口上HTTP proxy服务，它转发所有的请求至后端监听在127.0.0.1:8000上的”server”。 12345678910111213141516global daemon maxconn 25600 defaults mode http timeout connect 5000ms timeout client 50000ms timeout server 50000ms frontend http-in bind *:80 default_backend servers backend servers server server1 127.0.0.1:8080 maxconn 32 全局配置global配置中的参数为进程级别的参数，且通常与其运行的OS相关。 进程管理及安全相关的参数 chroot &lt;jail dir&gt;：修改haproxy的工作目录至指定的目录并在放弃权限之前执行chroot()操作，可以提升haproxy的安全级别，不过需要注意的是要确保指定的目录为空目录且任何用户均不能有写权限；一般情况下可以考虑不要，配置文件中注释掉或删掉即可； daemon：让haproxy以守护进程的方式工作于后台，其等同于“-D”选项的功能，当然，也可以在命令行中以“-db”选项将其禁用； gid &lt;number&gt;：以指定的GID运行haproxy，建议使用专用于运行haproxy的GID，以免因权限问题带来风险； group &lt;group name&gt;：同gid，不过指定的组名； log &lt;address&gt; &lt;facility&gt; [max level [min level]]：定义全局的syslog服务器，最多可以定义两个； log-send-hostname [&lt;string&gt;]：在syslog信息的首部添加当前主机名，可以为“string”指定的名称，也可以缺省使用当前主机名； nbproc &lt;number&gt;：指定启动的haproxy进程个数，只能用于守护进程模式的haproxy；默认只启动一个进程，鉴于调试困难等多方面的原因，一般只在单进程仅能打开少数文件描述符的场景中才使用多进程模式； pidfile：pid文件，也可以使用命令行中”-p”选项指定pid文件 uid：以指定的UID身份运行haproxy进程； ulimit-n：设定每进程所能够打开的最大文件描述符数目，默认情况下其会自动进行计算，因此不推荐修改此选项； user：同uid，但使用的是用户名； stats：是否开启Haproxy 状态信息页面 node：定义当前节点的名称，用于HA场景中多haproxy进程共享同一个IP地址时； description：当前实例的描述信息； 性能调整相关的参数 maxconn &lt;number&gt;：设定每个haproxy进程所接受的最大并发连接数，其等同于命令行选项“-n”；“ulimit -n”自动计算的结果正是参照此参数设定的； maxpipes &lt;number&gt;：haproxy使用pipe完成基于内核的tcp报文重组，此选项则用于设定每进程所允许使用的最大pipe个数；每个pipe会打开两个文件描述符，因此，“ulimit -n”自动计算时会根据需要调大此值；默认为maxconn/4，其通常会显得过大； noepoll：在Linux系统上禁用epoll机制； nokqueue：在BSE系统上禁用kqueue机制； nopoll：禁用poll机制； nosepoll：在Linux禁用启发式epoll机制； nosplice：禁止在Linux套接字上使用内核tcp重组，这会导致更多的recv/send系统调用；不过，在Linux 2.6.25-28系列的内核上，tcp重组功能有bug存在； spread-checks &lt;0..50, in percent&gt;：在haproxy后端有着众多服务器的场景中，在精确的时间间隔后统一对众服务器进行健康状况检查可能会带来意外问题；此选项用于将其检查的时间间隔长度上增加或减小一定的随机时长； tune.bufsize &lt;number&gt;：设定buffer的大小，同样的内存条件大小，较小的值可以让haproxy有能力接受更多的并发连接，较大的值可以让某些应用程序使用较大的cookie信息；默认为16384，其可以在编译时修改，不过强烈建议使用默认值； tune.chksize &lt;number&gt;：设定检查缓冲区的大小，单位为字节；更大的值有助于在较大的页面中完成基于字符串或模式的文本查找，但也会占用更多的系统资源；不建议修改； tune.maxaccept &lt;number&gt;：设定haproxy进程内核调度运行时一次性可以接受的连接的个数，较大的值可以带来较大的吞吐率，默认在单进程模式下为100，多进程模式下为8，设定为-1可以禁止此限制；一般不建议修改； tune.maxpollevents &lt;number&gt;：设定一次系统调用可以处理的事件最大数，默认值取决于OS；其值小于200时可节约带宽，但会略微增大网络延迟，而大于200时会降低延迟，但会稍稍增加网络带宽的占用量； tune.maxrewrite &lt;number&gt;：设定为首部重写或追加而预留的缓冲空间，建议使用1024左右的大小；在需要使用更大的空间时，haproxy会自动增加其值； Debug相关的参数 debug quiet 代理代理相关的配置可以如下配置段中。 defaults &lt;name&gt;“defaults”段用于为所有其它配置段提供默认参数，这配置默认配置参数可由下一个“defaults”所重新设定。 frontend &lt;name&gt;“frontend”段用于定义一系列监听的套接字，这些套接字可接受客户端请求并与之建立连接。 backend &lt;name&gt;“backend”段用于定义一系列“后端”服务器，代理将会将对应客户端的请求转发至这些服务器。 listen &lt;name&gt;“listen”段通过关联“前端”和“后端”定义了一个完整的代理，通常只对TCP流量有用。 所有代理的名称只能使用大写字母、小写字母、数字、-(中线)、_(下划线)、.(点号)和:(冒号)。此外，ACL名称会区分字母大小写。 配置文件中的关键字参考balance12balance &lt;algorithm&gt; [ &lt;arguments&gt; ]balance url_param &lt;param&gt; [check_post [&lt;max_wait&gt;]] 定义负载均衡算法，可用于“defaults”、“listen”和“backend”。&lt;algorithm&gt;用于在负载均衡场景中挑选一个server，其仅应用于持久信息不可用的条件下或需要将一个连接重新派发至另一个服务器时。支持的算法有： roundrobin 基于权重进行轮叫，在服务器的处理时间保持均匀分布时，这是最平衡、最公平的算法 此算法是动态的，这表示其权重可以在运行时进行调整，不过，在设计上，每个后端服务器仅能最多接受4128个连接； static-rr 基于权重进行轮叫，与roundrobin类似，但是为静态方法，在运行时调整其服务器权重不会生效；不过，其在后端服务器连接数上没有限制； leastconn 新的连接请求被派发至具有最少连接数目的后端服务器 在有着较长时间会话的场景中推荐使用此算法，如LDAP、SQL等，其并不太适用于较短会话的应用层协议，如HTTP； 此算法是动态的，可以在运行时调整其权重； source 将请求的源地址进行hash运算，并由后端服务器的权重总数相除后派发至某匹配的服务器； 这可以使得同一个客户端IP的请求始终被派发至某特定的服务器； 不过，当服务器权重总数发生变化时，如某服务器宕机或添加了新的服务器，许多客户端的请求可能会被派发至与此前请求不同的服务器； 常用于负载均衡无cookie功能的基于TCP的协议； 其默认为静态，不过也可以使用hash-type修改此特性； uri 对URI的左半部分(“问题”标记之前的部分)或整个URI进行hash运算，并由服务器的总权重相除后派发至某匹配的服务器； 这可以使得对同一个URI的请求总是被派发至某特定的服务器，除非服务器的权重总数发生了变化；此算法常用于代理缓存或反病毒代理以提高缓存的命中率； 需要注意的是，此算法仅应用于HTTP后端服务器场景； 其默认为静态算法，不过也可以使用hash-type修改此特性； url_param 通过&lt;argument&gt;为URL指定的参数在每个HTTP GET请求中将会被检索； 如果找到了指定的参数且其通过等于号“=”被赋予了一个值，那么此值将被执行hash运算并被服务器的总权重相除后派发至某匹配的服务器； 此算法可以通过追踪请求中的用户标识进而确保同一个用户ID的请求将被送往同一个特定的服务器，除非服务器的总权重发生了变化； 如果某请求中没有出现指定的参数或其没有有效值，则使用轮叫算法对相应请求进行调度； 此算法默认为静态的，不过其也可以使用hash-type修改此特性； hdr(&lt;name&gt;) 对于每个HTTP请求，通过指定的HTTP首部将会被检索； 如果相应的首部没有出现或其没有有效值，则使用轮叫算法对相应请求进行调度； 其有一个可选选项“use_domain_only”，可在指定检索类似Host类的首部时仅计算域名部分(比如通过www.magedu.com来说，仅计算magedu字符串的hash值)以降低hash算法的运算量； 此算法默认为静态的，不过其也可以使用hash-type修改此特性； bind12bind [&lt;address&gt;]:&lt;port_range&gt; [, ...]bind [&lt;address&gt;]:&lt;port_range&gt; [, ...] interface &lt;interface&gt; 此指令仅能用于frontend和listen区段，用于定义一个或几个监听的套接字。 &lt;address&gt;：可选选项，其可以为主机名、IPv4地址、IPv6地址或；省略此选项、将其指定为或0.0.0.0时，将监听当前系统的所有IPv4地址； &lt;port_range&gt;：可以是一个特定的TCP端口，也可是一个端口范围(如5005-5010)，代理服务器将通过指定的端口来接收客户端请求；需要注意的是，每组监听的套接字在同一个实例上只能使用一次，而且小于1024的端口需要有特定权限的用户才能使用，这可能需要通过uid参数来定义； &lt;interface&gt;：指定物理接口的名称，仅能在Linux系统上使用；其不能使用接口别名，而仅能使用物理接口名称，而且只有管理有权限指定绑定的物理接口； mode1mode &#123; tcp|http|health &#125; 设定实例的运行模式或协议。当实现内容交换时，前端和后端必须工作于同一种模式(一般说来都是HTTP模式)，否则将无法启动实例。 tcp：实例运行于纯TCP模式，在客户端和服务器端之间将建立一个全双工的连接，且不会对7层报文做任何类型的检查；此为默认模式，通常用于SSL、SSH、SMTP等应用； http：实例运行于HTTP模式，客户端请求在转发至后端服务器之前将被深度分析，所有不与RFC格式兼容的请求都会被拒绝； health：实例工作于health模式，其对入站请求仅响应“OK”信息并关闭连接，且不会记录任何日志信息；此模式将用于响应外部组件的健康状态检查请求；目前业讲，此模式已经废弃，因为tcp或http模式中的monitor关键字可完成类似功能； hash-type1hash-type &lt;method&gt; 定义用于将hash码映射至后端服务器的方法；其不能用于frontend区段；可用方法有map-based和consistent，在大多数场景下推荐使用默认的map-based方法。 map-based：hash表是一个包含了所有在线服务器的静态数组。其hash值将会非常平滑，会将权重考虑在列，但其为静态方法，对在线服务器的权重进行调整将不会生效，这意味着其不支持慢速启动。此外，挑选服务器是根据其在数组中的位置进行的，因此，当一台服务器宕机或添加了一台新的服务器时，大多数连接将会被重新派发至一个与此前不同的服务器上，对于缓存服务器的工作场景来说，此方法不甚适用。 consistent：hash表是一个由各服务器填充而成的树状结构；基于hash键在hash树中查找相应的服务器时，最近的服务器将被选中。此方法是动态的，支持在运行时修改服务器权重，因此兼容慢速启动的特性。添加一个新的服务器时，仅会对一小部分请求产生影响，因此，尤其适用于后端服务器为cache的场景。不过，此算法不甚平滑，派发至各服务器的请求未必能达到理想的均衡效果，因此，可能需要不时的调整服务器的权重以获得更好的均衡性。 log12log globallog &lt;address&gt; &lt;facility&gt; [&lt;level&gt; [&lt;minlevel&gt;]] 为每个实例启用事件和流量日志，因此可用于所有区段。每个实例最多可以指定两个log参数，不过，如果使用了“log global”且”global”段已经定了两个log参数时，多余了log参数将被忽略。 global：当前实例的日志系统参数同”global”段中的定义时，将使用此格式；每个实例仅能定义一次“log global”语句，且其没有任何额外参数； &lt;address&gt;：定义日志发往的位置，其格式之一可以为，其中的port为UDP协议端口，默认为514；格式之二为Unix套接字文件路径，但需要留心chroot应用及用户的读写权限； &lt;facility&gt;：可以为syslog系统的标准facility之一； &lt;level&gt;：定义日志级别，即输出信息过滤器，默认为所有信息；指定级别时，所有等于或高于此级别的日志信息将会被发送； maxconn1maxconn &lt;conns&gt; 设定一个前端的最大并发连接数，因此，其不能用于backend区段。对于大型站点来说，可以尽可能提高此值以便让haproxy管理连接队列，从而避免无法应答用户请求。当然，此最大值不能超出“global”段中的定义。此外，需要留心的是，haproxy会为每个连接维持两个缓冲，每个缓冲的大小为8KB，再加上其它的数据，每个连接将大约占用17KB的RAM空间。这意味着经过适当优化后，有着1GB的可用RAM空间时将能维护40000-50000并发连接。 如果为指定了一个过大值，极端场景下，其最终占据的空间可能会超出当前主机的可用内存，这可能会带来意想不到的结果；因此，将其设定了一个可接受值方为明智决定。其默认为2000。 default_backend1default_backend &lt;backend&gt; 在没有匹配的”use_backend”规则时为实例指定使用的默认后端，因此，其不可应用于backend区段 在”frontend”和”backend”之间进行内容交换时，通常使用”use-backend”定义其匹配规则；而没有被规则匹配到的请求将由此参数指定的后端接收 ：指定使用的后端的名称； 使用案例： 123use_backend dynamic if url_dynuse_backend static if url_css url_img extension_imgdefault_backend dynamic server1server &lt;name&gt; &lt;address&gt;[:port] [param*] 为后端声明一个server，因此，不能用于defaults和frontend区段。 &lt;name&gt;：为此服务器指定的内部名称，其将出现在日志及警告信息中；如果设定了”http-send-server-name”，它还将被添加至发往此服务器的请求首部中； &lt;address&gt;：此服务器的的IPv4地址，也支持使用可解析的主机名，只不过在启动时需要解析主机名至相应的IPv4地址； [:port]：指定将连接请求所发往的此服务器时的目标端口，其为可选项；未设定时，将使用客户端请求时的同一相端口； [param*]：为此服务器设定的一系参数；其可用的参数非常多，具体请参考官方文档中的说明，下面仅说明几个常用的参数； 服务器或默认服务器参数： backup：设定为备用服务器，仅在负载均衡场景中的其它server均不可用于启用此server； check：启动对此server执行健康状态检查，其可以借助于额外的其它参数完成更精细的设定，如： inter &lt;delay&gt;：设定健康状态检查的时间间隔，单位为毫秒，默认为2000；也可以使用fastinter和downinter来根据服务器端状态优化此时间延迟； rise &lt;count&gt;：设定健康状态检查中，某离线的server从离线状态转换至正常状态需要成功检查的次数； fall &lt;count&gt;：确认server从正常状态转换为不可用状态需要检查的次数； cookie &lt;value&gt;：为指定server设定cookie值，此处指定的值将在请求入站时被检查，第一次为此值挑选的server将在后续的请求中被选中，其目的在于实现持久连接的功能； maxconn &lt;maxconn&gt;：指定此服务器接受的最大并发连接数；如果发往此服务器的连接数目高于此处指定的值，其将被放置于请求队列，以等待其它连接被释放； maxqueue &lt;maxqueue&gt;：设定请求队列的最大长度； observe &lt;mode&gt;：通过观察服务器的通信状况来判定其健康状态，默认为禁用，其支持的类型有“layer4”和“layer7”，“layer7”仅能用于http代理场景； redir &lt;prefix&gt;：启用重定向功能，将发往此服务器的GET和HEAD请求均以302状态码响应；需要注意的是，在prefix后面不能使用/，且不能使用相对地址，以免造成循环；例如：server srv1 172.16.100.6:80 redir http://imageserver.magedu.com check weight &lt;weight&gt;：权重，默认为1，最大值为256，0表示不参与负载均衡； 检查方法： option httpchk option httpchk &lt;uri&gt; option httpchk &lt;method&gt; &lt;uri&gt; option httpchk &lt;method&gt; &lt;uri&gt; &lt;version&gt;：不能用于frontend段，例如： 1234backend https_relay mode tcp option httpchk OPTIONS * HTTP/1.1\r\nHost:\ www.magedu.com server apache1 192.168.1.1:443 check port 80 使用案例： 12server first 172.16.100.7:1080 cookie first check inter 1000server second 172.16.100.8:1080 cookie second check inter 1000 capture request header1capture request header &lt;name&gt; len &lt;length&gt; 捕获并记录指定的请求首部最近一次出现时的第一个值，仅能用于“frontend”和“listen”区段。捕获的首部值使用花括号{}括起来后添加进日志中。如果需要捕获多个首部值，它们将以指定的次序出现在日志文件中，并以竖线“|”作为分隔符。不存在的首部记录为空字符串，最常需要捕获的首部包括在虚拟主机环境中使用的“Host”、上传请求首部中的“Content-length”、快速区别真实用户和网络机器人的“User-agent”，以及代理环境中记录真实请求来源的“X-Forward-For”。 &lt;name&gt;：要捕获的首部的名称，此名称不区分字符大小写，但建议与它们出现在首部中的格式相同，比如大写首字母。需要注意的是，记录在日志中的是首部对应的值，而非首部名称。 &lt;length&gt;：指定记录首部值时所记录的精确长度，超出的部分将会被忽略。 可以捕获的请求首部的个数没有限制，但每个捕获最多只能记录64个字符。为了保证同一个frontend中日志格式的统一性，首部捕获仅能在frontend中定义。 capture response header1capture response header &lt;name&gt; len &lt;length&gt; 捕获并记录响应首部，其格式和要点同请求首部。 stats enable 启用基于程序编译时默认设置的统计报告，不能用于“frontend”区段。只要没有另外的其它设定，它们就会使用如下的配置： stats uri : /haproxy?stats stats realm : “HAProxy Statistics” stats auth : no authentication stats scope : no restriction 尽管“stats enable”一条就能够启用统计报告，但还是建议设定其它所有的参数，以免其依赖于默认设定而带来非期后果。下面是一个配置案例。 123456789backend public_www server websrv1 172.16.100.11:80 stats enable stats hide-version stats scope . stats uri /haproxyadmin?stats stats realm Haproxy\ Statistics stats auth statsadmin:password stats auth statsmaster:password stats hide-version1stats hide-version 启用统计报告并隐藏HAProxy版本报告，不能用于“frontend”区段。默认情况下，统计页面会显示一些有用信息，包括HAProxy的版本号，然而，向所有人公开HAProxy的精确版本号是非常有风险的，因为它能帮助恶意用户快速定位版本的缺陷和漏洞。尽管“stats hide-version”一条就能够启用统计报告，但还是建议设定其它所有的参数，以免其依赖于默认设定而带来非期后果。具体请参照“stats enable”一节的说明。 stats realm1stats realm &lt;realm&gt; 启用统计报告并高精认证领域，不能用于“frontend”区段。haproxy在读取realm时会将其视作一个单词，因此，中间的任何空白字符都必须使用反斜线进行转义。此参数仅在与“stats auth”配置使用时有意义。 &lt;realm&gt;：实现HTTP基本认证时显示在浏览器中的领域名称，用于提示用户输入一个用户名和密码。 尽管“stats realm”一条就能够启用统计报告，但还是建议设定其它所有的参数，以免其依赖于默认设定而带来非期后果。具体请参照“stats enable”一节的说明。 stats scope1stats scope &#123; &lt;name&gt; | "." &#125; 启用统计报告并限定报告的区段，不能用于“frontend”区段。当指定此语句时，统计报告将仅显示其列举出区段的报告信息，所有其它区段的信息将被隐藏。如果需要显示多个区段的统计报告，此语句可以定义多次。需要注意的是，区段名称检测仅仅是以字符串比较的方式进行，它不会真检测指定的区段是否真正存在。 &lt;name&gt;：可以是一个“listen”、“frontend”或“backend”区段的名称，而“.”则表示stats scope语句所定义的当前区段。 尽管“stats scope”一条就能够启用统计报告，但还是建议设定其它所有的参数，以免其依赖于默认设定而带来非期后果。下面是一个配置案例。 1234backend private_monitoring stats enable stats uri /haproxyadmin?stats stats refresh 10s stats auth1stats auth &lt;user&gt;:&lt;passwd&gt; 启用带认证的统计报告功能并授权一个用户帐号，其不能用于“frontend”区段。 &lt;user&gt;：授权进行访问的用户名； &lt;passwd&gt;：此用户的访问密码，明文格式； 此语句将基于默认设定启用统计报告功能，并仅允许其定义的用户访问，其也可以定义多次以授权多个用户帐号。可以结合“stats realm”参数在提示用户认证时给出一个领域说明信息。在使用非法用户访问统计功能时，其将会响应一个“401 Forbidden”页面。其认证方式为HTTP Basic认证，密码传输会以明文方式进行，因此，配置文件中也使用明文方式存储以说明其非保密信息故此不能相同于其它关键性帐号的密码。 尽管“stats auth”一条就能够启用统计报告，但还是建议设定其它所有的参数，以免其依赖于默认设定而带来非期后果。 stats admin1stats admin &#123; if | unless &#125; &lt;cond&gt; 在指定的条件满足时启用统计报告页面的管理级别功能，它允许通过web接口启用或禁用服务器，不过，基于安全的角度考虑，统计报告页面应该尽可能为只读的。此外，如果启用了HAProxy的多进程模式，启用此管理级别将有可能导致异常行为。 目前来说，POST请求方法被限制于仅能使用缓冲区减去保留部分之外的空间，因此，服务器列表不能过长，否则，此请求将无法正常工作。因此，建议一次仅调整少数几个服务器。下面是两个案例，第一个限制了仅能在本机打开报告页面时启用管理级别功能，第二个定义了仅允许通过认证的用户使用管理级别功能。 12345678backend stats_localhost stats enable stats admin if LOCALHOSTbackend stats_auth stats enable stats auth haproxyadmin:password stats admin if TRUE option httplog1option httplog [ clf ] 启用记录HTTP请求、会话状态和计时器的功能。 clf：使用CLF格式来代替HAProxy默认的HTTP格式，通常在使用仅支持CLF格式的特定日志分析器时才需要使用此格式。 默认情况下，日志输入格式非常简陋，因为其仅包括源地址、目标地址和实例名称，而“option httplog”参数将会使得日志格式变得丰富许多，其通常包括但不限于HTTP请求、连接计时器、会话状态、连接数、捕获的首部及cookie、“frontend”、“backend”及服务器名称，当然也包括源地址和端口号等。 option logasap12option logasapno option logasap 启用或禁用提前将HTTP请求记入日志，不能用于“backend”区段。 默认情况下，HTTP请求是在请求结束时进行记录以便能将其整体传输时长和字节数记入日志，由此，传较大的对象时，其记入日志的时长可能会略有延迟。“option logasap”参数能够在服务器发送complete首部时即时记录日志，只不过，此时将不记录整体传输时长和字节数。此情形下，捕获“Content-Length”响应首部来记录传输的字节数是一个较好选择。下面是一个例子。 12345listen http_proxy 0.0.0.0:80 mode http option httplog option logasap log 172.16.100.9 local2 option forwardfor1option forwardfor [ except &lt;network&gt; ] [ header &lt;name&gt; ] [ if-none ] 允许在发往服务器的请求首部中插入“X-Forwarded-For”首部。 &lt;network&gt;：可选参数，当指定时，源地址为匹配至此网络中的请求都禁用此功能。 &lt;name&gt;：可选参数，可使用一个自定义的首部，如“X-Client”来替代“X-Forwarded-For”。有些独特的web服务器的确需要用于一个独特的首部。 if-none：仅在此首部不存在时才将其添加至请求报文问道中。 HAProxy工作于反向代理模式，其发往服务器的请求中的客户端IP均为HAProxy主机的地址而非真正客户端的地址，这会使得服务器端的日志信息记录不了真正的请求来源，“X-Forwarded-For”首部则可用于解决此问题。HAProxy可以向每个发往服务器的请求上添加此首部，并以客户端IP为其value。 需要注意的是，HAProxy工作于隧道模式，其仅检查每一个连接的第一个请求，因此，仅第一个请求报文被附加此首部。如果想为每一个请求都附加此首部，请确保同时使用了“option httpclose”、“option forceclose”和“option http-server-close”几个option。 -下面是一个例子。 123frontend www mode http option forwardfor except 127.0.0.1 errorfile1errorfile &lt;code&gt; &lt;file&gt; 在用户请求不存在的页面时，返回一个页面文件给客户端而非由haproxy生成的错误代码；可用于所有段中。 &lt;code&gt;：指定对HTTP的哪些状态码返回指定的页面；这里可用的状态码有200、400、403、408、500、502、503和504； &lt;file&gt;：指定用于响应的页面文件； 例如： 123errorfile 400 /etc/haproxy/errorpages/400badreq.httperrorfile 403 /etc/haproxy/errorpages/403forbid.httperrorfile 503 /etc/haproxy/errorpages/503sorry.http errorloc 和 errorloc30212errorloc &lt;code&gt; &lt;url&gt;errorloc302 &lt;code&gt; &lt;url&gt; 请求错误时，返回一个HTTP重定向至某URL的信息；可用于所有配置段中。 &lt;code&gt;：指定对HTTP的哪些状态码返回指定的页面；这里可用的状态码有200、400、403、408、500、502、503和504； &lt;url&gt;：Location首部中指定的页面位置的具体路径，可以是在当前服务器上的页面的相对路径，也可以使用绝对路径；需要注意的是，如果URI自身错误时产生某特定状态码信息的话，有可能会导致循环定向； 需要留意的是，这两个关键字都会返回302状态吗，这将使得客户端使用同样的HTTP方法获取指定的URL，对于非GET法的场景(如POST)来说会产生问题，因为返回客户的URL是不允许使用GET以外的其它方法的。如果的确有这种问题，可以使用errorloc303来返回303状态码给客户端。 errorloc3031errorloc303 &lt;code&gt; &lt;url&gt; 请求错误时，返回一个HTTP重定向至某URL的信息给客户端；可用于所有配置段中。 &lt;code&gt;：指定对HTTP的哪些状态码返回指定的页面；这里可用的状态码有400、403、408、500、502、503和504； &lt;url&gt;：Location首部中指定的页面位置的具体路径，可以是在当前服务器上的页面的相对路径，也可以使用绝对路径；需要注意的是，如果URI自身错误时产生某特定状态码信息的话，有可能会导致循环定向； 例如： 12345backend webserver server 172.16.100.6 172.16.100.6:80 check maxconn 3000 cookie srv01 server 172.16.100.7 172.16.100.7:80 check maxconn 3000 cookie srv02 errorloc 403 /etc/haproxy/errorpages/sorry.htm errorloc 503 /etc/haproxy/errorpages/sorry.htm 配置案例http服务器配置示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#---------------------------------------------------------------------# Global settings#---------------------------------------------------------------------global # to have these messages end up in /var/log/haproxy.log you will # need to: # # 1) configure syslog to accept network log events. This is done # by adding the '-r' option to the SYSLOGD_OPTIONS in # /etc/sysconfig/syslog # # 2) configure local2 events to go to the /var/log/haproxy.log # file. A line like the following can be added to # /etc/sysconfig/syslog # # local2.* /var/log/haproxy.log # log 127.0.0.1 local2 chroot /var/lib/haproxy pidfile /var/run/haproxy.pid maxconn 4000 user haproxy group haproxy daemondefaults mode http log global option httplog option dontlognull option http-server-close option forwardfor except 127.0.0.0/8 option redispatch retries 3 timeout http-request 10s timeout queue 1m timeout connect 10s timeout client 1m timeout server 1m timeout http-keep-alive 10s timeout check 10s maxconn 30000listen stats mode http bind 0.0.0.0:1080 stats enable stats hide-version stats uri /haproxyadmin?stats stats realm Haproxy\ Statistics stats auth admin:admin stats admin if TRUEfrontend http-in bind *:80 mode http log global option httpclose option logasap option dontlognull capture request header Host len 20 capture request header Referer len 60 default_backend serversfrontend healthcheck bind :1099 mode http option httpclose option forwardfor default_backend serversbackend servers balance roundrobin server websrv1 192.168.10.11:80 check maxconn 2000 server websrv2 192.168.10.12:80 check maxconn 2000 负载均衡MySQL服务的配置示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#---------------------------------------------------------------------# Global settings#---------------------------------------------------------------------global # to have these messages end up in /var/log/haproxy.log you will # need to: # # 1) configure syslog to accept network log events. This is done # by adding the '-r' option to the SYSLOGD_OPTIONS in # /etc/sysconfig/syslog # # 2) configure local2 events to go to the /var/log/haproxy.log # file. A line like the following can be added to # /etc/sysconfig/syslog # # local2.* /var/log/haproxy.log # log 127.0.0.1 local2 chroot /var/lib/haproxy pidfile /var/run/haproxy.pid maxconn 4000 user haproxy group haproxy daemondefaults mode tcp log global option httplog option dontlognull retries 3 timeout http-request 10s timeout queue 1m timeout connect 10s timeout client 1m timeout server 1m timeout http-keep-alive 10s timeout check 10s maxconn 600listen stats mode http bind 0.0.0.0:1080 stats enable stats hide-version stats uri /haproxyadmin?stats stats realm Haproxy\ Statistics stats auth admin:admin stats admin if TRUEfrontend mysql bind *:3306 mode tcp log global default_backend mysqlserversbackend mysqlservers balance leastconn server dbsrv1 192.168.10.11:3306 check port 3306 intval 2 rise 1 fall 2 maxconn 300 server dbsrv2 192.168.10.12:3306 check port 3306 intval 2 rise 1 fall 2 maxconn 300 ACL基本说明haproxy的ACL用于实现基于请求报文的首部、响应报文的内容或其它的环境状态信息来做出转发决策，这大大增强了其配置弹性。其配置法则通常分为两步，首先去定义ACL，即定义一个测试条件，而后在条件得到满足时执行某特定的动作，如阻止请求或转发至某特定的后端。定义ACL的语法格式如下。 1acl &lt;aclname&gt; &lt;criterion&gt; [flags] [operator] &lt;value&gt; ... &lt;aclname&gt;：ACL名称，区分字符大小写，且其只能包含大小写字母、数字、-(连接线)、_(下划线)、.(点号)和:(冒号)；haproxy中，acl可以重名，这可以把多个测试条件定义为一个共同的acl； &lt;criterion&gt;：测试标准，即对什么信息发起测试；测试方式可以由[flags]指定的标志进行调整；而有些测试标准也可以需要为其在之前指定一个操作符[operator]； [flags]：目前haproxy的acl支持的标志位有3个： -i：不区分中模式字符的大小写； -f：从指定的文件中加载模式； --：标志符的强制结束标记，在模式中的字符串像标记符时使用； &lt;value&gt;：acl测试条件支持的值有以下四类： 整数或整数范围：如1024:65535表示从1024至65535；仅支持使用正整数(如果出现类似小数的标识，其为通常为版本测试)，且支持使用的操作符有5个，分别为eq、ge、gt、le和lt； 字符串：支持使用“-i”以忽略字符大小写，支持使用“\”进行转义；如果在模式首部出现了-i，可以在其之前使用“–”标志位； 正则表达式：其机制类同字符串匹配； IP地址及网络地址 同一个acl中可以指定多个测试条件，这些测试条件需要由逻辑操作符指定其关系。条件间的组合测试关系有三种：“与”(默认即为与操作)、“或”(使用“||”操作符)以及“非”(使用“!”操作符)。 常用的测试标准(criteria)be_sess_rate1be_sess_rate(backend) &lt;integer&gt; 用于测试指定的backend上会话创建的速率(即每秒创建的会话数)是否满足指定的条件；常用于在指定backend上的会话速率过高时将用户请求转发至另外的backend，或用于阻止攻击行为。例如： 1234backend dynamic mode http acl being_scanned be_sess_rate gt 50 redirect location /error_pages/denied.html if being_scanned fe_sess_rate1fe_sess_rate(frontend) &lt;integer&gt; 用于测试指定的frontend(或当前frontend)上的会话创建速率是否满足指定的条件；常用于为frontend指定一个合理的会话创建速率的上限以防止服务被滥用。例如下面的例子限定入站邮件速率不能大于50封/秒，所有在此指定范围之外的请求都将被延时50毫秒。 12345678frontend mail bind :25 mode tcp maxconn 500 acl too_fast fe_sess_rate ge 50 tcp-request inspect-delay 50ms tcp-request content accept if ! too_fast tcp-request content accept if WAIT_END hdr1hdr(header) &lt;string&gt; 用于测试请求报文中的所有首部或指定首部是否满足指定的条件；指定首部时，其名称不区分大小写，且在括号“()”中不能有任何多余的空白字符。测试服务器端的响应报文时可以使用shdr()。例如下面的例子用于测试首部Connection的值是否为close。 1hdr(Connection) -i close method1method &lt;string&gt; 测试HTTP请求报文中使用的方法。 path_beg1path_beg &lt;string&gt; 用于测试请求的URL是否以指定的模式开头。下面的例子用于测试URL是否以/static、/images、/javascript或/stylesheets头。 1acl url_static path_beg -i /static /images /javascript /stylesheets path_end1path_end &lt;string&gt; 用于测试请求的URL是否以指定的模式结尾。例如，下面的例子用户测试URL是否以jpg、gif、png、css或js结尾。 1acl url_static path_end -i .jpg .gif .png .css .js hdr_beg1hdr_beg &lt;string&gt; 用于测试请求报文的指定首部的开头部分是否符合指定的模式。例如，下面的例子用记测试请求是否为提供静态内容的主机img、video、download或ftp。 1acl host_static hdr_beg(host) -i img. video. download. ftp. hdr_end1hdr_end &lt;string&gt; 用于测试请求报文的指定首部的结尾部分是否符合指定的模式。例如，下面的例子用记测试请求是否为动静分离示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667global log 127.0.0.1 local2 chroot /var/lib/haproxy pidfile /var/run/haproxy.pid maxconn 4000 user haproxy group haproxy daemon # turn on stats unix socket stats socket /var/lib/haproxy/statsdefaults mode http log global option httplog option dontlognull option http-server-close option forwardfor except 127.0.0.0/8 option redispatch retries 3 timeout http-request 10s timeout queue 1m timeout connect 10s timeout client 1m timeout server 1m timeout http-keep-alive 10s timeout check 10s maxconn 30000listen stats mode http bind 0.0.0.0:1080 stats enable stats hide-version stats uri /haproxyadmin?stats stats realm Haproxy\ Statistics stats auth admin:admin stats admin if TRUEfrontend http-in bind *:80 mode http log global option httpclose option logasap option dontlognull capture request header Host len 20 capture request header Referer len 60 acl url_static path_beg -i /static /images /javascript /stylesheets acl url_static path_end -i .jpg .jpeg .gif .png .css .js use_backend static_servers if url_static default_backend dynamic_serversbackend static_servers balance roundrobin server imgsrv1 172.16.200.7:80 check maxconn 6000 server imgsrv2 172.16.200.8:80 check maxconn 6000backend dynamic_servers balance source server websrv1 172.16.200.7:80 check maxconn 1000 server websrv2 172.16.200.8:80 check maxconn 1000 server websrv3 172.16.200.9:80 check maxconn 1000]]></content>
      <categories>
        <category>Haproxy</category>
      </categories>
      <tags>
        <tag>Haproxy</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Haproxy配置实现Web负载均衡]]></title>
    <url>%2F2017%2F12%2F03%2F2017-12-03-082510-Haproxy%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0Web%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[环境说明Haproxy hostname：Haproxy 运行服务：Haproxy IP地址 eth0 : 192.168.127.130/24 brd 192.168.127.255 eth1 : 172.20.35.21/22 brd 172.20.35.255 web1 hostname：web1 运行服务：Apache-httpd IP地址 eth0 : 192.168.127.133/24 brd 192.168.127.255 网关指向Haproxy服务器 =&gt; 192.168.127.130 web2 hostname：web2 运行服务：Apache-httpd IP地址 eth1 : 192.168.127.134/24 brd 192.168.127.255 网关指向Haproxy服务器 =&gt; 192.168.127.130 基本配置以上三台服务器需要做相同的配置 192.168.127这个段在虚拟机选择NAT模式 保持时间同步 1ntpdate time.nist.gov 防火墙等配置禁用，可使用如下命令一键配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# Disable IPv6 networkFile="/etc/sysconfig/network"confList=(NETWORKING_IPV6=no NOZEROCONF=yes)for var in $&#123;confList[@]&#125;;do if egrep -qs "$&#123;var%%=*&#125;=" $&#123;networkFile&#125;;then sed -ri "s#($&#123;var%%=*&#125;=).*#\1$&#123;var##*=&#125;#" $&#123;networkFile&#125; else echo "$&#123;var&#125;" &gt;&gt; $&#123;networkFile&#125; fidonesed -ri '/(net.ipv6.conf.all.disable_ipv6|net.ipv6.conf.default.disable_ipv6) *= */d' /etc/sysctl.confecho 'net.ipv6.conf.all.disable_ipv6 = 1' &gt;&gt; /etc/sysctl.confecho 'net.ipv6.conf.default.disable_ipv6 = 1' &gt;&gt; /etc/sysctl.conf sysctl -p# Set languagelangfile='/etc/locale.conf'export LANG="en_US.UTF-8";sed -ri '/LANG/s/=.*/="en_US.UTF-8"/' $&#123;langfile&#125;# Turn off selinuxsetenforce 0fileList=(/etc/sysconfig/selinux /etc/selinux/config)for f in $&#123;fileList[@]&#125;;do sed -ri 's/(^SELINUX=).*/\1disabled/' $&#123;f&#125;done# Disable the DNS function of sshdegrep -q '^UseDNS no' /etc/ssh/sshd_config || \sed -ri '/#UseDNS /aUseDNS no' /etc/ssh/sshd_config# Turn off some services/usr/bin/systemctl stop firewalld.service;/usr/bin/systemctl disable firewalld.service;/usr/bin/systemctl is-enabled firewalld.service;# Add firewall policyIPT='/sbin/iptables'# ---------------------------------------for chain in INPUT OUTPUT FORWARD;do $&#123;IPT&#125; -t filter -P $&#123;chain&#125; ACCEPT &amp;&gt;/dev/nulldoneunset chain# ---------------------------------------for chain in PREROUTING POSTROUTING OUTPUT;do $&#123;IPT&#125; -t nat -P $&#123;chain&#125; ACCEPT &amp;&gt;/dev/nulldoneunset chain# ---------------------------------------for chain in PREROUTING INPUT FORWARD OUTPUT POSTROUTING;do $&#123;IPT&#125; -t mangle -P $&#123;chain&#125; ACCEPT &amp;&gt;/dev/nulldoneunset chain# ---------------------------------------for table in filter nat mangle;do $&#123;IPT&#125; -F -t $&#123;table&#125; &amp;&gt;/dev/null $&#123;IPT&#125; -X -t $&#123;table&#125; &amp;&gt;/dev/nulldone 配置web1 网关配置 12ip route add default via 192.168.127.130 dev eth0 &amp;&gt;/dev/nullip route change default via 192.168.127.130 dev eth0 &amp;&gt;/dev/null web和静态页面的配置 1234567891011yum -y install httpd php php-mysql # 安装Apache及phpsystemctl enable httpd# 加入开机启动服务echo '&lt;h1&gt;web1.test.com&lt;/h1&gt;' &gt;&gt; /var/www/html/index.html# 创建静态页面systemctl start httpd # 启动httpd服务 web2 网关配置 12ip route add default via 192.168.127.130 dev eth0 &amp;&gt;/dev/nullip route change default via 192.168.127.130 dev eth0 &amp;&gt;/dev/null web和静态页面的配置 1234567891011yum -y install httpd php php-mysql # 安装Apache及phpsystemctl enable httpd# 加入开机启动服务echo '&lt;h1&gt;web2.test.com&lt;/h1&gt;' &gt;&gt; /var/www/html/index.html# 创建静态页面systemctl start httpd # 启动httpd服务 haproxy12cp /etc/haproxy/haproxy.cfg&#123;,.bak&#125;# 配置文件备份 配置说明 Global settings ：这是第一部分的配置，全局配置；对Haproxy进程自身属性的设定 proxys：对代理的设定，通常有4部分组成 defaults：提供默认配置 frontend：前端配置 backend：后端配置 listen：从某种意义上讲可以认为是将frontend和backend整合到一块的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#---------------------------------------------------------------------# Example configuration for a possible web application. See the# full configuration options online.## http://haproxy.1wt.eu/download/1.4/doc/configuration.txt##---------------------------------------------------------------------#---------------------------------------------------------------------# Global settings#---------------------------------------------------------------------global # to have these messages end up in /var/log/haproxy.log you will # need to: # # 1) configure syslog to accept network log events. This is done # by adding the '-r' option to the SYSLOGD_OPTIONS in # /etc/sysconfig/syslog # # 2) configure local2 events to go to the /var/log/haproxy.log # file. A line like the following can be added to # /etc/sysconfig/syslog # # local2.* /var/log/haproxy.log # log 127.0.0.1 local2 chroot /var/lib/haproxy pidfile /var/run/haproxy.pid maxconn 4000 user nobody group nobody daemon # turn on stats unix socket stats socket /var/lib/haproxy/stats#---------------------------------------------------------------------# common defaults that all the 'listen' and 'backend' sections will# use if not designated in their block#---------------------------------------------------------------------defaults mode http log global option httplog option dontlognull option http-server-close option forwardfor except 127.0.0.0/8 option redispatch retries 3 timeout http-request 10s timeout queue 1m timeout connect 10s timeout client 1m timeout server 1m timeout http-keep-alive 10s timeout check 10s maxconn 3000frontend web_proxy bind 192.168.127.130:80 default_backend webserversbackend webservers balance roundrobin server web1 192.168.127.133:80 check server web2 192.168.127.134:80 check 测试 配置文件配置无误之后启动haproxy服务 在浏览器访问Haproxy的监听地址多次刷新则可看到负载均衡的效果 Haproxy监控页面12345678910listen stats #关联前端和后端定义一个完整的代理 mode http #设置代理协议 bind 0.0.0.0:1080 #绑定相应的端口 stats enable #开启Haproxy统计状态 stats refresh 3s #统计页面自动刷新时间间隔 stats hide-version #隐藏代理服务器版本 stats uri /haproxyadmin?stats #访问的url stats realm Haproxy\ Statistics #统计页面认证时提示内容信息 stats auth admin:123456 #设置登录用户和密码 stats admin if TRUE #如果认证通过，则就可以打开stats 加入配置，重启服务后访问http://192.168.127.130:1080//haproxyadmin?stats]]></content>
      <categories>
        <category>Haproxy</category>
      </categories>
      <tags>
        <tag>Haproxy</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Haproxy编译安装]]></title>
    <url>%2F2017%2F12%2F02%2F2017-12-02-140410-Haproxy%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[版本信息： 系统：CentOS Linux release 7.4.1708 (Core) 内核：4.14.8-1.el7.elrepo.x86_64 并启用了bbr算法 Haproxy：haproxy-1.7.9 Tips： CentOS 自6.4开始系统自带Haproxy 解决依赖关系1yum -y install openssl openssl-devel 获取源码包 官网： http://www.haproxy.org 下载链接：http://www.haproxy.org/download/1.7/src/haproxy-1.7.9.tar.gz 12cd ~wget http://www.haproxy.org/download/1.7/src/haproxy-1.7.9.tar.gz 解压12tar xf haproxy-1.7.9.tar.gz -C /usr/local/src/cd /usr/local/src/haproxy-1.7.9/ 获取帮助12cd /usr/local/src/haproxy-1.7.9/cat README 编译安装 根据README帮助说明，结合实际需要进行make 其中TARGET参考README，ARCH需要使用arch或uname 来查看 123456789101112131415161718make TARGET=linux2628 USE_OPENSSL=1 ARCH=x86_64 PREFIX=/opt/haproxymake install PREFIX=/opt/haproxy# 编译安装install -d /usr/sbin install haproxy /usr/sbininstall haproxy-systemd-wrapper /usr/sbin# 将make好的haproxy拷贝到指定目录install -d /usr/local/share/man/man1 install -m 644 doc/haproxy.1 /usr/local/share/man/man1 # 生成man文档cp -ar /opt/haproxy/doc/haproxy /usr/local/doc/haproxy# 生成docmkdir -pv /var/lib/haproxy# 这个目录是Haproxy配置中chroot要用到的配置 程序测试1haproxy 出现如下信息则编译安装成功 123456789101112131415161718192021222324HA-Proxy version 1.7.9 2017/08/18Copyright 2000-2017 Willy Tarreau &lt;willy@haproxy.org&gt;Usage : haproxy [-f &lt;cfgfile|cfgdir&gt;]* [ -vdVD ] [ -n &lt;maxconn&gt; ] [ -N &lt;maxpconn&gt; ] [ -p &lt;pidfile&gt; ] [ -m &lt;max megs&gt; ] [ -C &lt;dir&gt; ] [-- &lt;cfgfile&gt;*] -v displays version ; -vv shows known build options. -d enters debug mode ; -db only disables background mode. -dM[&lt;byte&gt;] poisons memory with &lt;byte&gt; (defaults to 0x50) -V enters verbose mode (disables quiet mode) -D goes daemon ; -C changes to &lt;dir&gt; before loading files. -q quiet mode : don&apos;t display messages -c check mode : only check config files and exit -n sets the maximum total # of connections (2000) -m limits the usable amount of memory (in MB) -N sets the default, per-proxy maximum # of connections (2000) -L set local peer name (default to hostname) -p writes pids of all children to this file -de disables epoll() usage even when available -dp disables poll() usage even when available -dS disables splice usage (broken on old kernels) -dR disables SO_REUSEPORT usage -dr ignores server address resolution failures -dV disables SSL verify on servers side -sf/-st [pid ]* finishes/terminates old pids. 文件说明1234567891011121314151617181920212223242526/opt/haproxy/├── doc # 文档存放目录│ └── haproxy│ ├── 51Degrees-device-detection.txt│ ├── architecture.txt│ ├── close-options.txt│ ├── configuration.txt│ ├── cookie-options.txt│ ├── DeviceAtlas-device-detection.txt│ ├── intro.txt│ ├── linux-syn-cookies.txt│ ├── lua.txt│ ├── management.txt│ ├── netscaler-client-ip-insertion-protocol.txt│ ├── network-namespaces.txt│ ├── proxy-protocol.txt│ ├── SPOE.txt│ └── WURFL-device-detection.txt├── sbin # 编译好的二进制程序│ └── haproxy└── share # man文档 └── man └── man1 └── haproxy.16 directories, 17 files 环境与配置 编译好的二进制程序可移植到其他机器上执行 在编译后的源码包目录下的examples目录下有一些可供参考的init脚本、配置文件、vim配置等 创建主配置文件/etc/haproxyhaproxy.cfg，沿用旧版本的配置模板 12mkdir /etc/haproxy/vim /etc/haproxy/haproxy.cfg 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#---------------------------------------------------------------------# Example configuration for a possible web application. See the# full configuration options online.## http://haproxy.1wt.eu/download/1.4/doc/configuration.txt##---------------------------------------------------------------------#---------------------------------------------------------------------# Global settings#---------------------------------------------------------------------global # to have these messages end up in /var/log/haproxy.log you will # need to: # # 1) configure syslog to accept network log events. This is done # by adding the '-r' option to the SYSLOGD_OPTIONS in # /etc/sysconfig/syslog # # 2) configure local2 events to go to the /var/log/haproxy.log # file. A line like the following can be added to # /etc/sysconfig/syslog # # local2.* /var/log/haproxy.log # log 127.0.0.1 local2 chroot /var/lib/haproxy # 这个目录需要手动创建 pidfile /var/run/haproxy.pid maxconn 4000 user nobody group nobody # 用户和组使用nobody，省去创建系统用户 daemon # turn on stats unix socket stats socket /var/lib/haproxy/stats#---------------------------------------------------------------------# common defaults that all the 'listen' and 'backend' sections will# use if not designated in their block#---------------------------------------------------------------------defaults mode http log global option httplog option dontlognull option http-server-close option forwardfor except 127.0.0.0/8 option redispatch retries 3 timeout http-request 10s timeout queue 1m timeout connect 10s timeout client 1m timeout server 1m timeout http-keep-alive 10s timeout check 10s maxconn 3000#---------------------------------------------------------------------# main frontend which proxys to the backends#---------------------------------------------------------------------frontend main *:5000 acl url_static path_beg -i /static /images /javascript /stylesheets acl url_static path_end -i .jpg .gif .png .css .js use_backend static if url_static default_backend app#---------------------------------------------------------------------# static backend for serving up images, stylesheets and such#---------------------------------------------------------------------backend static balance roundrobin server static 127.0.0.1:4331 check#---------------------------------------------------------------------# round robin balancing between the various backends#---------------------------------------------------------------------backend app balance roundrobin server app1 127.0.0.1:5001 check server app2 127.0.0.1:5002 check server app3 127.0.0.1:5003 check server app4 127.0.0.1:5004 check 服务控制 CentOS 7系列可以使用systemd的方式来管理服务 为了管理更灵活，我们选择使用控制脚本，而不是systemd，这里只是提供一个systemd范例 如果生产环境没有特殊要求则可以直接使用这种控制方式 文件/usr/lib/systemd/system/haproxy.service 123456789101112[Unit]Description=HAProxy Load BalancerAfter=syslog.target network.target[Service]EnvironmentFile=/etc/sysconfig/haproxyExecStart=/usr/sbin/haproxy-systemd-wrapper -f /etc/haproxy/haproxy.cfg -p /run/haproxy.pid $OPTIONSExecReload=/bin/kill -USR2 $MAINPIDKillMode=mixed[Install]WantedBy=multi-user.target 因为生产环境需要，可能需要监听私网地址并做相应的地址转换，因此使用init形式的服务控制脚本 这个脚本基于官方的服务脚本做了二次修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#!/bin/bash## chkconfig: - 85 15# description: HA-Proxy is a TCP/HTTP reverse proxy which is particularly suited \# for high availability environments.# processname: haproxy# config: /etc/haproxy/haproxy.cfg# pidfile: /var/run/haproxy.pid# Script Author: Simon Matter &lt;simon.matter@invoca.ch&gt;# Version: 2004060600# Source function library.if [ -f /etc/init.d/functions ]; then . /etc/init.d/functionselif [ -f /etc/rc.d/init.d/functions ] ; then . /etc/rc.d/init.d/functionselse exit 0fi# Source networking configuration.. /etc/sysconfig/network# Check that networking is up.[ "$&#123;NETWORKING&#125;" = "no" ] &amp;&amp; exit 0# This is the path of our programEXEC='/usr/sbin/haproxy'if test -e $&#123;EXEC&#125;;then if test -s $&#123;EXEC&#125;;then if test ! -x $&#123;EXEC&#125;;then echo "$&#123;EXEC&#125; : Permission denied" exit 1 fi else echo "$&#123;EXEC&#125; : Can not run the empty binary file" exit 1 fielse echo "$&#123;EXEC&#125; : No such file or directory" exit 1fi# This is our service nameprog=$(basename $EXEC)# This is the path of configuration filecfgfile=/etc/haproxy/haproxy.cfg[ -f $&#123;cfgfile&#125; ] || &#123; echo "Cannot load $&#123;cfgfile&#125;: No such file or directory" exit 1&#125;pidfile=/var/run/$&#123;prog&#125;.pidlockfile=/var/lock/subsys/$&#123;prog&#125;RETVAL=0check() &#123; $&#123;EXEC&#125; -c -q -V -f $&#123;cfgfile&#125; $&#123;OPTIONS&#125;&#125;quiet_check() &#123; $&#123;EXEC&#125; -c -q -f $&#123;cfgfile&#125; $&#123;OPTIONS&#125; if [ $? -ne 0 ]; then echo "Errors found in configuration file, check it with '$&#123;prog&#125; check'." exit 1 fi&#125;start() &#123; quiet_check rh_status_q &amp;&amp; &#123; echo -n "Starting $&#123;prog&#125;: " echo_failure echo echo $"Cannot start $&#123;prog&#125;: $&#123;prog&#125; is already running . "; exit 0 &#125; echo -n "Starting $&#123;prog&#125;: " # start it up here, usually something like "daemon $exec" daemon $&#123;EXEC&#125; -D -f $&#123;cfgfile&#125; -p $&#123;pidfile&#125; RETVAL=$? echo [ $&#123;RETVAL&#125; -eq 0 ] &amp;&amp; touch $&#123;lockfile&#125; return $&#123;RETVAL&#125;&#125;stop() &#123; rh_status_q || &#123; echo -n "Stopping $&#123;prog&#125;: " echo_failure echo echo $"Cannot stop $&#123;prog&#125;: $&#123;prog&#125; is not running . "; return 0 &#125; echo -n "Stopping $&#123;prog&#125;: " # stop it here, often "killproc $prog" killproc $&#123;prog&#125; -USR1 RETVAL=$? echo [ $&#123;RETVAL&#125; -eq 0 ] &amp;&amp; &#123; rm -f $&#123;lockfile&#125; $&#123;pidfile&#125; &#125; return $&#123;RETVAL&#125;&#125;restart() &#123; quiet_check stop start&#125;reload() &#123; quiet_check test -s $&#123;pidfile&#125; || &#123; echo -n "Reloading $&#123;prog&#125;: " echo_failure echo echo $"Cannot reload $&#123;prog&#125;: $&#123;prog&#125; is not running . "; return 1 &#125; echo -n "Reloading $&#123;prog&#125;: " $&#123;EXEC&#125; -D -f $&#123;cfgfile&#125; -p $&#123;pidfile&#125; -sf $(cat $&#123;pidfile&#125;) RETVAL=$? [ $&#123;RETVAL&#125; -eq 0 ] &amp;&amp; echo_success || echo_failure echo return $&#123;RETVAL&#125;&#125;rh_status() &#123; status $&#123;prog&#125;&#125;rh_status_q() &#123; rh_status &gt;/dev/null 2&gt;&amp;1&#125;condrestart() &#123; [ -e $&#123;lockfile&#125; ] &amp;&amp; restart || :&#125;# See how we were called.case "$1" in start|stop|restart|reload|check|condrestart) $1 ;; status) rh_status ;; *) echo echo -e $"\tUsage: $&#123;prog&#125; &#123; check | start | stop | restart | reload | condrestart | status &#125;" echo exit 1 ;;esac exit $? 开启日志记录自己记录日志1local2.* /var/log/haproxy.log 交给日志服务器记录日志 配置/etc/haproxy/haproxy.cfg 1log 127.0.0.1 local2 开启rsyslog记录haproxy日志功能，编辑/etc/rsyslog.conf找到如下配置项 去掉配置项的注释 123# Provides UDP syslog reception$ModLoad imudp$UDPServerRun 514 添加如下内容 12# Save haproxy log local2.* /var/log/haproxy.log 配置/etc/sysconfig/rsyslog 相关解释说明: -r: 打开接受外来日志消息的功能,其监控514 UDP端口; -x: 关闭自动解析对方日志服务器的FQDN信息,这能避免DNS不完整所带来的麻烦; -m: 修改syslog的内部mark消息写入间隔时间(0为关闭),例如240为每隔240分钟写入一次”–MARK–”信息; -h: 默认情况下,syslog不会发送从远端接受过来的消息到其他主机,而使用该选项,则把该开关打开,所有接受到的信息都可根据syslog.conf中定义的@主机转发过去. 12345# Options for rsyslogd# Syslogd options are deprecated since rsyslog v3.# If you want to use them, switch to compatibility mode 2 by "-c 2"# See rsyslogd(8) for more detailsSYSLOGD_OPTIONS="-r -m 0" 重启服务 1234service rsyslog restarthaproxy_ctl.sh restart# 这个是自己改好的服务控制脚本 查看日志 1tailf /var/log/haproxy/haproxy.log]]></content>
      <categories>
        <category>Haproxy</category>
      </categories>
      <tags>
        <tag>Haproxy</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Haproxy简介]]></title>
    <url>%2F2017%2F12%2F01%2F2017-12-01-213710-Haproxy%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[简介 Haproxy提供高可用性、负载均衡以及基于TCP和HTTP应用的代理，支持http的虚拟主机，它是免费、快速并且可靠的一种解决方案。HAProxy特别适用于那些负载特大的web站点，这些站点通常又需要会话保持或七层处理HAProxy运行在时下的硬件上，完全可以支持数以万计的并发连接。并且它的运行模式使得它可以很简单安全的整合进您当前的架构中， 同时可以保护你的web服务器不被暴露到网络上。 HAProxy实现了一种==事件驱动==、单一进程模型此模型支持非常大的并发连接数。多进程或多线程模型受内存限制 、系统调度器限制以及无处不在的锁限制，很少能处理数千并发连接。事件驱动模型因为在有更好的资源和时间管理的用户端(User-Space) 实现所有这些任务，所以没有这些问题。此模型的弊端是，在多核系统上，这些程序通常扩展性较差。这就是为什么他们必须进行优化以 使每个CPU时间片(Cycle)做更多的工作。 HAProxy 支持连接拒绝 : 因为维护一个连接的打开的开销是很低的，有时我们很需要限制攻击蠕虫（attack bots），也就是说限制它们的连接打开从而限制它们的危害。 这个已经为一个陷于小型DDoS攻击的网站开发了而且已经拯救了很多站点，这个优点也是其它负载均衡器没有的。 HAProxy 支持全透明代理（已具备硬件防火墙的典型特点）: 可以用客户端IP地址或者任何其他地址来连接后端服务器. 这个特性仅在Linux 2.4/2.6内核打了cttproxy补丁后才可以使用. 这个特性也使得为某特殊服务器处理部分流量同时又不修改服务器的地址成为可能。 主要版本1.4 ——提供较好的弹性：衍生于1.2版本，并提供了额外的新特性，其中大多数是期待已久的。 客户端侧的长连接(client-side keep-alive) TCP加速(TCP speedups) 响应池(response buffering) RDP协议 基于源的粘性(source-based stickiness) 更好的统计数据接口(a much better stats interfaces) 更详细的健康状态检测机制(more verbose health checks) 基于流量的健康评估机制(traffic-based health) 支持HTTP认证 服务器管理命令行接口(server management from the CLI) 基于ACL的持久性(ACL-based persistence) 日志分析器 1.3 ——内容交换和超强负载：衍生于1.2版本，并提供了额外的新特性。 内容交换(content switching)：基于任何请求标准挑选服务器池； ACL：编写内容交换规则； 负载均衡算法(load-balancing algorithms)：更多的算法支持； 内容探测(content inspection)：阻止非授权协议； 透明代理(transparent proxy)：在Linux系统上允许使用客户端IP直接连入服务器； 内核TCP拼接(kernel TCP splicing)：无copy方式在客户端和服务端之间转发数据以实现数G级别的数据速率； 分层设计(layered design)：分别实现套接字、TCP、HTTP处理以提供更好的健壮性、更快的处理机制及便捷的演进能力； 快速、公平调度器(fast and fair scheduler)：为某些任务指定优先级可实现理好的QoS； 会话速率限制(session rate limiting)：适用于托管环境； 支持的平台及OS x86、x86_64、Alpha、SPARC、MIPS及PARISC平台上的Linux 2.4； x86、x86_64、ARM (ixp425)及PPC64平台上的Linux2.6； UltraSPARC 2和3上的Sloaris 8/9； Opteron和UltraSPARC平台上的Solaris 10； x86平台上的FreeBSD 4.1-8 i386, amd64, macppc, alpha, sparc64和VAX平台上的OpenBSD 3.1-current； 若要获得最高性能，需要在Linux 2.6或打了epoll补丁的Linux 2.4上运行haproxy 1.2.5以上的版本。 1.1默认使用的polling系统为select()，其处理的文件数达数千个时性能便会急剧下降。 1.2和1.3版本默认的为poll()，在有些操作系统上可会也会有性能方面的问题，但在Solaris上表现相当不错。 1.3在Linux 2.6及打了epoll补丁的Linux 2.4上默认使用epoll，在FreeBSD上使用kqueue，这两种机制在任何负载上都能提供恒定的性能表现。 在较新版本的Linux 2.6(&gt;=2.6.27.19)上，HAProxy还能够使用splice()系统调用在接口间无复制地转发任何数据，这甚至可以达到10Gbps的性能。 基于以上事实，在x86或x86_64平台上，要获取最好性能的负载均衡器，建议按顺序考虑以下方案。 Linux 2.6.32及之后版本上运行HAProxy 1.4； 打了epoll补丁的Linux 2.4上运行HAProxy 1.4； FreeBSD上运行HAProxy 1.4； Solaris 10上运行HAProxy 1.4； 性能可以从三个因素来评估负载均衡器的性能： 会话率 会话并发能力 数据率 HAProxy借助于OS上几种常见的技术来实现性能的最大化。 单进程、事件驱动模型显著降低了上下文切换的开销及内存占用。 O(1)事件检查器(event checker)允许其在高并发连接中对任何连接的任何事件实现即时探测。 在任何可用的情况下，单缓冲(single buffering)机制能以不复制任何数据的方式完成读写操作，这会节约大量的CPU时钟周期及内存带宽； 借助于Linux 2.6 (&gt;= 2.6.27.19)上的splice()系统调用，HAProxy可以实现零复制转发(Zero-copy forwarding)，在Linux 3.5及以上的OS中还可以实现零复制启动(zero-starting)； MRU内存分配器在固定大小的内存池中可实现即时内存分配，这能够显著减少创建一个会话的时长； 树型存储：侧重于使用作者多年前开发的弹性二叉树，实现了以O(log(N))的低开销来保持计时器命令、保持运行队列命令及管理轮询及最少连接队列； 优化的HTTP首部分析：优化的首部分析功能避免了在HTTP首部分析过程中重读任何内存区域； 精心地降低了昂贵的系统调用，大部分工作都在用户空间完成，如时间读取、缓冲聚合及文件描述符的启用和禁用等； 所有的这些细微之处的优化实现了在中等规模负载之上依然有着相当低的CPU负载，甚至于在非常高的负载场景中，5%的用户空间占用率和95%的系统空间占用率也是非常普遍的现象，这意味着HAProxy进程消耗比系统空间消耗低20倍以上。因此，对OS进行性能调优是非常重要的。即使用户空间的占用率提高一倍，其CPU占用率也仅为10%，这也解释了为何7层处理对性能影响有限这一现象。由此，在高端系统上HAProxy的7层性能可轻易超过硬件负载均衡设备。 在生产环境中，在7层处理上使用HAProxy作为昂贵的高端硬件负载均衡设备故障故障时的紧急解决方案也时长可见。硬件负载均衡设备在“报文”级别处理请求，这在支持跨报文请求(request across multiple packets)有着较高的难度，并且它们不缓冲任何数据，因此有着较长的响应时间。对应地，软件负载均衡设备使用TCP缓冲，可建立极长的请求，且有着较大的响应时间。 web反向代理及站点架构]]></content>
      <categories>
        <category>Haproxy</category>
      </categories>
      <tags>
        <tag>Haproxy</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx常用参数配置说明]]></title>
    <url>%2F2017%2F01%2F02%2FNginx%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[nginx.vim 使用vim对nginx配置文件做语法高亮 站点： http://www.vim.org/scripts/script.php?script_id=1886 123456mkdir -pv ~/.vim/syntax# 语法目录创建wget http://www.vim.org/scripts/download_script.php?src_id=19394 -O ~/.vim/syntax/nginx.vim# 下载nginx.vim到~/vim/syntax/目录下au BufRead,BufNewFile /etc/nginx/*,/usr/local/nginx/conf/* setfiletype nginx ' # 编辑~/.vim/filetype.vim，写入代码；路径要按照实际安装路径来修改 文件结构配置文件/usr/local/nginx/conf/nginx.conf 12345678910111213141516171819....events&#123;....&#125;http&#123;.... server &#123; location&#123;&#125; .... &#125; server &#123; location &#123;&#125; .... &#125;&#125; 正常运行的必备配置user Syntax: user user [group];Default: user nobody nobody;Context: main Defines user and group credentials used by worker processes. If group is omitted, a group whose name equals that of user is used.Nginx以哪个用户和组身份运行；如果在configure指定，则运行时以指定的用户和组为准 pid Syntax: pid file;Default: pid nginx.pid;Context: main Defines a file that will store the process ID of the main process.Nginx进程标识符存放路径；如果在configure指定，则运行时以指定的pid文件为准 worker_rlimit_nofile Syntax: worker_rlimit_nofile number;Default: —Context: main Changes the limit on the maximum number of open files (RLIMIT_NOFILE) for worker processes. Used to increase the limit without restarting the main process.指定一个worker进程所能够打开的最大文件描述符数；理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与（ulimit -n ）的值保持一致。 worker_rlimit_sigpending (Since Linux 2.6.8) Specifies the limit on the number of signals that may be queued for the real user ID of the calling process. 设定每个用户能够发往worker进程的信号的数量； 优化性能相关的配置worker_processes Syntax: worker_processes number | auto;Default: worker_processes 1;Context: main Defines the number of worker processes. work进程的个数 ，通常其数值应该为cpu的物理核心数减1 可以根据物理CPU自动设定。 worker不使用进程或线程处理请求，而是直接将worker绑定到CPU上,，这样就没有进程切换的说法了。 worker_cpu_affinity Syntax: worker_cpu_affinity cpumask …;worker_cpu_affinity auto [cpumask];Default: —Context: main Binds worker processes to the sets of CPUs. Each CPU set is represented by a bitmask of allowed CPUs. There should be a separate set defined for each of the worker processes. By default, worker processes are not bound to any specific CPUs.仅用于Linux。将worker进程与指定的CPU进行绑定，这种绑定不能隔离CPU，CPU还可能会响应其它进程请求。 12345678work_procrsses 6worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000;# Bind each worker process to one CPU only.# 分别给每个worker进程绑定一个CPU.worker_processes 2;worker_cpu_affinity 0101 1010;# Binds the first worker process to CPU0/CPU2, and the second worker process to CPU1/CPU3. The second example is suitable for hyper-threading.# 将CPU0/CPU2绑定给第一个worker进程，将CPU1/CPU3绑定给第二个worker进程。 ssl_engine Syntax: ssl_engine device;Default: —Context: main Defines the name of the hardware SSL accelerator.在存在ssl硬件加速器的服务器上，指定所使用的ssl硬件加速设备 timer_resolution Syntax: timer_resolution interval;Default: —Context: main Reduces timer resolution in worker processes, thus reducing the number of gettimeofday() system calls made. By default, gettimeofday() is called each time a kernel event is received. With reduced resolution, gettimeofday() is only called once per specified interval. 每次内核事件调用返回时，都会使用gettimeday()来更新nginx缓存时钟； timer_resolution用于定义每隔多久才会由gettimeday()更新一次缓存时钟； 更新越频繁系统压力越大； x86-64系统上，gettimeday()代价已经很小，可以不做此配置； worker_priority1worker_priority -10; Syntax: worker_priority number;Default: worker_priority 0;Context: main Defines the scheduling priority for worker processes like it is done by the nice command: a negative number means higher priority. Allowed range normally varies from -20 to 20.worker进程的优先级，默认为0；20到19之间的值，值越小越优先调用 跟事件相关的配置accept_mutex Syntax: accept_mutex on | off;Default: accept_mutex off;Context: events If accept_mutex is enabled, worker processes will accept new connections by turn. Otherwise, all worker processes will be notified about new connections, and if volume of new connections is low, some of the worker processes may just waste system resources.是否打开nginx的负载均衡锁 此锁能够让多个worker进行轮流地、序列化地与新的客户端建立连接； 而通常当一个worker进程的负载达到其上限的7/8，master就尽可能不将请求调度至此worker lock_file Syntax: lock_file file;Default: lock_file logs/nginx.lock;Context: main nginx uses the locking mechanism to implement accept_mutex and serialize access to shared memory. On most systems the locks are implemented using atomic operations, and this directive is ignored. On other systems the “lock file” mechanism is used. This directive specifies a prefix for the names of lock files.锁文件 accept_mutex_delay Syntax: accept_mutex_delay time;Default: accept_mutex_delay 500ms;Context: events If accept_mutex is enabled, specifies the maximum time during which a worker process will try to restart accepting new connections if another worker process is currently accepting new connections. 使用accept锁以后，只有一个worker能取得锁，一个worker进程为取得accept锁的等待时长，即用户建立等待的时间 如果某worker进程在某次试图取得锁时失败了，至少要等待#ms才能再锁。 multi_accept Syntax: multi_accept on | off;Default: multi_accept off;Context: eventsmulti_accept on|off; If multi_accept is disabled, a worker process will accept one new connection at a time. Otherwise, a worker process will accept all new connections at a time.是否允许一次性地响应多个用户连接请求 use Syntax: use method;Default: —Context: events Specifies the connection processing method to use. There is normally no need to specify it explicitly, because nginx will by default use the most efficient method. use [epoll|rtsig|select|poll];指定使用哪种事件驱动模型，建议让nginx自动选择，linux上一般用epoll worker_commections Syntax: worker_connections number;Default: worker_connections 512;Context: events Sets the maximum number of simultaneous connections that can be opened by a worker process. It should be kept in mind that this number includes all connections (e.g. connections with proxied servers, among others), not only connections with clients. Another consideration is that the actual number of simultaneous connections cannot exceed the current limit on the maximum number of open files, which can be changed by worker_rlimit_nofile. 每个worker能够并发响应的最大请求数，如果为代理服务器的话，worker_rlimit_nofile=worker_commections*2 用于调试、定位问题只调试nginx时使用 daemon Syntax: daemon on | off;Default: daemon on;Context: main Determines whether nginx should become a daemon. Mainly used during development.关闭提供守护进程的模式，是否让nignx运行于后台；调试时应该为off，使得所有信息直接输出在控制台 master_process Syntax: master_process on | off;Default: master_process on;Context: main Determines whether worker processes are started. This directive is intended for nginx developers.是否以master/worker模式运行nginx，默认为on，调试时可以设置为off以方便追踪 error_log Syntax: error_log file [level];Default: error_log logs/error.log error;Context: main, http, mail, stream, server, location Configures logging. Several logs can be specified on the same level (1.5.2).错误日志文件及其级别，调试时可以使用debug级别，但要求在编译时必须使用–with-debug启用debug功能，默认通常为error级别 http配置必须使用虚拟机来配置站点，每个虚拟主机使用一个server{}段来配置 1234 server&#123; &#125;# 定义一个虚拟主机，server可以出现一次或多次。nginx支持使用基于主机名或IP的虚拟主机 非虚拟主机的配置和公共选项，需要定义在server之外，http之内 12345678910http&#123; directive value; .... server&#123; ...... &#125; server&#123; &#125; ......&#125; listen Syntax: listen address[:port] [default_server] [ssl]listen port [default_server] [ssl]listen unix:path [default_server] [ssl]Default: listen :80 | :8000;Context: server Sets the address and port for IP, or the path for a UNIX-domain socket on which the server will accept requests. Both address and port, or only address or only port can be specified. An address may also be a hostname, for example:12345listen 127.0.0.1:8000;listen 127.0.0.1;listen 8000;listen *:8000;listen localhost:8000; 设置监听的地址或端口 default_server：定义此server为http中默认的server； 如果所有的server中没有任何一个listen使用此参数，那么第一个server即为默认server; ssl Syntax: ssl on | off;Default: ssl off;Context: http, server Enables the HTTPS protocol for the given virtual server.是否启用https服务器 rcvbuf和sndbuf1234rcvbuf=SIZE;# 接收缓存大小sndbuf=SIZE;# 发送缓存大小 server_name Syntax: server_name name …;Default: server_name “”;Context: server Sets names of a virtual server设置主机名 server_name可以跟多个主机名，名称可以使用通配符和正则表达式（通常以~开头）； 当nginx收到一个请求时，会取出其首部的server的值，而后跟众server_name进行比较： 先做精确匹配 左侧通配符匹配 右侧通配符匹配 正则表达式匹配 server_name_hash_bucket_size Syntax: server_names_hash_bucket_size size;Default: server_names_hash_bucket_size 32|64|128;Context: http Sets the bucket size for the server names hash tables. The default value depends on the size of the processor’s cache line. The details of setting up hash tables are provided in a separate document.为了实现快速主机查找，nginx使用hash表来保存主机名 location Syntax1: location [ = | ~ | ~* | ^~ ] uri { … }Syntax2: location @name { … }Default: —Context: server, location Sets configuration depending on a request URI.允许根据用户请求的URI来匹配指定的各location以进行访问配置；匹配到时，将被location块中的配置所处理 123456=：精确匹配~：正则表达式模式匹配，匹配时区分字符大小写~*：正则表达式模式匹配，匹配时忽略字符大小写^~:只需要前半部分与uri匹配即可，不检查正则表达式# 匹配优先级：# 字符字面量最精确匹配、正则表达式检索（由多个时，由第一个匹配到的所处理），按字符字面量 文件路径定义root Syntax: root path;Default: root html;Context: http, server, location, if in location Sets the root directory for requests. For example, with the following configuration设置web资源路径，用于指定请求的根文档目录，从根开始匹配 alias Syntax: alias path;Default: —Context: location Defines a replacement for the specified location. For example, with the following configuration指定路径别名，只能用于location中，从最后一个/开始匹配 index Syntax: index filename;Default: index index.html index.htm;Context: location 定义默认页面，可以跟多个值。自左向右匹配 error_page Syntax: error_page code … [=[response]] uri;Default: —Context: http, server, location, if in location Defines the URI that will be shown for the specified errors. A uri value can contain variables.当对于某个请求发回错误时，如果匹配上了error_page指令中设定的code，则重定向至新的新URI中 try_files Syntax1: try_files file … uri;Syntax2: try_files file … =code;Default: —Context: server, location Checks the existence of files in the specified order and uses the first found file for request processing; the processing is performed in the current context. The path to a file is constructed from the file parameter according to the root and alias directives. It is possible to check directory’s existence by specifying a slash at the end of a name, e.g. “$uri/”. If none of the files were found, an internal redirect to the uri specified in the last parameter is made.自左向右尝试读取有path所指定路径，在第一找到即停止并返回，如果所有path均不存在，则返回最后一个uri 1234location ~* ^/document/(.*)$&#123; root /www/htdocs try_files $uri /docu/$1 /temp.html&#125; 网络连接相关设置keepalive_timeout Syntax: keepalive_timeout timeout [header_timeout];Default: keepalive_timeout 75s;Context: http, server, location The first parameter sets a timeout during which a keep-alive client connection will stay open on the server side. The zero value disables keep-alive client connections. The optional second parameter sets a value in the “Keep-Alive: timeout=time” response header field. Two parameters may differ. The “Keep-Alive: timeout=time” header field is recognized by Mozilla and Konqueror. MSIE closes keep-alive connections by itself in about 60 seconds. 设置持久连接的超时时长 keepalive_requests Syntax: keepalive_requests number;Default: keepalive_requests 100;Context: http, server, locationThis directive appeared in version 0.8.0. Sets the maximum number of requests that can be served through one keep-alive connection. After the maximum number of requests are made, the connection is closed.在一次持久连接中允许承载的最大请求数 keepalive_disable Syntax: keepalive_disable none | browser …;Default: keepalive_disable msie6;Context: http, server, location Disables keep-alive connections with misbehaving browsers. The browser parameters specify which browsers will be affected. The value msie6 disables keep-alive connections with old versions of MSIE, once a POST request is received. The value safari disables keep-alive connections with Safari and Safari-like browsers on Mac OS X and Mac OS X-like operating systems. The value none enables keep-alive connections with all browsers. 对指定的浏览器禁止使用长连接 .tcp_nodelay Syntax: tcp_nodelay on | off;Default: tcp_nodelay on;Context: http, server, location Enables or disables the use of the TCP_NODELAY option. The option is enabled only when a connection is transitioned into the keep-alive state.对keepalive连接是否使用tcp_nodelay选项 client_header_timeout Syntax: client_header_timeout time;Default: client_header_timeout 60s;Context: http, server Defines a timeout for reading client request header. If a client does not transmit the entire header within this time, the 408 (Request Time-out) error is returned to the client.设置客读取http请求首部的超时时长 client_body_timeout Syntax: client_body_timeout time;Default: client_body_timeout 60s;Context: http, server, location Defines a timeout for reading client request body. The timeout is set only for a period between two successive read operations, not for the transmission of the whole request body. If a client does not transmit anything within this time, the 408 (Request Time-out) error is returned to the client.设置读取http请求包体的超时时间 send_timeout Syntax: send_timeout time;Default: send_timeout 60s;Context: http, server, location Sets a timeout for transmitting a response to the client. The timeout is set only between two successive write operations, not for the transmission of the whole response. If the client does not receive anything within this time, the connection is closed.设置发送响应的超时时长 对客户端请求的限制limit_except Syntax: limit_except method … { … }Default: —Context: location Limits allowed HTTP methods inside a location. The method parameter can be one of the following: GET, HEAD, POST, PUT, DELETE, MKCOL, COPY, MOVE, OPTIONS, PROPFIND, PROPPATCH, LOCK, UNLOCK, or PATCH. Allowing the GET method makes the HEAD method also allowed. Access to other methods can be limited using the ngx_http_access_module and ngx_http_auth_basic_module modules directives: 1234limit_except GET &#123; allow 192.168.1.0/32; deny all;&#125; Please note that this will limit access to all methods except GET and HEAD.在location中对指定范围之外的其他方法的访问控制 client_max_body_size Syntax: client_max_body_size size;Default: client_max_body_size 1m;Context: http, server, location Sets the maximum allowed size of the client request body, specified in the “Content-Length” request header field. If the size in a request exceeds the configured value, the 413 (Request Entity Too Large) error is returned to the client. Please be aware that browsers cannot correctly display this error. Setting size to 0 disables checking of client request body size. 设置http请求包体的最大值，常用于限定客户端所能够请求的最大包体，根据请求首部中的Content-Length来检查，以避免无用的传输 limit_rate Syntax: limit_rate rate;Default: limit_rate 0;Context: http, server, location, if in location Limits the rate of response transmission to a client. The rate is specified in bytes per second. The zero value disables rate limiting. The limit is set per a request, and so if a client simultaneously opens two connections, the overall rate will be twice as much as the specified limit. Rate limit can also be set in the $limit_rate variable. It may be useful in cases where rate should be limited depending on a certain condition: 12345678server &#123; if ($slow) &#123; set $limit_rate 4k; &#125; ...&#125; 限制客户端每秒传输的字节数，默认为0表示没有限制 limit_rate_after Syntax: limit_rate_after size;Default: limit_rate_after 0;Context: http, server, location, if in location This directive appeared in version 0.8.0.Sets the initial amount after which the further transmission of a response to a client will be rate limited. Example: 12345location /flv/ &#123; flv; limit_rate_after 500k; limit_rate 50k;&#125; nginx向客户端发送响应报文时，如果文件超过指定的大小，则后续的发送过程开始限速 文件操作的优化sendfile Syntax: sendfile on | off;Default: sendfile off;Context: http, server, location, if in location Enables or disables the use of sendfile().是否启用sendfile功能 aio Syntax: aio on | off | threads[=pool];Default: aio off;Context: http, server, locationThis directive appeared in version 0.8.11. Enables or disables the use of asynchronous file I/O (AIO) on FreeBSD and Linux是否启用aio功能 open_file_cache Syntax1: open_file_cache off;Syntax2: open_file_cache max=N [inactive=time];Default: open_file_cache off;Context: http, server, location Configures a cache that can store: open file descriptors, their sizes and modification times; information on existence of directories; file lookup errors, such as “file not found”, “no read permission”, and so on. 是否打开文件缓存功能 max：用于缓存条目的最大值，允许打开的缓存条目最大数，当满两类以后将根据LRU（最小最少连接数）算法进行置换 inactive：某缓存条目在指定时长内没有被访问过时，将自动被删除；通常默认为60s 缓存的信息包括： 文件句柄、文件大小和上次修改时间; 已经打开的目录结构; 没有找到或没有访问权限的信息; open_file_cache_errors Syntax: open_file_cache_errors on | off;Default: open_file_cache_errors off;Context: http, server, location Enables or disables caching of file lookup errors by open_file_cache.是否缓存 文件找不到 或 没有权限访问 等相关信息 open_file_cache_valid Syntax: open_file_cache_valid time;Default: open_file_cache_valid 60s;Context: http, server, location Sets a time after which open_file_cache elements should be validated.多长时间检查一次缓存中的条目是否超出非活动时长，默认为60s open_file_cache_min_use Syntax: open_file_cache_min_uses number;Default: open_file_cache_min_uses 1;Context: http, server, location Sets the minimum number of file accesses during the period configured by the inactive parameter of the open_file_cache directive, required for a file descriptor to remain open in the cache.在inactive指定的时长内被访问超过此处指定的次数时，才不会被删除 对客户端请求的特殊处理ignore_invalid_headers Syntax: ignore_invalid_headers on | off;Default: ignore_invalid_headers on;Context: http, server Controls whether header fields with invalid names should be ignored. Valid names are composed of English letters, digits, hyphens, and possibly underscores (as controlled by the underscores_in_headers directive). If the directive is specified on the server level, its value is only used if a server is a default one. The value specified also applies to all virtual servers listening on the same address and port. 是否忽略不合法的http首部。off意味着请求首部中出现不合规的首部将拒绝响应 log_not_found Syntax: log_not_found on | off;Default: log_not_found on;Context: http, server, location Enables or disables logging of errors about not found files into error_log.用户访问的文件不存在时，是否将其记录到错误日志中 resolver address Syntax: resolver address … [valid=time] [ipv6=on|off];Default: —Context: http, server, location Configures name servers used to resolve names of upstream servers into addresses指定nginx使用的dns服务器地址 resolve timeout Syntax: resolver_timeout time;Default: resolver_timeout 30s;Context: http, server, location Sets a timeout for name resolution指定DNS解析超时时长 server_tokens Syntax: server_tokens on | off | string;Default: server_tokens on;Context: http, server, location Enables or disables emitting nginx version in error messages and in the “Server” response header field.是否在错误页面中显示nginx的版本号 核心模块的内置变量： $uri：当前请求的uri，不带参数 $request_uri：请求的uri，带完整参数 $host：http请求报文中host首部；如果请求中没有host首部，则以处理此请求的主机的主机名代替 $hostname：nginx服务运行所在主机的主机名 $remote_addr：客户端IP $remote_port: 客户端port $remote_user：使用用户认证时客户端用户输入的用户名 $request_filename：用户请求中的URI经过本地root或alias转换后映射的本地的文件路径 $request_method：请求方法 $server_addr：服务器地址 $server_name: 服务器名称 $server_port：服务器端口 $server_protocol：服务器向客户端发送响应时的协议，如http/1.1，http/1.0 $scheme：在请求中使用的scheme 映射协议本身的协议 $http_HEADER：匹配请求报文中指定的HEADER，$http_host匹配请求报文中的host首部 $sent_http_HEADER：匹配响应报文中指定的HERDER，例如$http_content_type匹配相应报文中的content-type首部 $document_root：当前请求映射到的root配置 URL rewrite nginx通过ngx_http_rewrite_module模块支持url重写、支持if条件判断，但不支持else。 该模块需要PCRE支持，应在编译 nginx 时指定PCRE源码目录。 rewrite指令执行顺序 执行server块的rewrite指令(这里的块指的是server关键字后{}包围的区域，其它xx块类似) 执行location匹配 执行选定的location中的rewrite指令 如果其中某步URI被重写，则重新循环执行1-3，直到找到真实存在的文件如果循环超过10次，则返回500 Internal ServerError错误 break Syntax: break;Default: —Context: server,location,if Stops processing the current set of ngx_http_rewrite_module directives.停止处理当前的ngx_http_rewrite_module的指令 Example： 1234if ($slow) &#123; limit_rate 10k; break;&#125; if Syntax: if(condition){…}Default: —Context: server,location The specified condition is evaluated. If true, this module directives specified inside the braces are executed, and the request is assigned the configuration inside the if directive. Configurations inside the if directives are inherited from the previous configuration level.对给定的条件condition进行判断。如果为真，大括号内的rewrite指令将被执行。 if条件(conditon)可以是如下任何内容： 一个变量名；false如果这个变量是空字符串或者以0开始的字符串； 使用= ，!= 比较的一个变量和字符串 使用~， ~*与正则表达式匹配的变量，如果这个正则表达式中包含 } 则整个表达式需要用 “ 或’ ‘ 包围 使用-f ，!-f 检查一个文件是否存在 使用-d, !-d 检查一个目录是否存在 使用-e ，!-e 检查一个文件、目录、符号链接是否存在 使用-x ， !-x 检查一个文件是否可执行 Example： 12345678910111213141516171819if ($http_user_agent ~ MSIE) &#123; rewrite ^(.*)$ /msie/$1 break;&#125; if ($http_cookie ~*"id=([^;]+)(?:;|$)") &#123; set $id $1;&#125; if ($request_method = POST) &#123; return 405;&#125; if ($slow) &#123; limit_rate 10k;&#125; if ($invalid_referer) &#123; return 403;&#125; return Syntax1: return code [text];Syntax2: return code URL;Syntax3: return URL;Default: —Context: server, location, if Stops processing and returns the specified code to a client. The non-standard code 444 closes a connection without sending a response header. 停止处理并返回指定状态码(code)给客户端 非标准状态码444表示关闭连接且不给客户端发响应头。 从0.8.42版本起，return 支持响应URL重定向(对于301，302，303，307），或者文本响应(对于其他状态码) 对于文本或者URL重定向可以包含变量 rewrite Syntax: rewrite regex replacement [flag];Default: —Context: server, location, if If the specified regular expression matches a request URI, URI is changed as specified in the replacement string. The rewrite directives are executed sequentially in order of their appearance in the configuration file. It is possible to terminate further processing of the directives using flags. If a replacement string starts with “http://”, “https://”, or “$scheme”, the processing stops and the redirect is returned to a client. 如果一个URI匹配指定的正则表达式regex，URI就按照replacement重写。 rewrite按配置文件中出现的顺序执行。flags标志可以停止继续处理。 如果replacement以 http:// 或 https:// 开始，将不再继续处理，这个重定向将返回给客户端。 flag：标志位 last 一旦被当前规则匹配并重写后立即停止检查后续的其他rewrite的规则，而后通过重写后的规则重新发起请求 break 一旦被当前规则匹配并重写后立即停止检查后续的其他rewrite的规则，而后继续由nginx进行后续的操作 redirect 如果replacement不是以http:// 或 https:// 开始 ，返回302临时重定向 permant 返回301永久重定向 最终完整的重定向URL包括请求scheme( http:// https:// 等),请求的server_name_in_redirect和 port_in_redirec三部分，说白了也就是http协议 域名 端口三部分组成。 Example： 1234567server &#123; #... rewrite ^(/download/.*)/media/(.*)\..*$ $1/mp3/$2.mp3 last; rewrite ^(/download/.*)/audio/(.*)\..*$ $1/mp3/$2.ra last; return 403; #...&#125; 一般将rewrite写在location中时都使用break标志，或者将rewrite写在if上下文中；如下所示, 那么应使用break而不是last , 否则last将循环10次匹配，然后返回 500错误: 12345location /download/ &#123; rewrite ^(/download/.*)/media/(.*)\..*$ $1/mp3/$2.mp3 break; rewrite ^(/download/.*)/audio/(.*)\..*$ $1/mp3/$2.ra break; return 403;&#125; 如果客户端使用IE浏览器，则重定向到/nginx-ie目录下 123if ($http_user_agent~ MSIE) &#123; rewrite ^(.*)$ /nginx-ie/$1 break;&#125; 禁止访问多个目录 1234location ~^/(cron|templates)/ &#123; deny all; break;&#125; 禁止访问以/data开头的文件 1234location ~ ^/data &#123; deny all; break;&#125; 禁止访问.sh、.flv、.mp4为文件名后缀的URL地址 123location ~.*\.(sh|flv|mp4)?$ &#123; return 403;&#125; 注意： （1）、在写URI地址的时候，留意 . 是否要转义字符操作 （2）、如果正则表达regex式中包含 } 或 ; , 那么整个表达式需要用双引号或单引号包围 （3）、如果被替换的URI中含有参数（即类似/app/test.php?id=5之类的URI），默认情况下参数id=5会自动附加到替换串上，如果不想自动附带后面的参数，可以在replacement后加一个问号。如下，我们加了一个自定义的参数user=$1,然后在结尾处放了一个问号?，把原先的参数去掉。Example： 123rewrite ^/users/(.*)$ /show?user=$1? last;rewrite ^/test(.*)$ http://www.test.com/home? permanent; # 结果是http://www.test.com/home rewrite_log Syntax: rewrite_log on | off;Default: rewrite_log off;Context: http, server, location, if Enables or disables logging of ngx_http_rewrite_module module directives processing results into the error_log at the notice level.是否将重写过程记录在错误日志中，默认为notice级别；默认为off 配置使用nginxnginx虚拟主机12345server&#123; listen server_name root&#125; 访问控制access模块123allowdeny#至上而下依次认证，默认为通过 基于用户认证123456location /admin/ &#123; root auth_basic "标题" auth_basic_user_file "密码的存放位置" &#125;# 使用htpasswd创建密码 建立下载站点1234location /download/&#123; root autoindex on&#125; 防盗链 定义合规的引用 1valid_referers none |blocked |server_names|string ... 判断不合规的引用 123if ($invaild_referer) &#123; rewrite ^/.*$ http://www.a.com/403.html&#125; .状态页123456789server &#123; server_name 127.0.0.1; location /nginx_status &#123; stub_status on; access_log off; allow 127.0.0.1; deny all; &#125;&#125; 输出Active connections: 3176server accepts handled requests12633357212 12633357212 16331056076Reading: 4 Writing: 97 Waiting: 3075 Active connections: 当前 Nginx 正处理的活动连接数。 serveraccepts handled requests — 总共处理了 233851 个连接 , 成功创建 233851 次握手 (证明中间没有失败的 ), 总共处理了 687942 个请求 ( 平均每次握手处理了 2.94 个数据请求 )。 Reading : nginx当前读取到客户端的 Header 信息数。 Writing : nginx 当前返回给客户端的 Header 信息数。 Waiting: 开启 keep-alive 的情况下，这个值等于 active – (reading + writing)， 意思就是 Nginx 已经处理完正在等候下一次请求指令的驻留连接。 压缩12gzipgzip on|off gzip_buffer 使用的缓存大小 gzip_comp_level 压缩的级别 gzip_disable 不压缩的类型或浏览器 gzip_min_length 最少压缩的大小 gzip_http_version 压缩完成以后发送http的版本 gzip_types：只压缩的格式]]></content>
      <categories>
        <category>Services</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx编译安装]]></title>
    <url>%2F2017%2F01%2F01%2FNginx%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[下载站点 源码包站点：http://nginx.org/en/download.html下载链接：http://nginx.org/download/nginx-1.10.2.tar.gz 编译安装环境准备1234567yum -y groupinstall "Compatibility libraries" "Development tools" "Server Platform Development"# 解决依赖关系，安装开发环境软件包组yum -y install pcre-devel zlib-devel gcc gcc-c++ openssl-devel# 安装pcre(Perl语言正则表达式库)、zlib库、openssl库、gcc及gcc++# gzip模块需要 zlib 库# rewrite模块需要 pcre 库# ssl 功能需要openssl库 添加用户和组123groupadd -r nginxuseradd -r -g nginx -s /bin/false -M nginx# 首先添加用户nginx，实现以之运行nginx服务进程： 编译安装12345678910111213141516171819202122tar xf nginx-1.10.2.tar.gz cd nginx-1.10.2./configure \--prefix=/usr/local/nginx \--sbin-path=/usr/local/nginx/sbin/nginx \--conf-path=/usr/local/nginx/conf/nginx.conf \--error-log-path=/usr/local/nginx/logs/error.log \--http-log-path=/usr/local/nginx/logs/access.log \--pid-path=/usr/local/nginx/logs/nginx.pid \--lock-path=/usr/local/nginx/logs/nginx.lock \--user=nginx \--group=nginx \--with-http_ssl_module \--with-http_flv_module \--with-http_stub_status_module \--with-http_gzip_static_module \--http-client-body-temp-path=/usr/local/nginx/tmp/client_body_temp \--http-proxy-temp-path=/usr/local/nginx/tmp/proxy_temp \--http-fastcgi-temp-path=/usr/local/nginx/tmp/fastcgi_temp \--http-uwsgi-temp-path=/usr/local/nginx/tmp/uwsgi_temp \--http-scgi-temp-path=/usr/local/nginx/tmp/scgi_temp \--with-pcre | tee -a /tmp/nginx_configure.log 帮助和检查1234567/usr/local/nginx/sbin/nginx -h# 查看使用帮助/usr/local/nginx/sbin/nginx -t# 配置检查# nginx: [emerg] mkdir() "/usr/local/nginx/tmp/client_body_temp" failed (2: No such file or directory)# 指定的目录未创建，需要手动创建mkdir -pv /usr/local/nginx/tmp/ 启动进程123456killall httpd# 停用现有的httpd进程/usr/local/nginx/sbin/nginx # 启动nginx ss -tnl# 验证进程 服务脚本为nginx提供SysV init脚本，根据具体配置修改脚本内容 1vim /etc/rc.d/init.d/nginx 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#!/bin/sh## nginx - this script starts and stops the nginx daemon## chkconfig: - 85 15 # description: Nginx is an HTTP(S) server, HTTP(S) reverse \# proxy and IMAP/POP3 proxy server# processname: nginx# config: /usr/local/nginx/conf/nginx.conf# config: /etc/sysconfig/nginx# pidfile: /usr/local/nginx/logs/nginx.pid # Source function library.. /etc/rc.d/init.d/functions # Source networking configuration.. /etc/sysconfig/network # Check that networking is up.[ "$NETWORKING" = "no" ] &amp;&amp; exit 0 nginx="/usr/local/nginx/sbin/nginx"# nginx命令路径prog=$(basename $nginx) NGINX_CONF_FILE=" /usr/local/nginx/conf/nginx.conf"# nginx配置文件路径[ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginx lockfile=/usr/local/nginx/logs/nginx.lock # lock文件路径 make_dirs() &#123; # make required directories user=`$nginx -V 2&gt;&amp;1 | /bin/fgrep 'configure arguments' | /bin/sed -r 'sS[^*]*--user=([^ ]*).*S\1Sg' -` options=`$nginx -V 2&gt;&amp;1 | /bin/fgrep 'configure arguments:'` for opt in $options; do if [ `echo $opt | grep '.*-temp-path'` ]; then value=`echo $opt | cut -d "=" -f 2` if [ ! -d "$value" ]; then # echo "creating" $value mkdir -p $value &amp;&amp; chown -R $user $value fi fi done&#125; start() &#123; [ -x $nginx ] || exit 5 [ -f $NGINX_CONF_FILE ] || exit 6 make_dirs echo -n $"Starting $prog: " daemon $nginx -c $NGINX_CONF_FILE retval=$? echo [ $retval -eq 0 ] &amp;&amp; touch $lockfile return $retval&#125; stop() &#123; echo -n $"Stopping $prog: " killproc $prog -QUIT retval=$? echo [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile return $retval&#125; restart() &#123; configtest || return $? stop sleep 1 start&#125; reload() &#123; configtest || return $? echo -n $"Reloading $prog: " killproc $nginx -HUP RETVAL=$? echo&#125; force_reload() &#123; restart&#125; configtest() &#123; $nginx -t -c $NGINX_CONF_FILE&#125; rh_status() &#123; status $prog&#125; rh_status_q() &#123; rh_status &gt;/dev/null 2&gt;&amp;1&#125; case "$1" in start) rh_status_q &amp;&amp; exit 0 $1 ;; stop) rh_status_q || exit 0 $1 ;; restart|configtest) $1 ;; reload) rh_status_q || exit 7 $1 ;; force-reload) force_reload ;; status) rh_status ;; condrestart|try-restart) rh_status_q || exit 0 ;; *) echo $"Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;" exit 2esac 服务添加和启动123chkconfig --add nginxchkconfig nginx onservice nginx start 编译安装参数说明123456789101112131415161718192021222324--prefix= 指向安装目录--sbin-path nginx程序路径--conf-path= 配置文件路径（nginx.conf）--error-log-path= 错误日志路径--http-log-path= 访问日志路径--pid-path= pid文件路径--lock-path= 锁文件路径--user= 程序运行时的用户--group= 指定程序运行时的用户组--with-http_ssl_module 启用ngx_http_ssl_module支持（使支持https请求，需已安装openssl）--with-http_flv_module 启用ngx_http_flv_module支持（提供寻求内存使用基于时间的偏移量文件）--with-http_stub_status_module 启用ngx_http_stub_status_module支持（获取nginx自上次启动以来的工作状态）--with-http_gzip_static_module 启用ngx_http_gzip_static_module支持（在线实时压缩输出数据流）--http-client-body-temp-path= 设定http客户端请求临时目录路径--http-proxy-temp-path= 设定http代理临时目录路径--http-fastcgi-temp-path= 设定http fastcgi临时目录路径--http-uwsgi-temp-path= 设定http uwsgi临时目录路径--http-scgi-temp-path= 设定http scgi临时目录路径--with-debug 启用debug日志--with-http_perl_module 启用ngx_http_perl_module支持（该模块使nginx可以直接使用perl或通过ssi调用perl）--with-perl_modules_path= 设定perl模块路径--with-perl= 设定perl库文件路径--with-pcre 启用pcre库--with-pcre= pcre库文件目录路径]]></content>
      <categories>
        <category>Services</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx服务器特性]]></title>
    <url>%2F2017%2F01%2F01%2FNginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[NginxNginx (读作”engine X”) 由Igor Sysoev(俄罗斯)于2005年编写，是一个免费、开源、高性能的HTTP服务器和反向代理，也可以作为一个IMAP/POP3代理服务器。根据 Netcraft 的 April 2015 Web Server Survey, 现在全世界14.48%的网站使用Nginx，而Apache占38.39%。Nginx因为稳定，丰富的功能集，配置简单，资源占用低而闻名世界。 基本HTTP服务器特性 处理静态文件（静态资源的web服务器），索引文件以及自动索引；能缓存打开的文件描述符 使用缓存加速反向代理服务器；简单负载均衡及容错；健康状态检测 远程FastCGI 模块化架构，非DSO机制；支持多种过滤器gzip，SSI和图像的模块完成图形大小调整等 支持SSL，TLS SNI 扩展HTTP服务器特性 基于名字和IP做虚拟主机 Keep-alive和pipelined连接支持； 灵活的配置； 平滑配置更新或程序版本升级； 重新加载配置以及在线升级时，不需要中断正在处理的请求； 自定义访问日志格式，带缓存的日志写操作及快速日志轮转以提高性能； 3xx-5xx错误代码重定向； 重写（rewrite）模块：使用正则表达式改变URI； 根据客户端地址执行不同的功能； 基于客户端IP地址和用户认证机制的访问控制； 路径别名； 支持验证HTTP referer； 支持PUT、DELETE、MKCOL、COPY以及MOVE方法； 支持FLV流和MP4流； 速度限制； 来自同一地址的同时连接数或请求数限制； 嵌入Perl语言。 邮件代理服务器特性 使用外部HTTP认证服务器重定向用户到IMAP/POP3后端； 使用外部HTTP认证服务器认证用户后重定向连接到内部SMTP后端； 支持的认证方式： POP3: USER/PASS, APOP, AUTH LOGIN/PLAIN/CRAM-MD5; IMAP: LOGIN, AUTH LOGIN/PLAIN/CRAM-MD5; SMTP: AUTH LOGIN/PLAIN/CRAM-MD5; SSL支持； STARTTLS和STLS支持。 架构和扩展性 一个主进程和多个工作进程（一个master 生成一个或多个worker），工作进程以非特权用户运行； 事件驱动机制：kqueue（FreeBSD 4.1+）、epoll（Linux 2.6+）、rt signals（Linux 2.2.19+）、/dev/poll（Solaris 7 11/99+）、event ports（Solaris 10）、select以及poll； 众多支持的kqueue特性包括EV_CLEAR、EV_DISABLE（临时禁止事件）、NOTE_LOWAT、EV_EOF，可用数据的数量，错误代码； 支持sendfile（FreeBSD 3.1+, Linux 2.2+, Mac OS X 10.5+）、sendfile64（Linux 2.4.21+）和sendfilev（Solaris 8 7/01+）； 文件AIO（FreeBSD 4.3+, Linux 2.6.22+）； 支持mmap； DIRECTIO (FreeBSD 4.4+, Linux 2.4+, Solaris 2.6+, Mac OS X); 支持Accept-filters（FreeBSD 4.1+, NetBSD 5.0+）和 TCP_DEFER_ACCEPT（Linux 2.4+）； 10000个非活跃的HTTP keep-alive连接仅占用约2.5M内存； 尽可能避免数据拷贝操作。 模块类别 核心模块 标准http模块 可选的http模块 邮件模块 第三方扩展模块 小结 nginx：非阻塞、事件驱动，一个master多个worker，一个worker响应多个用户请求]]></content>
      <categories>
        <category>Services</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建Zabbix监控服务器]]></title>
    <url>%2F2016%2F03%2F12%2F2016-03-12-104349-%E6%90%AD%E5%BB%BAZabbix%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[简介Linux下常用的系统监控软件有Nagios、Cacti、Zabbix、Monit等，这些开源的软件，可以帮助我们更好的管理机器，在第一时间内发现，并警告系统维护人员。 Zabbix介绍Alexei Vladishev创建了Zabbix项目，当前处于活跃开发状态，Zabbix SIA提供支持. Zabbix是一个企业级的、开源的、分布式的监控套件 Zabbix可以监控网络和服务的监控状况. Zabbix利用灵活的告警机制，允许用户对事件发送基于Email的告警. 这样可以保证快速的对问题作出相应. Zabbix可以利用存储数据提供杰出的报告及图形化方式. 这一特性将帮助用户完成容量规划. Zabbix支持polling和trapping两种方式. 所有的Zabbix报告都可以通过配置参数在WEB前端进行访问. Web前端将帮助你在任何区域都能够迅速获得你的网络及服务状况. Zabbix可以通过尽可能的配置来扮演监控你的IT基础框架的角色，而不管你是来自于小型组织还是大规模的公司. Zabbix是零成本的. 因为Zabbix编写和发布基于GPL V2协议. 意味着源代码是免费发布的. Zabbix公司也提供商业化的技术支持. Zabbix功能 应用监控 数据库/SSH/Apache/Nginx等应用程序的监控。 服务器监控 CPU，内存，SWAP，磁盘空间，网卡流量的监控等. 网络设备监控 支持Cisco, Juniper, 3Com等网络设备，网络设备通过SNMP（SNMP (v1,v2,v3) devices）协议进行监控。 自定义监控 对于Zabbix无法满足的监控，可以添加自定义监控。 Zabbix特性 数据收集 可用性及性能检测 支持SNMP(trapping及polling)、IPMI、JMX监控 自定义检测 自定义间隔收集收据 server/proxy/agents吸能 灵活的阀值定义 允许灵活地自定义问题阀值，Zabbix中称为触发器(trigger), 存储在后端数据库中 高级告警配置 可以自定义告警升级(escalation)、接收者及告警方式 告警信息可以配置并允许使用宏(macro)变量 通过远程命令实行自动化动作(action) 实时绘图 通过内置的绘图方法实现监控数据实时绘图 扩展的图形化显示 允许自定义创建多监控项视图 网络拓扑(network maps) 自定义的面板(screen)和slide shows，并允许在dashboard页面显示 报告 高等级(商业)监控资源 历史数据存储 数据存储在数据库中 历史数据可配置 内置数据清理机制 配置简单 主机通过添加监控设备方式添加 一次配置，终生监控(译者注：除非调整或删除) 监控设备允许使用模板 支持多种语言，包括中文 模板使用 模板中可以添加组监控 模板允许继承 系统自带多种监控模版 网络自动发现 自动发现网络设备 agent自动注册 自动发现文件系统、网卡设备、SNMP OID等 快速的web接口 web前端采用php编写 访问无障碍 你想怎么做就能做么做 审计日志 Zabbix API Zabbix API提供程序级别的访问接口，第三方程序可以很快接入 权限系统 安全的权限认证 用户可以限制允许维护的列表 全特性、agent易扩展 在监控目标上部署 支持Linux及Windows 二进制守护进程 C开发，高性能，低内存消耗 易移植 具备应对复杂环境情况 通过Zabbix proxy可以非常容易的创建远程监控 支持分布式部署和WEB集中管理 Zabbix缺点 需要在被监控机器上面安装agent。 配置信息都存储在数据库里面，数据库是整个监控平台的瓶颈。 Zabbix组件默认情况下，zabbix包含5个程序：zabbix_agentd、zabbix_get、zabbix_sender、zabbix_server，zabbix_proxy、可选程序zabbix_java_gateway（需要另外安装）。以及web前端组件和数据存储系统。 zabbix_agentd 被监控端守护进程，监控本地资源和应用，将收集数据（CPU负载、内存、硬盘使用情况等）汇报给Zabbix Server。agentd并不是必须的，因为zabbix系统支持众多的监控数据采集方法，通过被监控设备代理采集监控数据只是其中的一种方法。 zabbix_get zabbix工具，单独使用的命令，通常在server或proxy端执行，用于获取被监控端数据，通常用于排错。 zabbix_sender zabbix工具，单独使用的命令，发送数据给server或proxy端，通常用于耗时较长的check，并且与trapper配合使用。生产环境中，个别消耗时间较长的check经常导致zabbix超时，于是我们在脚本执行完后，使用sender主动提交数据。 zabbix_server 服务端守护进程，zabbix_agentd、zabbix_get、zabbix_sender、zabbix_proxy、zabbix_java_gateway的数据最终都提交到server端。负责所有监控设备和监控项目配置、数据的存储与报表的生成和展示、报警的发送等。（数据不都是主动提交给server，多数情况下都是server主动去获取数据） zabbix_proxy zabbix代理守护进程，功能和server类似。唯一不同的是它只是一个中转站，需要把收集到的数据提交/被提交到server端。一般跨机房、地区的环境需要用到proxy。可以减轻Zabbix Server的压力。 zabbix_java_gateway Java网关，zabbix2.0之后引入的一个功能。类似与agentd，但只用于Java方面。需要特别注意的是，它只能主动去获取数据，而不能被动获取数据。它的数据最终会提交给server或proxy。 Web前端组件 通过Web界面进行管理和维护操作。 数据存储系统 所有被监控主机和被监控项目的配置信息以及系统所采集的所有监控数据都存储在数据库中。 Zabbix 环境需求软硬件需求 内存和磁盘 基本需求：128M内存、256M硬盘。硬盘需要考虑的问题：监控条目越多、历史记录保留时间越久数据库将会越大。100台server，做基本的CPU、内存、硬盘、网卡流量等监控，建议硬盘空间80GB CPU 由Zabbix数据库使用情况而定，如果监控条目越多，选择的CPU应该越好 其他硬件 如果有必要的话，可准备GSM短信猫 硬件配置样例 Name Platform CPU/Memory Database Monitored hosts Small CentOS Virtual Appliance MySQL InnoDB 100 Medium CentOS 2 CPU cores/2GB MySQL InnoDB 500 Large RedHat Enterprise Linux 4 CPU cores/8GB RAID10 MySQL InnoDB or PostgreSQL &gt;1000 Very large RedHat Enterprise Linux 8 CPU cores/16GB Fast RAID10 MySQL InnoDB or PostgreSQL &gt;10000 支持的平台 Linux IBM AIX FreeBSD NetBSD OpenBSD HP-UX Mac OS X Solaris Windows: all desktop and server versions since 2000 (Zabbix agent only) 软件需求 数据库 Software Version MySQL 5.0.3 or later Oracle 10g or later PostgreSQL 8.1 or later SQLite 3.3.5 or later IBM DB2 9.7 or later 前端 软件 版本 可选/必须 Apache 1.3.12 or later PHP 5.4.0 or later gd 2.0 or later PHP GD 扩展 必须支持 PNG (–with-png-dir), JPEG (–with-jpeg-dir) 和 FreeType 2 (–with-freetype-dir). bcmath php必须，php-bcmath (–enable-bcmath) ctype php必须，php-ctype (–enable-ctype) libXML 2.6.15 or later php必须 xmlreader php必须 xmlwriter php必须 session php必须 sockets php必须，php-net-socket (–enable-sockets) mbstring php必须，php-mbstring (–enable-mbstring) gettext php必须，php-gettext (–with-gettext). ldap php可选 ibm_db2 可选，如果 IBM DB2 作为zabbix后端数据库则需要 mysqli 推荐，如果 MySQL 作为zabbix后端数据库则需要 oci8 可选，如果 Oracle 作为zabbix后端数据库则需要 pgsql 可选，如果 PostgreSQL 作为zabbix后端数据库则需要 sqlite3 可选，如果 SQLite 作为zabbix后端数据库则需要 服务器以下内容都为可选项，如果你需要监控特定项，安装特定支持即可。 OpenIPMI：IPMI硬件监控 libssh2：版本1.0以上，监控ssh服务 fping：icmp监控项 libcurl：监控web项. libiksemel：支持jabber报警 net-snmp：增加SNMP支持 Java网关如果你需要通过Java网关来监控你的Java进程，那么你需要增加如下支持 包名 地址 兼容性 logback-core-0.9.27.jar http://logback.qos.ch/ 0.9.27, 1.0.13, and 1.1.1已测试 logback-classic-0.9.27.jar http://logback.qos.ch/ 0.9.27, 1.0.13, and 1.1.1.已测试 slf4j-api-1.6.1.jar http://logback.qos.ch/ 1.6.1, 1.6.6, and 1.7.6.已测试 android-json-4.3_r3.1.jar https://android.googlesource.com/platform/libcore/+/master/json 2.3.3_r1.1 and 4.3_r3.1已测试 数据库硬盘容量计算 每秒处理的数据量 这里的每秒只是一个平均值，例如：3000个监控项，均为60秒刷新一次，那么平均每秒有50（3000/60）个数据要处理。也就是说每秒有50条数据要存储到MySQL（或其他数据库）中。 历史记录保存时间 一般情况下，zabbix监控项值都要存储到数据库中，并且保留一段时间。假如一个数据需要保存30天，而且每秒有50个值要保存，这30天要存储129 600 000（300 * 24小时 * 3600秒 * 50）个值 一条记录需要多少容量：容量由当前使用的数据库引擎和存储的数据类型（浮点型、整型、字符型等）共同决定。通常，一条记录需要占用大约50个字节，这个案例中129 600 000个记录大约需要（129 600 000 * 50）6.5GB的硬盘空间 趋势数据保存时间 什么是趋势数据？当查看一周或一月的图标，图表上看到的 MAX / MIN / AVG / COUNT / 都是取自趋势数据，趋势数据一小时获取一次。通常，一条趋势数据大约占用128字节，如果需要保存5年的趋势数据，3000个监控项每年需要2.4GB（3000 个 * 24小时 * 365天 * 128字节），5年共16.8GB。 事件记录保存时间 报警、警告、恢复等事件。一个事件大概占用130个字节，通常情况下不会有太多的事件，除非运维做的很糟糕，或者运维要求太严格，把阈值调的很低。如果每秒有一个事件发生，那么一年事件记录占用的数据空间为： （1天 * 365天 * 24小时 * 3600秒 * 130字节） 大约4.1G空间。 数据库空间计算公式 zabbix配置占用：固定大小，一般 &lt; 10MB 历史数据：天数 *（监控项总数 / 更新频率）* 24小时 * 3600秒 * 50字节 趋势数据：天数 *（监控项总数 / 3600）* 24 小时 * 3600秒 * 128 字节 事件数据：天数 * 事件个数（大概值）* 24 小时 * 3600 秒 * 130 字节 Zabbix部署前提：时间同步 12*/2 * * * * root /usr/sbin/ntpdate time.nist.gov 1&gt;/dev/null 2&gt;&amp;1# 加入计划任务 12yum -y groupinstall "Compatibility libraries" "Development tools" "Server Platform Development"# 解决依赖关系，安装开发环境软件包组 部署LNMPLinux：CentOS 6.8Nginx：1.11.12MySQL：5.6.35PHP：5.6.30 Zabbix：3.2.4-1 zabbix-agent-3.2.4-1 zabbix-get-3.2.4-1 zabbix-sender-3.2.4-1 zabbix-server-mysql-3.2.4-1 zabbix-web-3.2.4-1 zabbix-web-mysql-3.2.4-1 安装MySQL123456789101112131415161718192021222324252627282930313233343536373839404142434445yum -y install autoconf automake imake libxml2-devel expat-devel cmake gcc gcc-c++ libaio libaio-devel bzr bison libtool ncurses5-devel # 解决依赖关系，安装所需环境cdwget http://mirrors.sohu.com/mysql/MySQL-5.6/mysql-5.6.35-linux-glibc2.5-x86_64.tar.gztar xf mysql-5.6.35-linux-glibc2.5-x86_64.tar.gz -C /usr/local/# 下载解压groupadd -r mysqluseradd -g mysql -r -s /sbin/nologin -M mysql# 创建用户和组ln -sv /usr/local/mysql-5.6.35-linux-glibc2.5-x86_64/ /usr/local/mysql# 创建软连接chown -R mysql.mysql /usr/local/mysql/# 属主、数组修改install -cdv /datachown mysql.mysql /data/# 创建数据存放目录/usr/local/mysql/scripts/mysql_install_db \--basedir=/usr/local/mysql \--datadir=/data/ --user=mysql# 初始化数据库cp /usr/local/mysql/support-files/my-default.cnf /etc/my.cnf # 创建配置文件sed -ri '/\[mysqld\]/adatadir=/data' /etc/my.cnf # 指定mysql数据文件的存放位置# thread_concurrency = 2sed -ri "sS(thread_concurrency =).*S\1 $(( `/bin/egrep -cw "processor" /proc/cpuinfo ` * 2 ))S" /etc/my.cnf # 修改此文件中thread_concurrency的值为你的CPU个数乘以2cp /usr/local/mysql/support-files/mysql.server /etc/rc.d/init.d/mysqld# 修改 datadir=/data# 创建服务脚本chkconfig --add mysqld chkconfig mysqld onservice mysqld start# 启动服务 报错解答 https://icesquare.com/wordpress/mysql-starting-mysql-error-the-server-quit-without-updating-pid-file/ 12345678910111213141516171819202122232425262728293031netstat -tunlp | grep 3306# 验证# 为了使用mysql的安装符合系统使用规范，并将其开发组件导出给系统使用，这里做如下配置# 输出mysql的man手册至man命令的查找路径# 编辑/etc/man.config，添加如下行即可：MANPATH /usr/local/mysql/manecho 'export PATH=/usr/local/mysql/bin:$PATH' &gt;| /etc/profile.d/mysqlbin.sh. /etc/profile.d/mysqlbin.sh# 修改PATH环境变量，让系统可以直接使用mysql的相关命令ln -sv /usr/local/mysql/include/ /usr/include/mysql# 输出mysql的头文件至系统头文件路径/usr/includeecho '/usr/local/mysql/lib/' &gt; /etc/ld.so.conf.d/mysqllib.conf# 输出mysql的库文件给系统库查找路径ldconfig# 让系统重新载入系统库ldconfig -p | grep mysqlmysql&gt; use mysql;mysql&gt; select user,host,password from user;mysql&gt; drop user ''@'localhost';mysql&gt; drop user ''@'test';mysql&gt; update user set password=password('hehedada') where user='root';mysql&gt; flush privileges;# 删除匿名用户，修改密码mysql -u root -P 3306 -h 127.0.0.1 -p# 测试 安装Nginx123456789101112131415161718192021222324252627282930313233343536yum -y install pcre-devel zlib-devel openssl-devel# 解决依赖关系，安装所需环境groupadd -r nginxuseradd -r -g nginx -s /bin/false -M nginx# 添加用户nginx，实现以之运行nginx服务进程cdwget http://nginx.org/download/nginx-1.11.12.tar.gztar xf nginx-1.11.12.tar.gz # 下载解压cd nginx-1.11.12./configure \--prefix=/usr/local/nginx \--sbin-path=/usr/local/nginx/sbin/nginx \--conf-path=/usr/local/nginx/conf/nginx.conf \--error-log-path=/usr/local/nginx/logs/error.log \--http-log-path=/usr/local/nginx/logs/access.log \--pid-path=/usr/local/nginx/logs/nginx.pid \--lock-path=/usr/local/nginx/logs/nginx.lock \--user=nginx \--group=nginx \--with-http_ssl_module \--with-http_flv_module \--with-http_stub_status_module \--with-http_gzip_static_module \--http-client-body-temp-path=/usr/local/nginx/tmp/client_body_temp \--http-proxy-temp-path=/usr/local/nginx/tmp/proxy_temp \--http-fastcgi-temp-path=/usr/local/nginx/tmp/fastcgi_temp \--http-uwsgi-temp-path=/usr/local/nginx/tmp/uwsgi_temp \--http-scgi-temp-path=/usr/local/nginx/tmp/scgi_temp \--with-pcre | tee -a /tmp/nginx_configure.log# 编译前配置make &amp;&amp; make install# 编译安装 123456789101112/usr/local/nginx/sbin/nginx -h# 查看使用帮助/usr/local/nginx/sbin/nginx -t# 配置检查# nginx: [emerg] mkdir() "/usr/local/nginx/tmp/client_body_temp" failed (2: No such file or directory)# 指定的目录未创建，需要手动创建mkdir -pv /usr/local/nginx/tmp/# nginx: [emerg] getpwnam("nginx") failed# 检查nginx的用户名和组是否创建 为nginx提供SysV init脚本，根据具体配置修改脚本内容/etc/rc.d/init.d/nginx 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#!/bin/sh## nginx - this script starts and stops the nginx daemon## chkconfig: - 85 15 # description: Nginx is an HTTP(S) server, HTTP(S) reverse \# proxy and IMAP/POP3 proxy server# processname: nginx# config: /usr/local/nginx/conf/nginx.conf# config: /etc/sysconfig/nginx# pidfile: /usr/local/nginx/logs/nginx.pid # Source function library.. /etc/rc.d/init.d/functions # Source networking configuration.. /etc/sysconfig/network # Check that networking is up.[ "$NETWORKING" = "no" ] &amp;&amp; exit 0 nginx="/usr/local/nginx/sbin/nginx"# nginx命令路径prog=$(basename $nginx) NGINX_CONF_FILE=" /usr/local/nginx/conf/nginx.conf"# nginx配置文件路径[ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginx lockfile=/usr/local/nginx/logs/nginx.lock # lock文件路径 make_dirs() &#123; # make required directories user=`$nginx -V 2&gt;&amp;1 | /bin/fgrep 'configure arguments' | /bin/sed -r 'sS[^*]*--user=([^ ]*).*S\1Sg' -` options=`$nginx -V 2&gt;&amp;1 | /bin/fgrep 'configure arguments:'` for opt in $options; do if [ `echo $opt | grep '.*-temp-path'` ]; then value=`echo $opt | cut -d "=" -f 2` if [ ! -d "$value" ]; then # echo "creating" $value mkdir -p $value &amp;&amp; chown -R $user $value fi fi done&#125; start() &#123; [ -x $nginx ] || exit 5 [ -f $NGINX_CONF_FILE ] || exit 6 make_dirs echo -n $"Starting $prog: " daemon $nginx -c $NGINX_CONF_FILE retval=$? echo [ $retval -eq 0 ] &amp;&amp; touch $lockfile return $retval&#125; stop() &#123; echo -n $"Stopping $prog: " killproc $prog -QUIT retval=$? echo [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile return $retval&#125; restart() &#123; configtest || return $? stop sleep 1 start&#125; reload() &#123; configtest || return $? echo -n $"Reloading $prog: " killproc $nginx -HUP RETVAL=$? echo&#125; force_reload() &#123; restart&#125; configtest() &#123; $nginx -t -c $NGINX_CONF_FILE&#125; rh_status() &#123; status $prog&#125; rh_status_q() &#123; rh_status &gt;/dev/null 2&gt;&amp;1&#125; case "$1" in start) rh_status_q &amp;&amp; exit 0 $1 ;; stop) rh_status_q || exit 0 $1 ;; restart|configtest) $1 ;; reload) rh_status_q || exit 7 $1 ;; force-reload) force_reload ;; status) rh_status ;; condrestart|try-restart) rh_status_q || exit 0 ;; *) echo $"Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;" exit 2esac 12345678chmod +x /etc/rc.d/init.d/nginxchkconfig --add nginxchkconfig nginx onservice nginx start# 服务启动netstat -tunlp | grep :80# 验证 安装phpMcrypt是PHP的一个扩展，完成了常用加密算法的封装。其实该扩展是对mcrypt标准类库的封装，mcrypt完成了相当多的常用加密算法，如DES, TripleDES, Blowfish (default), 3-WAY, SAFER-SK64, SAFER-SK128, TWOFISH, TEA, RC2 和 GOST加密算法，并且提供了CBC、OFB、CFB 和 ECB 四种块加密的模型。要使用该扩展，必须首先安装mcrypt标准类库，注意的是mcrypt软件依赖libmcrypt和mhash两个库。 环境和库 1234yum -y groupinstall "Desktop Platform Development" # 桌面平台环境，开发所需yum -y install zlib-devel libxml2-devel libjpeg-devel libjpeg-turbo-devel libiconv-devel libmcrypt-devel mhash mcrypt freetype-devel libpng-devel gd-devel libcurl-devel libxslt-devel libxslt-devel openssl-devel bzip2 bzip2-devel# 依赖库安装 libmcrypt（安装mcrypt需要此软件包） 123456cdwget http://nchc.dl.sourceforge.net/project/mcrypt/Libmcrypt/2.5.8/libmcrypt-2.5.8.tar.gztar xf libmcrypt-2.5.8.tar.gzcd libmcrypt-2.5.8./configure --prefix=/usr/local/make &amp;&amp; make install mhash（安装mcrypt需要此软件包） 123456cdwget https://nchc.dl.sourceforge.net/project/mhash/mhash/0.9.9.9/mhash-0.9.9.9.tar.gztar xf mhash-0.9.9.9.tar.gz cd mhash-0.9.9.9./configure --prefix=/usr/local/make &amp;&amp; make install mcrypt扩展 12345678910111213141516171819cdwget https://ncu.dl.sourceforge.net/project/mcrypt/MCrypt/2.6.8/mcrypt-2.6.8.tar.gztar xf mcrypt-2.6.8.tar.gzln -s /usr/local/bin/libmcrypt-config /usr/bin/libmcrypt_config# 添加链接，以免libmcrypt未搜索到echo -e '/usr/local/lib' &gt; /etc/ld.so.conf.d/libmcrypt_lg.confldconfig# 添加库搜索路径export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH# 由于在配置Mcrypt时，会找不到libmcrypt的链接库，导致无法编译# 因为Libmcrypt的链接库在/usr/local/lib文件夹下。# 因此在配置mcrypt时要加入LD_LIBRARY_PATH=/usr/local/lib导入键接库cd mcrypt-2.6.8./configure --prefix=/usr/local/mcrypt make &amp;&amp; make install 编译安装php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849cdwget http://cn.php.net/distributions/php-5.4.27.tar.bz2tar xf php-5.4.27.tar.bz2 cd php-5.4.27# 添加库链接ln -sv /usr/local/mysql/lib/libmysqlclient.so.18 /usr/lib64/./configure --prefix=/usr/local/php5.6.30 \--with-mysql=/usr/local/mysql \--with-mysqli=/usr/local/mysql/bin/mysql_config \--without-pdo-sqlite \--without-sqlite3 \--with-freetype-dir \--with-jpeg-dir \--with-png-dir \--with-zlib \--enable-xml \--with-libxml-dir=/usr \--disable-rpath \--enable-bcmath \--enable-shmop \--enable-sysvsem \--enable-inline-optimization \--with-curl \--enable-mbregex \--enable-mbstring \--enable-sockets \--with-mcrypt=/usr/local/mcrypt \--with-mhash \--with-config-file-path=/etc \--with-gd \--enable-gd-native-ttf \--with-openssl \--enable-pcntl \--with-xmlrpc \--enable-zip \--enable-soap \--enable-short-tags \--enable-static \--with-config-file-scan-dir=/etc/php.d \--with-bz2 \--with-xsl \--enable-fpm \--with-fpm-user=nginx \--with-fpm-group=nginx \--with-gettext \--enable-ftp | tee -a /tmp/php_install.logmake &amp;&amp; make install 说明 如果使用PHP5.3以上版本，为了链接MySQL数据库，可以指定mysqlnd，这样在本机就不需要先安装MySQL或MySQL开发包了。mysqlnd从php 5.3开始可用，可以编译时绑定到它（而不用和具体的MySQL客户端库绑定形成依赖），但从PHP 5.4开始它就是默认设置了。 如果MySQL和PHP不在一台主机，使用with-mysql时，都直接指定为mysqlnd，表示MySQL不在本机，而是在另外的其他主机上./configure --with-mysql=mysqlnd --with-pdo-mysql=mysqlnd --with-mysqli=mysqlnd 123456789101112131415161718192021ln -sv /usr/local/php5.6.30/ /usr/local/php# 添加链接echo 'export PATH=/usr/local/php/bin:/usr/local/php/sbin:$PATH' &gt; /etc/profile.d/php.shsource /etc/profile.d/php.sh# 添加环境变量cp /root/php-5.4.27/php.ini-production /usr/local/php/lib/php.inicp /root/php-5.4.27/php.ini-production /etc/php.ini# 生成php配置文件cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf# 创建php-fpm服务程序的配置文件cp /root/php-5.4.27/sapi/fpm/init.d.php-fpm /etc/rc.d/init.d/php-fpm# 创建服务脚本chmod +x /etc/rc.d/init.d/php-fpmchkconfig --add php-fpmchkconfig php-fpm on# 添加服务 配置php-fpm，并启用pid文件 1vim /usr/local/php/etc/php-fpm.conf 123456789101112pm.max_children = 50# 最大子进程数pm.start_servers = 5# 程序启动时启动的子进程数pm.min_spare_servers = 2# 最小空闲进程数pm.max_spare_servers = 8# 最大空闲进程数pid = /usr/local/php/var/run/php-fpm.pid# pid文件路径（和php-fpm服务脚本中pid保持一致）error_log = log/php-fpm.log# 启用记录错误日志 服务验证 12345678service php-fpm start# 启动服务# 使用如下命令来验正（如果此命令输出有中几个php-fpm进程就说明启动成功了）：ps aux | grep php-fpmnetstat -tnlp | grep php-fpm# 默认情况下，fpm监听在127.0.0.1的9000端口，也可以使用如下命令验正其是否已经监听在相应的套接字。 部署Zabbix-server123yum install -y epel-releaseyum -y install mysql-devel postgresql-devel net-snmp-devel net-snmp-libs openldap-devel gnutls-devel sqlite-devel unixODBC-devel OpenIPMI-devel libssh2-devel java-devel iksemel-devel curl-devel libxml2-devel# 依赖库安装 12345678910wget https://mirrors.aliyun.com/zabbix/zabbix/3.2/rhel/6/x86_64/zabbix-agent-3.2.4-1.el6.x86_64.rpmwget https://mirrors.aliyun.com/zabbix/zabbix/3.2/rhel/6/x86_64/zabbix-get-3.2.4-1.el6.x86_64.rpmwget https://mirrors.aliyun.com/zabbix/zabbix/3.2/rhel/6/x86_64/zabbix-sender-3.2.4-1.el6.x86_64.rpmwget https://mirrors.aliyun.com/zabbix/zabbix/3.2/rhel/6/x86_64/deprecated/zabbix-server-mysql-3.2.4-1.el6.x86_64.rpmwget https://mirrors.aliyun.com/zabbix/zabbix/3.2/rhel/6/x86_64/deprecated/zabbix-web-3.2.4-1.el6.noarch.rpmwget https://mirrors.aliyun.com/zabbix/zabbix/3.2/rhel/6/x86_64/deprecated/zabbix-web-mysql-3.2.4-1.el6.noarch.rpm# 手动下载rpm包yum localinstall zabbix-server-mysql-3.2.4-1.el6.x86_64.rpm zabbix-get-3.2.4-1.el6.x86_64.rpm zabbix-web-3.2.4-1.el6.noarch.rpm zabbix-web-mysql-3.2.4-1.el6.noarch.rpm# 使用yum进行本地安装 报错解决 12345678Error: Package: zabbix-server-mysql-3.2.4-1.el6.x86_64 (/zabbix-server-mysql-3.2.4-1.el6.x86_64) Requires: libiksemel.so.3()(64bit)Error: Package: zabbix-server-mysql-3.2.4-1.el6.x86_64 (/zabbix-server-mysql-3.2.4-1.el6.x86_64) Requires: fping# 解决方法yum install -y epel-releaseyum -y install iksemel fping 旧版本的安装 1234567# 安装zabbix3.0所需要EPEL源和zabbix的yum源，如下：rpm -ivh http://mirrors.aliyun.com/epel/7/x86_64/e/epel-release-7-8.noarch.rpmrpm -ivh http://repo.zabbix.com/zabbix/3.0/rhel/7/x86_64/zabbix-release-3.0-1.el7.noarch.rpm#以上安装完毕后，我们现在来正式安装zabbix3.0，使用如下命令：yum -y install zabbix-server-mysql zabbix-web-mysql zabbix-get 参考：https://pkgs.org/download/libiksemel.so.3()(64bit) 数据库优化1234567install -cdv /var/lib/mysqltouch /usr/local/mysql/mysql.sockln -sv /usr/local/mysql/mysql.sock /tmp/ln -sv /usr/local/mysql/mysql.sock /var/lib/mysql/mysql.sock chown -R mysql:mysql /var/lib/mysqlvim /etc/my.cnf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159[client][mysql]#这个配置段设置启动MySQL服务的条件；在这种情况下，no-auto-rehash确保这个服务启动得比较快。no-auto-rehash[mysqld]user = mysql port = 3306 socket = /usr/local/mysql/mysql.sockbasedir = /usr/local/mysql datadir = /dataopen_files_limit = 10240back_log = 600 # 在MYSQL暂时停止响应新请求之前，短时间内的多少个请求可以被存在堆栈中。如果系统在短时间内有很多连接，则需要增大该参数的值，该参数值指定到来的TCP/IP连接的监听队列的大小。默认值80。max_connections = 800 # MySQL允许最大的进程连接数，如果经常出现Too Many Connections的错误提示，则需要增大此值。默认151max_connect_errors = 3000 # 设置每个主机的连接请求异常中断的最大次数，当超过该次数，MYSQL服务器将禁止host的连接请求，直到mysql服务器重启或通过flush hosts命令清空此host的相关信息。默认100external-locking = FALSE # 使用–skip-external-locking MySQL选项以避免外部锁定。该选项默认开启max_allowed_packet = 8M # 设置在网络传输中一次消息传输量的最大值。系统默认值 为4MB，最大值是1GB，必须设置1024的倍数。#sort_buffer_size = 2M # Sort_Buffer_Size 是一个connection级参数，在每个connection（session）第一次需要使用这个buffer的时候，一次性分配设置的内存。# Sort_Buffer_Size 并不是越大越好，由于是connection级的参数，过大的设置+高并发可能会耗尽系统内存资源。例如：500个连接将会消耗 500*sort_buffer_size(8M)=4G内存#Sort_Buffer_Size 超过2KB的时候，就会使用mmap() 而不是 malloc() 来进行内存分配，导致效率降低。 系统默认2M，使用默认值即可#join_buffer_size = 2M # 用于表间关联缓存的大小，和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。系统默认2M，使用默认值即可thread_cache_size = 100 # 默认38# 服务器线程缓存这个值表示可以重新利用保存在缓存中线程的数量,当断开连接时如果缓存中还有空间,那么客户端的线程将被放到缓存中,如果线程重新被请求，那么请求将从缓存中读取,如果缓存中是空的或者是新的请求，那么这个线程将被重新创建,如果有很多新的线程，增加这个值可以改善系统性能.通过比较 Connections 和 Threads_created 状态的变量，可以看到这个变量的作用。设置规则如下：1GB 内存配置为8，2GB配置为16，3GB配置为32，4GB或更高内存，可配置更大。#thread_concurrency = 2 #系统默认为10，使用10先观察# 设置thread_concurrency的值的正确与否, 对mysql的性能影响很大, 在多个cpu(或多核)的情况下，错误设置了thread_concurrency的值, 会导致mysql不能充分利用多cpu(或多核), 出现同一时刻只能一个cpu(或核)在工作的情况。thread_concurrency应设为CPU核数的2倍. 比如有一个双核的CPU, 那么thread_concurrency的应该为4; 2个双核的cpu, thread_concurrency的值应为8query_cache_size = 2M # 在MyISAM引擎优化中，这个参数也是一个重要的优化参数。但也爆露出来一些问题。机器的内存越来越大，习惯性把参数分配的值越来越大。这个参数加大后也引发了一系列问题。我们首先分析一下 query_cache_size的工作原理：一个SELECT查询在DB中工作后，DB会把该语句缓存下来，当同样的一个SQL再次来到DB里调用时，DB在该表没发生变化的情况下把结果从缓存中返回给Client。这里有一个关建点，就是DB在利用Query_cache工作时，要求该语句涉及的表在这段时间内没有发生变更。那如果该表在发生变更时，Query_cache里的数据又怎么处理呢？首先要把Query_cache和该表相关的语句全部置为失效，然后在写入更新。那么如果Query_cache非常大，该表的查询结构又比较多，查询语句失效也慢，一个更新或是Insert就会很慢，这样看到的就是Update或是Insert怎么这么慢了。所以在数据库写入量或是更新量也比较大的系统，该参数不适合分配过大。而且在高并发，写入量大的系统，建议把该功能禁掉。query_cache_limit = 4M #指定单个查询能够使用的缓冲区大小，缺省为1Mquery_cache_min_res_unit = 1M # 默认是4KB，设置值大对大数据查询有好处，但如果你的查询都是小数据查询，就容易造成内存碎片和浪费# 查询缓存碎片率 = Qcache_free_blocks / Qcache_total_blocks * 100%# 如果查询缓存碎片率超过20%，可以用FLUSH QUERY CACHE整理缓存碎片，或者试试减小query_cache_min_res_unit，如果你的查询都是小数据量的话。# 查询缓存利用率 = (query_cache_size – Qcache_free_memory) / query_cache_size * 100%# 查询缓存利用率在25%以下的话说明query_cache_size设置的过大，可适当减小;查询缓存利用率在80%以上而且Qcache_lowmem_prunes &gt; 50的话说明query_cache_size可能有点小，要不就是碎片太多。# 查询缓存命中率 = (Qcache_hits – Qcache_inserts) / Qcache_hits * 100%#default-storage-engine = MyISAM#default_table_type = InnoDB # 开启失败#thread_stack = 192K # 设置MYSQL每个线程的堆栈大小，默认值足够大，可满足普通操作。可设置范围为128K至4GB，默认为256KB，使用默认观察transaction_isolation = READ-COMMITTED # 设定默认的事务隔离级别.可用的级别如下:READ UNCOMMITTED-读未提交 READ COMMITTE-读已提交 REPEATABLE READ -可重复读 SERIALIZABLE -串行tmp_table_size = 2M # tmp_table_size 的默认大小是 32M。如果一张临时表超出该大小，MySQL产生一个 The table tbl_name is full 形式的错误，如果你做很多高级 GROUP BY 查询，增加 tmp_table_size 值。如果超过该值，则会将临时表写入磁盘。max_heap_table_size = 2Mexpire_logs_days = 7 key_buffer_size = 16M # 批定用于索引的缓冲区大小，增加它可以得到更好的索引处理性能，对于内存在4GB左右的服务器来说，该参数可设置为256MB或384MB。read_buffer_size = 1M # 默认128K# MySql读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySql会为它分配一段内存缓冲区。read_buffer_size变量控制这一缓冲区的大小。如果对表的顺序扫描请求非常频繁，并且你认为频繁扫描进行得太慢，可以通过增加该变量值以及内存缓冲区大小提高其性能。和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。read_rnd_buffer_size = 1M # MySql的随机读（查询操作）缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySql会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySql会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。bulk_insert_buffer_size = 1M #批量插入数据缓存大小，可以有效提高插入效率，默认为8Mmyisam_sort_buffer_size = 1M # MyISAM表发生变化时重新排序所需的缓冲 默认8Mmyisam_max_sort_file_size = 10G # MySQL重建索引时所允许的最大临时文件的大小 (当 REPAIR, ALTER TABLE 或者 LOAD DATA INFILE).# 如果文件大小比此值更大,索引会通过键值缓冲创建(更慢)#myisam_max_extra_sort_file_size = 10G # 5.6无此值设置#myisam_repair_threads = 1 默认为1# 如果一个表拥有超过一个索引, MyISAM 可以通过并行排序使用超过一个线程去修复他们.# 这对于拥有多个CPU以及大量内存情况的用户,是一个很好的选择.myisam_recover # 自动检查和修复没有适当关闭的 MyISAM 表skip-name-resolve lower_case_table_names = 1 server-id = 1innodb_additional_mem_pool_size = 6M # 这个参数用来设置 InnoDB 存储的数据目录信息和其它内部数据结构的内存池大小，类似于Oracle的library cache。这不是一个强制参数，可以被突破。innodb_buffer_pool_size = 32M # 这对Innodb表来说非常重要。Innodb相比MyISAM表对缓冲更为敏感。MyISAM可以在默认的 key_buffer_size 设置下运行的可以，然而Innodb在默认的 innodb_buffer_pool_size 设置下却跟蜗牛似的。由于Innodb把数据和索引都缓存起来，无需留给操作系统太多的内存，因此如果只需要用Innodb的话则可以设置它高达 70-80% 的可用内存。一些应用于 key_buffer 的规则有 — 如果你的数据量不大，并且不会暴增，那么无需把 innodb_buffer_pool_size 设置的太大了#innodb_data_file_path = ibdata1:1024M:autoextend 设置过大导致报错，默认12M观察# 表空间文件 重要数据#innodb_file_io_threads = 4 # 不明确，使用默认值# 文件IO的线程数，一般为 4，但是在 Windows 下，可以设置得较大。innodb_thread_concurrency = 4#服务器有几个CPU就设置为几，建议用默认设置，一般为8.innodb_flush_log_at_trx_commit = 2 # 如果将此参数设置为1，将在每次提交事务后将日志写入磁盘。为提供性能，可以设置为0或2，但要承担在发生故障时丢失数据的风险。设置为0表示事务日志写入日志文件，而日志文件每秒刷新到磁盘一次。设置为2表示事务日志将在提交时写入日志，但日志文件每次刷新到磁盘一次。#innodb_log_buffer_size = 16M # 使用默认8M# 此参数确定些日志文件所用的内存大小，以M为单位。缓冲区更大能提高性能，但意外的故障将会丢失数据.MySQL开发人员建议设置为1－8M之间#innodb_log_file_size = 128M # 使用默认48M# 此参数确定数据日志文件的大小，以M为单位，更大的设置可以提高性能，但也会增加恢复故障数据库所需的时间#innodb_log_files_in_group = 3 # 使用默认2#为提高性能，MySQL可以以循环方式将日志文件写到多个文件。推荐设置为3M#innodb_max_dirty_pages_pct = 90 # 使用默认75观察# Buffer_Pool中Dirty_Page所占的数量，直接影响InnoDB的关闭时间。参数innodb_max_dirty_pages_pct 可以直接控制了Dirty_Page在Buffer_Pool中所占的比率，而且幸运的是innodb_max_dirty_pages_pct是可以动态改变的。所以，在关闭InnoDB之前先将innodb_max_dirty_pages_pct调小，强制数据块Flush一段时间，则能够大大缩短 MySQL关闭的时间。innodb_lock_wait_timeout = 120 # 默认为50秒 # InnoDB 有其内置的死锁检测机制，能导致未完成的事务回滚。但是，如果结合InnoDB使用MyISAM的lock tables 语句或第三方事务引擎,则InnoDB无法识别死锁。为消除这种可能性，可以将innodb_lock_wait_timeout设置为一个整数值，指示 MySQL在允许其他事务修改那些最终受事务回滚的数据之前要等待多长时间(秒数)innodb_file_per_table = 0 # 默认为No# 独享表空间（关闭）[mysqldump]quick # max_allowed_packet = 32M[mysqld_safe]log-error=/data/mysqld.errpid-file=/data/mysqld.pidsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES 报错解决： 1service mysqld restart 1234ERROR! The server quit without updating PID file (/data/zabbix.pid).# 1 配置文件my.cnf中的pid-file的路径最好是datadir目录下的和主机名相同的文件# 2 读取错误日志文件分析问题# 3 不丢失数据的情况下， 尝试 pkill -9 mysqld，然后重新启动服务，多尝试几次 为zabbix创建数据库123456789101112131415161718192021222324252627shell&gt; mysql -u root -h localhost -pmysql&gt; show variables like '%char%';+--------------------------+---------------------------------------------------------------+| Variable_name | Value |+--------------------------+---------------------------------------------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | latin1 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | latin1 || character_set_system | utf8 || character_sets_dir | /usr/local/mysql-5.6.35-linux-glibc2.5-x86_64/share/charsets/ |+--------------------------+---------------------------------------------------------------+8 rows in set (0.00 sec)mysql&gt; create database zabbix character set utf8 collate utf8_bin; Query OK, 1 row affected (0.04 sec)mysql&gt; grant all privileges on zabbix.* to zabbix@127.0.0.1 identified by 'zabbix'; Query OK, 0 rows affected (0.03 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)mysql&gt; quitBye 导入数据库 12zcat /usr/share/doc/zabbix-server-mysql-3.2.*/create.sql.gz | mysql -umonitor -pmonitor zabbix# 注意需要指定zabbix的数据库及帐号密码 配置Nginx + PHP-fpm1vim /usr/local/nginx/conf/nginx.conf 12345678910111213user nginx;worker_processes auto;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; include extra/*.conf; # 将extra目录下的conf文件包含&#125; 12mkdir /usr/local/nginx/conf/extra/vim /usr/local/nginx/conf/extra/zabbix.conf 123456789101112131415server &#123; listen 80; server_name zabbix.test.com; root html/zabbix; location / &#123; index index.php index.html index.htm; &#125; location ~ .*\.(php|php5)?$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi.conf; &#125; access_log logs/zabbix_access.log;&#125; 1234567service nginx configtestservice nginx reloadrm /usr/local/nginx/html/*cp -ar /usr/share/zabbix/ /usr/local/nginx/html/chown -R nginx:nginx /usr/local/nginx/html/# /etc/zabbix/web/这个不给权限 nginx的errorlog会有报错chown nginx:nginx /etc/zabbix/web zabbix前端 php 参数配置1vim /usr/local/php/lib/php.ini 12345678max_execution_time = 300memory_limit = 128M post_max_size = 16Mupload_max_filesize = 2Mmax_input_time = 300always_populate_raw_post_data = -1date.timezone = Asia/Shanghai# date.timezone Europe/Riga 12cp /usr/local/php/lib/php.ini /etc/php.ini /etc/init.d/php-fpm restart zabbix-server配置1vim /etc/zabbix/zabbix_server.conf 1234567DBHost=localhostDBName=zabbixDBUser=zabbixDBPassword=zabbixDBSocket=/usr/local/mysql/mysql.sock# 如果是本机的话，一般在/tmp目录下DBPort=3306 12chkconfig --add zabbix-serverchkconfig zabbix-server on 安装zabbix的管理页面在操作连接数据库时可能会出现 1The frontend does not match Zabbix database. Current database version (mandatory/optional): 3000000/3000000. Required mandatory version: 3020000. Contact your system administrator. 遇到这种问题先确认一下zabbix配置文件中的数据库账号密码和MySQL配置的是否一致，然后需要删除一下创建的zabbix库,然后在从新导入zabbix库文件，再更新一下mandatory的版本 12345678910111213mysql&gt; use zabbix;Database changedmysql&gt; update dbversion set mandatory=3020000;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; flush privileges; Query OK, 0 rows affected (0.00 sec)mysql&gt; use mysql; Database changedmysql&gt; exitBye 默认账户Admin密码 zabbix]]></content>
      <categories>
        <category>Services</category>
      </categories>
      <tags>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL安装(通用二进制包)]]></title>
    <url>%2F2016%2F02%2F28%2F2016-02-28-114023-MySQL%E5%AE%89%E8%A3%85(%E9%80%9A%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%85)%2F</url>
    <content type="text"><![CDATA[下载站点 源码包站点：http://mirrors.sohu.com/mysql/下载链接：http://mirrors.sohu.com/mysql/MySQL-5.5/mysql-5.5.53-linux2.6-x86_64.tar.gz 源码包安装必须安装在/usr/local/下，目录名叫mysql 环境准备 1234yum -y groupinstall "Compatibility libraries" "Development tools" "Server Platform Development"# 解决依赖关系，安装开发环境软件包组yum -y install autoconf automake imake libxml2-devel expat-devel cmake gcc gcc-c++ libaio libaio-devel bzr bison libtool ncurses5-devel# 解决依赖关系，安装所需环境 添加用户和组 123groupadd -r mysqluseradd -g mysql -r -s /sbin/nologin mysql# 创建用户和组 链接和属主数组 1234567tar xf mysql-5.5.53-linux2.6-x86_64.tar.gz -C /usr/local/cd /usr/local/ln -sv mysql-5.5.53-linux2.6-x86_64 mysql# 创建软连接cd mysqlchown -R mysql.mysql /usr/local/mysql/*# 属主、数组修改 存储位置定义在/下创建一个独立分区data，用于存放数据。建议使用基于硬RAID的lvm。 123mkdir -pv /data/mydatachown -R mysql.mysql /data/mydata/# 为了便于管理，在/data/目录下创建目录为mydata作为数据库存放位置，并修改属主数组 数据库初始化 123456/usr/local/mysql/scripts/mysql_install_db --datadir=/data/mydata/ --user=mysql# 初始化系统（数据）库ls /data/mydata/# 此目录下每个目录识别为一个数据库chown -R root /usr/local/mysql/* # 属主修改回root 服务脚本 1cp /usr/local/mysql/support-files/mysql.server /etc/rc.d/init.d/mysqld 配置文件 123cp -a /usr/local/mysql/support-files/my-large.cnf /etc/my.cnf# 根据实际业务需求拷贝模版，生成配置文件vim /etc/my.cnf 123# 根据实际安装配置以下两个变量的值basedir=/usr/local/mysqldatadir=/data/mydata 环境变量 12echo 'export PATH=/usr/local/mysql/bin:$PATH' &gt; /etc/profile.d/mysqlbin.sh# 添加环境变量 服务添加和启动 123chkconfig --add mysqldchkconfig --level 2345 mysqld onservice mysqld start 导出头文件 1ln -sv /usr/local/mysql/include/ /usr/include/mysql 导出库文件 12345678ldconfig -p | fgrep mysql# 在所有已缓存的库文件中搜索mysql，可能搜到的为老版本echo '/usr/local/mysql/lib/' &gt; /etc/ld.so.conf.d/mysql_lib.conf# 添加搜索路径ldconfig# 手动链接库ldconfig -p | fgrep mysql# 检查是否成功链接 导出帮助文件 1vim /etc/man.config 12# 加入如下配置MANPATH /usr/local/mysql/man 12man mysqld# 验证 1mysql -u root -h localhost -p 客户端连接 用户名：-u Username 或 –user=Username 密码：-p string 或 –password=string 主机：-h Hostname 或 –host=Hostname 执行命令：-e 用户账号：用户@主机 客户端命令 自身执行，不需要语句终止符 \q 退出 \? 获取帮助 \g 直接将命令送到服务器端执行 \G 不再显示为表格显示，而是以列的方式显示 \c 取消命令的执行 stsauts：查询运行状态 mysql服务器端命令 需要语句终止符，通常默认为分号(;) 数据库基础语句及匿名用户删除mysql所有用户的帐号是被读进内存中完成授权的 123456help set passwordset password for 'root'@'localhost' = password('admin');set password for 'root'@'127.0.0.1' = password('admin');或update user set password=password('hehedada') where user='root';设置密码 12345678910111213141516171819202122232425show database();显示当前的默认数据库select user();显示当前用户use mysql;把mysql设为默认数据库show databases;显示所有的数据库show tables;显示默认数据库中的表desc user;查看表的表结构select user,host,password from user;drop user 'root'@'::1';drop user ''@'localhost';drop user ''@'centos6\_8';删除不安全(匿名)用户# 或set password for 'root'@127.0.0.1 = password("hehedada");# 设置密码flush privileges;# 刷新权限]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基础]]></title>
    <url>%2F2016%2F02%2F27%2F2016-02-27-215624-MySQL%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[MySQL是什么？MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 最流行的关系型数据库管理系统，在 WEB 应用方面MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。 MySQL是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，它分为社区版和商业版，其体积小、速度快、总体拥有成本低，并且开源. MySQL的特性 使用 C和 C++编写，并使用了多种编译器进行测试，保证了源代码的可移植性。 支持 AIX、FreeBSD、HP-UX、Linux、Mac OS、NovellNetware、OpenBSD、OS/2 Wrap、Solaris、Windows等多种操作系统。 为多种编程语言提供了 API。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby,.NET和 Tcl 等。 支持多线程，充分利用 CPU 资源。 优化的 SQL查询算法，有效地提高查询速度。 既能够作为一个单独的应用程序应用在客户端服务器网络环境中，也能够作为一个库而嵌入到其他的软件中。 提供多语言支持，常见的编码如中文的 GB 2312、BIG5，日文的 Shift_JIS等都可以用作数据表名和数据列名。 提供 TCP/IP、ODBC 和 JDBC等多种数据库连接途径。 提供用于管理、检查、优化数据库操作的管理工具。 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。 支持多种存储引擎。 MySQL 是开源的，所以你不需要支付额外的费用。 MySQL 使用标准的 SQL数据语言形式。 MySQL 对 PHP 有很好的支持，PHP是目前最流行的 Web 开发语言。 MySQL是可以定制的，采用了 GPL协议，你可以修改源码来开发自己的 MySQL 系统。 在线 DDL/更改功能，数据架构支持动态应用程序和开发人员灵活性（5.6新增） 复制全局事务标识，可支持自我修复式集群（5.6新增） 复制无崩溃从机，可提高可用性（5.6新增） 复制多线程从机，可提高性能（5.6新增） 3倍更快的性能（5.7新增） 新的优化器（5.7新增） 原生JSON支持（5.7新增） 多源复制（5.7新增） GIS的空间扩展（5.7新增）存储引擎 MyISAM MySQL 5.0 之前的默认数据库引擎，最为常用。拥有较高的插入，查询速度，但不支持事务. InnoDB事务型数据库的首选引擎，支持ACID事务，支持行级锁定, MySQL 5.5 起成为默认数据库引擎. BDB源 自 Berkeley DB，事务型数据库的另一种选择，支持Commit 和Rollback 等其他事务特性 Memory所有数据置于内存的存储引擎，拥有极高的插入，更新和查询效率。但是会占用和数据量成正比的内存空间。并且其内容会在 MySQL 重新启动时丢失 Merge将一定数量的 MyISAM 表联合而成一个整体，在超大规模数据存储时很有用 Archive非常适合存储大量的独立的，作为历史记录的数据。因为它们不经常被读取。Archive 拥有高效的插入速度，但其对查询的支持相对较差 Federated将不同的 MySQL 服务器联合起来，逻辑上组成一个完整的数据库。非常适合分布式应用 Cluster/NDB高冗余的存储引擎，用多台数据机器联合提供服务以提高整体性能和安全性。适合数据量大，安全和性能要求高的应用 CSV 逻辑上由逗号分割数据的存储引擎。它会在数据库子目录里为每个数据表创建一个 .csv 文件。这是一种普通文本文件，每个数据行占用一个文本行。CSV 存储引擎不支持索引。 BlackHole 黑洞引擎，写入的任何数据都会消失，一般用于记录 binlog 做复制的中继 EXAMPLE 存储引擎是一个不做任何事情的存根引擎。它的目的是作为 MySQL 源代码中的一个例子，用来演示如何开始编写一个新存储引擎。同样，它的主要兴趣是对开发者。EXAMPLE 存储引擎不支持编索引。另外，MySQL 的存储引擎接口定义良好。有兴趣的开发者可以通过阅读文档编写自己的存储引擎。 数据库是什么？ 数据库（Database）是按照数据结构来组织、存储和管理数据的仓库，每个数据库都有一个或多个不同的API用于创建，访问，管理，搜索和复制所保存的数据。 数据存储在文件中，但是在文件中读写数据速度相对较慢。所以，我们使用关系型数据库管理系统（RDBMS）来存储和管理的大数据量。 所谓的”关系型数据库”，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。可以理解为”表格”的概念, 一个关系型数据库由一个或多个表格组成, 如图所示的一个表格: RDBMS即关系数据库管理系统(Relational Database Management System)的特点： 数据以表格的形式出现 每行为各种记录名称 每列为记录名称所对应的数据域 许多的行和列组成一张表单 若干的表单组成database RDBMS 术语 数据库: 数据库是一些关联表的集合。. 数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。 列: 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。 行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。 冗余：存储两倍数据，冗余可以使系统速度更快。 主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。 外键：外键用于关联两个表。 复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。 索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。 参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SElinux和Rsyslog]]></title>
    <url>%2F2016%2F02%2F26%2F2016-02-26-151027-SElinux%E5%92%8CRsyslog%2F</url>
    <content type="text"><![CDATA[SElinux SELinux(Security-Enhanced Linux) 是美国国家安全局（NSA）对于强制访问控制的实现，是 Linux历史上最杰出的新安全子系统。NSA是在Linux社区的帮助下开发了一种访问控制体系，在这种访问控制体系的限制下，进程只能访问那些在他的任务中所需要文件。 SElinux的用途在于增强系统抵御 0-Day 攻击(利用尚未公开的漏洞实现的攻击行为)的能力。所以它不是网络防火墙或 ACL 的替代品，在用途上也不重复。 获取当前 SELinux 运行状态 1getenforce 可能返回结果有三种：Enforcing、Permissive 和 Disabled。Disabled 代表 SELinux 被禁用，Permissive 代表仅记录安全警告但不阻止可疑行为，Enforcing 代表记录警告且阻止可疑行为。 改变 SELinux 运行状态 1setenforce [ Enforcing | Permissive | 1 | 0 ] 该命令可以立刻改变 SELinux 运行状态，在 Enforcing 和 Permissive 之间切换，结果保持至关机。一个典型的用途是看看到底是不是 SELinux 导致某个服务或者程序无法运行。若是在 setenforce 0 之后服务或者程序依然无法运行，那么就可以肯定不是 SELinux 导致的。 若是想要永久变更系统 SELinux 运行环境，可以通过更改配置文件 /etc/sysconfig/selinux 实现。注意当从 Disabled 切换到 Permissive 或者 Enforcing 模式后需要重启计算机并为整个文件系统重新创建安全标签(touch /.autorelabel &amp;&amp; reboot) SELinux 运行策略 配置文件 /etc/sysconfig/selinux 还包含了 SELinux 运行策略的信息，通过改变变量 SELINUXTYPE 的值实现，该值有两种可能：targeted 代表仅针对预制的几种网络服务和访问请求使用 SELinux 保护，strict 代表所有网络服务和访问请求都要经过 SELinux 参考文档：http://blog.csdn.net/myarrow/article/details/9856095/ Rsyslogrsyslog是UNIX系统中提供的一种日志记录方法(RFC3164)，rsyslog本身是一个服务器，程序中凡是使用rsyslog记录的信息都会发送到该服务器，服务器根据配置决定此信息是否记录，是记录到磁盘文件还是其他地方，这样使系统内所有应用程序都能以统一的方式记录日志，为系统日志的统一审计提供了方便。 日志管理服务分类 rsyslogd 普通日志管理服务：采集各种服务产生的信息根据日志服务配置文件内容将信息进行分类保存。 klogd 内核信息日志文件服务：专门记录内核信息 logrotate 日志文件轮替服务：解决日志文件内容过多消耗内存的日志文件替换服务 常见日志分类123456/var/log/cron # crontab 例行性任务调度产生信息/var/log/maillog # 邮件往来信息/var/log/secure # 涉及帐号密码的登陆信息/var/log/faillog /var/log/wtmp # 记录系统登陆者信息/var/log/yum.log # yum使用的信息在log 目录里面一般还有各种的网络服务日志文件，例如http samba 等等。 日志格式syslog记录的日志格式为：时间 主机名 进程 日志内容 文件信息rsyslog设备依据两个重要的文件：/etc/rc.d/init.d/rsyslog 守护进程和 /etc/rsyslog.conf 配置文件。通常情况下，多数rsyslog信息被写到 /var/adm 或 /var/log 目录下的信息文件中(messages.*)。一个典型的rsyslog记录包括生成程序的名字和一个文本信息。它还包括一个设备和一个优先级范围。 通过使用rsyslog.conf文件，可以对生成的日志的位置及其相关信息进行灵活的配置。该配置文件指明了rsyslog守护程序记录日志的行为，该程序在启动时查询配置文件。该文件由不同程序或消息分类的单个条目组成，每个占一行。对每类消息提供一个选择域和一个动作域。这些域由tab隔开： 选择域指明消息的类型和优先级; 动作域指明syslogd接收到一个与选择标准相匹配的消息时所执行的动作。 syslog.conf行的基本语法是： 消息类型.优先级 动作域 其中，每个选择域是由消息类型和优先级组成。当指明一个优先级时，syslogd将记录一个拥有相同或更高优先级的消息。Linux中一些主要的消息类型如表2所示，表3列出了一些优先级信息： rsyslog消息类型 消息类型 消息来源 kern 内核 User 用户程序 Damon 系统守护进程 Mail 电子邮件系统 Auth 与安全权限相关的命令 Lpr 打印机 News 新闻组信息 Uucp Uucp程序 Cron 记录当前登录的每个用户信息 wtmp 一个用户每次登录进入和退出时间的永久记录 Authpriv 授权信息 local0 ~ local7 8个自定义 priority 优先级 描述 emerg 最高的紧急程度状态 alert 紧急状态 Cirt 重要信息 warning 警告 err 临界状态 notice 出现不寻常的事情 info 一般性消息 Debug 调试级信息 None 不记录任何日志信息 通配机制 * 是把本项服务生成的所有日志消息都发送到操作动作指定的地点。就像它在规则表达式里的作用一样，星号代表“任何东西”。“mail.*”将把所有优先级的消息都发送到操作动作指定的/var/log/mail文件里。 = 大于该等级的信息等级 ! 不等于该等级，除了该等级以外的信息等级 - 异步写入，常用语邮件服务器，如mail.* -/var/log/maillog Target 记录到文件，如/var/log/messages 发送到日志服务器，@1.2.4.8 管道，| command]]></content>
      <categories>
        <category>security</category>
      </categories>
      <tags>
        <tag>security</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iptables Command & Examples]]></title>
    <url>%2F2016%2F02%2F25%2F2016-2-25%20iptables_Command_Examples%2F</url>
    <content type="text"><![CDATA[日常处理SSH连接1234iptables -A INPUT -d 192.168.2.133 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT# 将目标为本机22端口，状态为新请求或者已建立的连接放行iptables -A OUTPUT -s 192.168.2.133 -m state --state ESTABLISED -j ACCEPT# 将本机发出去的，状态为已建立的连接放行 本机到本机123iptables -A INPUT -i lo -j ACCEPTiptables -A OUTPUT -o lo -j ACCEPT# 本机到本机的连接放行 FTP连接 装载ip_conntrack_ftp和ip_nat_ftp模块 在 /etc/sysconfig/iptables-config 中IPTABLES_MODULES=后面使用空格追加ip_nat_ftp ip_conntrack_ftp 规则编写 12iptables -A INPUT -d 192.168.2.2 -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPTiptables -I OUTPUT -s 192.168.2.2 -m state --state ESTABLISHED,RELATED -j ACCEPT LOG记录1iptables -I INPUT -d 192.168.2.234 -p icmp --icmp-type 8 -j LOG --log-level notice --log-prefix "---firewall for icmp---" 数据切片123456iptables -t mangle -I PREROUTING -i eth+ -p tcp --tcp-flags SYN,ACK,RST,FIN SYN -m tcpmss --mss 1400:1500 -j TCPMSS --set-mss 1360# 或iptables -t mangle -I PREROUTING -i eth+ -p tcp --syn -m tcpmss --mss 1400:1500 -j TCPMSS --set-mss 1360# 将即将到达的的syn请求的数据包通过tcpmss模块调整iptables -t mangle -I POSTROUTING -o eth+ -p tcp --tcp-flags SYN,RST,ACK SYN,ACK -m tcpmss --mss 1400:1500 -j TCPMSS --set-mss 1360# 将即将走出本机的回应syn请求的数据包通过tcpmss模块调整 限制icmp速率123456789iptables -N ICMP_limit# 自定义一个链 ICMP_limit iptables -A ICMP_limit -p icmp --icmp-type echo-request -m limit --limit 5/minute --limit-burst 6 -j ACCEPTiptables -A ICMP_limit -p icmp --icmp-type echo-request -j DROP# 限定每分钟最多可以连接5个(1/12s)，一批最高峰值为6个，即前6个速度比较快，后面的按照5/minute作回应 iptables -I INPUT -p icmp --icmp-type echo-request -j ICMP_limit# 在INPUT链进行jump跳转 修改TTL值12iptables -t mangle -A POSTROUTING -o eth+ -p icmp -j TTL --ttl-set 255# 从本机出去的数据包，将其TTL设置为255。即使用mtr或traceroute命令后从本机的下一跳直接为目标主机，而不显示中间经过的路由 MARK标记12345iptables -t mangle -I PREROUTING -p tcp -s 10.0.0.0/8 -d 31.13.95.48 --dport 80 -j MARK --set-mark 2# 对相应符合条件的数据包进行标记 ip rule add fwmark 2 lookup 12 prio 997# 对标记的数据包做策略路由 MASQUERADE12iptables -t nat -A POSTROUTING -o eth0 -s 192.168.0.0/24 -j MASQUERADE# 不管现在eth0的出口获得了怎样的动态ip，MASQUERADE会自动读取eth0现在的ip地址然后做SNAT出去，这样就实现了很好的动态SNAT地址转换。 字符串匹配系统要求： 内核在2.6.18以上 iptables在1.3.5以上 内核中包含字符串匹配模块 1234iptables -I OUTPUT -p tcp -m string --string "qq.com" --algo bm -j DROPiptables -I OUTPUT -p udp -m string --string "qq.com" --algo kmp -j DROP# 禁用QQ相关通信# --algo bm|kmp 设置字符匹配的查询算法，一般默认使用bm算法效果就可以了，另外还可以设置kmp算法 抵御常见攻击SYN 方法1：限制请求速度 1234567iptables -N SYN_FLOOD# 自定义链SYN_FLOODiptables -A INPUT -p tcp --syn -j SYN_FLOOD # 对第一次握手SYN包进行jump iptables -A SYN_FLOOD -m limit --limit 1/s --limit-burst 4 -j RETURN iptables -A SYN_FLOOD -j DROP# 限定每秒最多可以连接1个，一批最高峰值为4个，即前4个速度比较快，后面的按照1/s返回主链进行回应。否则将丢弃 方法2：限制单个IP最大连接数 12iptables -A INPUT -i eth0 -p tcp --syn -m connlimit --connlimit-above 15 -j DROP# 限定单个IP连接超过15个就丢弃 DOS123456iptables -I INPUT 1 -p tcp -m multiport --dport 22 -m connlimit --connlimit-above 5 -j DROP# 单个IP最多5个会话iptables -I INPUT 2 -p tcp --dport 22 -m state --state NEW -m recent --set --name SSH #只要是新的连接请求，就把它加入到SSH列表中，此处需要使用recent模块iptables -I INPUT 3 -p tcp --dport 22 -m state --state NEW -m recent --update --seconds 300 --hitcount 3 --name SSH -j DROP# 5分钟(300s)内尝试次数达到3次，就拒绝为SSH列表中的这个IP提供服务。被限制5分钟后即可恢复访问。 访问过大12iptables -I INPUT -p tcp --dport 80 -m connlimit --connlimit-above 30 -j DROP# 对单个IP做连接上限 反弹木马12iptables -A OUTPUT -m state --state NEW -j DROP# 防止本机向外发送连接请求（如果本机有类似DNS请求的数据则据具体情况而待） ping攻击12iptables -A INPUT -p icmp --icmp-type echo-request -m limit --limit 1/m -j ACCEPT# 限制连接速率]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iptables ip_conntrack]]></title>
    <url>%2F2016%2F02%2F24%2F2016-2-24%20iptables_ip_conntrack%2F</url>
    <content type="text"><![CDATA[ip_conntrackLinux内核NAT的模块，实时记录当前主机上client和server彼此建立的连接关系，且可以追踪某个连接和其他某个连接处于何种状态，既可以追踪TCP协议，也可以追踪UDP协议和ICMP协议。 默认的timeout是432000秒（五天）。每个ip_conntrack记录约会占用292Bytes的内存，所以系统所能记录的ip_conntrack也是有限的，如果超过了这个限度，就会出现内核级错误“ip_conntrack: table full, dropping packet”，其结果就是无法再有任何的网络连接了。 参数位置及含义 用于定义ip_conntrack同时可以追踪连接数最大值 CentOS5.X /proc/sys/net/ipv4/ip_conntrack_max CentOS6.X /proc/sys/net/nf_conntrack_max 保存当前系统上每个client和当前主机所建立的连接关系 CentOS5.X /proc/net/ip_conntrack CentOS6.X /proc/net/nf_conntrack [ Tips ] 使用iptables命令查看nat表时,由于依赖关系将会自动激活ip_conntrack模块,如果在访问量非常繁忙的服务器上执行此操作将会导致大量请求被丢弃 此时需要修改/etc/sysctl.conf文net.ipv4.ip_conntrack_max=65535这一行。将IP追踪连接数调整至最大值，并使用sysctl命令立即生效: sysctl -w net.ipv4.ip_conntrack_max=65535或sysctl -p iptstate 以top命令类似的风格时显示Linux内核中iptables的工作状态。 -t 显示当前系统所有的连接的个数]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iptables Targets/Jump]]></title>
    <url>%2F2016%2F02%2F23%2F2016-2-23%20iptables_Targets_Jump%2F</url>
    <content type="text"><![CDATA[Target 处理动作：指的是由规则指定的操作，对规则匹配到的包做什么样的动作 ACCEPT放行，允许数据包通过 DROP丢弃，不做任何回应 REJECT拒绝数据包通过，并且回应给发送端一个错误信息 DNAT目标地址转换 --to SNAT源地址转换需要使用--to-source REDIRECT端口重定向 TOS用来设置IP头部中的Type Of Service字段 TTL用于修改IP头部中Time To Live字段的值 ULOGULOG可以在用户空间记录被匹配的包的信息，这些信息和整个包都会通过netlink socket被多播 MIRROR颠倒IP头部中的源目地址，然后再转发包 LOG在/var/log/messages 文件中记录日志信息，然后将数据包传递给下一条规则 MARK打标记，--set-mark n，这里的n是一个无符号整数，多用于对标记的数据进行策略路由操作 QUEUE防火墙将数据包移交到用户空间 RETURN 它使包返回上一层，顺序是：子链-&gt;父链-&gt;缺省的策略。 若包在子链中遇到了RETURN，则返回父链的下一条规则继续进行条件的比较 若在父链（或称主链，比如INPUT）中遇到了RETURN，就要被缺省的策略（一般是ACCEPT或DROP）操作了 MASQUERADE 做地址伪装，与SNAT作用相同但不需要使用--to-sourcee 假如当前系统用的是ADSL/3G/4G动态拨号方式，那么每次拨号出口IP都会改变，SNAT就会有局限性。]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iptables Match]]></title>
    <url>%2F2016%2F02%2F22%2F2016-2-22%20iptables_Match%2F</url>
    <content type="text"><![CDATA[通用匹配 无需依赖模块，自身可完成检查匹配 匹配参数 说明 ！ 使用叹号对条件取反 -p 指定协议（tcp，udp，icmp等），可使用all来指定所有协议 -s - -src，指定数据包源地址，可使用IP地址、网络地址、主机名 -d - -dst，指定目的地址 -i 指定数据报文流入接口，用于PREROUTING、INPUT、FORWARD -o 指定数据报文流出接口，用于OUTPUT、POSTROUTING、FORWARD 扩展匹配 需要依赖模块来完成检查匹配 隐式扩展 不用特别指明由那个模块进行的扩展，当使用-p {tcp|udp|icmp}中的一种时，可以直接使用扩展专用选项 扩展条件 扩展选项 说明 -p tcp --sport 来源端口 --dport 目的端口 --tcp-flags tcp标志位 --syn 第一次握手 -p udp --sport 来源端口 --dport 目的端口 -p icmp --icmp-type icmp类型 --tcp-flags mask comp 只检查mask指定的TCP的标志位，是逗号分开的标志位列表，comp表示此列表中出现在mask中，且必须为1.如果没有出现在mask中，而comp中出现的，必须为0 --tcp-flags SYN,FIN,ACK,RST SYN 或 --syn ：TCP三次握手的第一次 --tcp-flags SYN,FIN,ACK,RST SYN,ACK：匹配四个标志位，其中syn和ack为1，其他为0 --icmp-type 8：echo-request 0：echo-reply 允许本机ping其他主机 iptables -A OUTPUT -p icmp --icmp-type echo-request -j ACCEPT iptables -A INPUT -p icmp --icmp-type echo-reply -j ACCEPT 允许其他主机ping本机 iptables -A INPUT -p icmp --icmp-type 8 -j ACCEPT iptables -A OUTPUT -p icmp --icmp-type 0 -j ACCEPT 显示扩展（-m） 必须指明是由哪个模块进行的扩展，此功能可以使用额外的匹配机制 -m state：状态扩展，结合ip_conntrack模块追踪回话的状态 NEW 新连接发起的请求 ESTABLISHED 已经建立的连接(即:对于新请求的相应) INVALID 非法连接请求 RELATED 相关连的连接(由命令发起，例如ftp) 例如 -m state --state NEW -j ACCEPT状态为new放行 -m state --state NEW,ESTABLISHED -j ACCEPT状态为new或established都放行 -m multiport：离散的多端口扩展 --source-ports，--sports 多个源端口 --destination-ports，--dports 多个目的端口 --ports 源和目的端口 例如 -m multiport --destnation-ports 21,22,80 -j ACCEPT目标端口为21,22,80的数据包放行 -m iprange：匹配IP范围 --src-range ip1-ip100 源IP范围 --dst-range ip10-ip20 目的IP范围 -m connlimit：连接数限定 --connlimit-above n 连接数达到n，一般进行取反使用 例如 iptables -A INPUT -d 192.168.2.2 -p tcp --dport 80 -m connlimt !--connlimt-above 5 -j ACCEPT连接数未达到5个则放行，否则丢弃 -m limit：令牌桶过滤器，不控制最大上限 --limit n[/second|/minute|/hour|/day] 单位时间内最多允许n个数据包，3/minute表示每分钟最多3个 --limit-burst 峰值，蜂拥而至的连接数有多大，默认为5 例如 iptables -I INPUT -d 192.168.2.2 -p icmp --icmp-type 8 -m limit --limit 5/minute --limit-burst 6 -j ACCEPT iptables -I INPUT -d 192.168.2.2 -p icmp --icmp-type 8 -j DROP 目标为本机，协议为icmp，限定每分钟最多可以连接5个(1/12s)，一批最高峰值为6个，即前6个速度比较快，后面的按照5/minute作回应 -m string：匹配请求的报文中的字符串，字符匹配检查高效算法：kmp， bm --algo {kmp|bm} 指定算法 --string “STRING” 指定普通字符串 --hex-string “HEX_STRING” HEX_STRING为编码成16进制格式的字串； 例如 iptables -I OUTPUT -s 192.168.2.2 -m string --algo kmp --string &quot;H7N9&quot; -j REJECT 源地址为192.168.2.2，并且报文中匹配到H7N9则丢弃 -m time：基于时间做访问控制 --datestart YYYY[-MM][-DD[Thh[:mm[:ss]]]] 起始日期 --datestop 终止日期 --timestart hh:mm[:ss] 起始时间 --timestop hh:mm[:ss] 终止时间 --weekdays Sa[,Su] 一周中的哪些天 例如 iptables -I INPUT -d 172.16.100.7 -p tcp --dport 80 -m time --timestart 08:20 --timestop 18:40 --weekdays Mon,Tue,Thu,Fri -j REJECT 周一、二、四、五的8:20到18:40禁止其他主机访问本机（172.16.100.7）的80端口 参考链接： http://9612520.blog.51cto.com/9602520/1600273/ http://www.2cto.com/article/201207/143654.html]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iptables Options & Chain]]></title>
    <url>%2F2016%2F02%2F21%2F2016-2-21%20iptables_Options_%26_Chain%2F</url>
    <content type="text"><![CDATA[Options 选项名 功能及特点 -A （--append）在指定链的末尾添加一条新的规则 -D （--delete）删除指定链中的某条规则，按规则序号或内容确定要删除的规则 -I （--insert）在指定链中插入一条新的规则，默认在链的开头插入 -R （--replace）修改、替换指定链中的一条规则，按规则序号或内容确定 -F （--flush）清空指定链中的所有规则，默认清空表中所有链的内容 -N （--new-chain）新建一条用户自己定义的规则链 -X （--delete-chain）删除指定表中用户自定义的规则链 -E （-E old-chain-name new-chain-name）重命名自定义链 -P （--policy）设置指定链的默认策略 -v （--verbose）查看规则列表时显示详细的信息 -V （--Version）查看iptables命令工具的版本信息 -Z （--zero) 将指定链中的所有规则的包字节计数器归零 -h （--help）查看命令帮助信息 -L （--list）列出指定链中所有的规则，默认列出表中所有链的内容 -n 以数字形式显示地址和端口号,不进行解析 -v 显示链及规则详细信息 -x 显示计数器的精确值而不是近似值 --line-numbers显示规则号码 Chain 默认链 PREROUTING：进入netfilter后的数据包在进入路由判断前执行的规则 INPUT：路由判断后要进入本机内部获取本地服务资源 FORWARD：路由判断后目的地不是本机的数据包而执行的规则。与本机没有关联。 OUTPUT：由本机产生，需向外发的数据包执行的规则 POSTROUTING：路由判断后发送到网卡接口前,数据包准备离开netfilter时执行的规则 自定义链 自定义链必须在默认链调用后才能发挥作用。 如果没有被自定义链中的任何规则匹配,还应该有返回机制。 用户可以删除自定义的空链,但不可以删除默认链。 计数器 每一条规则都有两个内置的计数器,一个记录被匹配到的报文个数,一个记录被匹配的报文大小之和 Process 图例一 图例二]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iptables Basic]]></title>
    <url>%2F2016%2F02%2F20%2F2016-2-20%20iptables_Basic%2F</url>
    <content type="text"><![CDATA[防火墙 工作于主机或网络边缘，对于进出的报文根据事先定义的规则做检查，被匹配到的报文作出相应处理的组件 iptables linux的包过滤功能，即linux防火墙，它由netfilter 和 iptables 两个组件组成 netfilter Framework 网络过滤框架，工作于kernel space iptables结构 iptables -&gt; Tables -&gt; Chains -&gt; Rules table raw优先级最高，设置raw将不经过连接跟踪模块，一般是为了不让iptables做数据包连接追踪，以提高性能。如大量访问的web服务器，可以让80端口不再让iptables做数据包的链接跟踪处理，以提高用户的访问速度。 raw表处理完后，将跳过NAT表和 ip_conntrack处理，即不再做地址转换和数据包的链接跟踪处理。 mangle高级路由信息数据包修改(如tos服务类型，ttl包生存时间的修改，mark标记等) natNetwork Address Translation 与本机资源无关，主要处理源、目标IP和端口的转换 filter处理与本机资源有关的数据包，是默认表 基本操作 服务 启动 service iptables start 关闭 service iptables stop 重启 service iptables restart 重载 service iptables reload 状态 service iptables status 开启转发 echo &quot;1&quot;&gt; /proc/sys/net/ipv4/ip_forward 配置文件 服务配置文件 /etc/sysconfig/iptables-config 规则存放文件 /etc/sysconfig/iptables 配置保存 使用服务管理保存 service iptables save 保存位置：/etc/sysconfig/iptables 使用重定向 iptables-save &gt; /path/to/file 将规则保存于某个文件 iptables-restore &lt; /path/to/file 从某个文件读取规则并加载 注意 iptables服务重启后不会读取自定义的文件,而是读取/etc/sysconfig/iptables 语法格式 基本语法 iptables [-t table] Command CHAIN [num] 匹配标准 –j Action 说明 iptables不是服务但有服务脚本,服务脚本的主要作用在于生效保存的规则,装载及移除相关内核模块。 iptables/netfilter相关的内核模块 iptables_nat iptables_filter iptables_mangle iptables_raw ip_nat ip_conntrack]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Samba]]></title>
    <url>%2F2016%2F02%2F19%2F2016-02-19-151954-Samba%2F</url>
    <content type="text"><![CDATA[Samba Samba 是 SMB/CIFS 网络协议的重新实现, 它作为 NFS 的补充使得在 Linux 和 Windows 系统中进行文件共享、打印机共享更容易实现。 Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。 Samba服务器的工作原理是：客户端向Samba服务器发起请求，请求访问共享目录，Samba服务器接收请求，查询smb.conf文件，查看共享目录是否存在，以及来访者的访问权限，如果来访者具有相应的权限，则允许客户端访问，最后将访问过程中系统的信息以及采集的用户访问行为信息存放在日志文件中。 安装配置 安装 1yum -y install samba 配置Samba的配置文件一般就放在/etc/samba目录中，主配置文件名为smb.conf，文件中记录着大量的规则和共享信息，所以是samba服务非常重要的核心配置文件，完成samba服务器搭建的大部分主要配置都在该文件中进行。 123cd /etc/sambacp -a smb.conf&#123;,.bak&#125;vim smb.conf 123456789101112131415161718192021[global] workgroup = Samba netbios name = SambaServer server string = Linux Samba Server TestServer security = user# workgroup：在Windows中显示的工作组# netbios name：在Windows中显示出来的计算机名# server string ：Samba服务器说明，可以自定义# security：验证和登录方式，share为共享；user为用户认证[shared] path = /opt/shared writeable = no browseable = yes guest ok = yes# [shared]：在Windows中显示出来是共享的目录# path = 设置要共享的目录的路径# writeable 是否可写# browseable 是否可以浏览；可以浏览意味着，在工作组下能看到共享文件夹# guest ok 匿名用户以guest身份是登录 建立目录、用户并授权 1234install -cdv /opt/shareduseradd testsmbpasswd -a testchown -R test.test /opt/shared/ 用户 Samba的所有用户都必须是系统里已存在的用户 密码是独立的，不是/etc/shadow中的密码 启动smbd和nmbd服务 1for i in smb nmb ;do service $i restart;done 测试使用Windows的运行输入\Samba服务器的地址访问测试 附加12345678910111213141516171819# [global]字段可选配置：# dos charset = GB2312# 将Windows 客户端的文字编码设置为简体中文 GB2312# unix charset =GB2312# 指定Samba所在的CentOS服务端新建文件或目录时的编码为 GB2312# display charset= GB2312# 指定使用SWAT（一种通过浏览器控制Samba的工具）时页面的默认文字编码# directory mask = 0777# force directorymode = 0777# directorysecurity mask = 0777# force directorysecurity mode = 0777# 指定新建目录的权限# create mask =0777# force createmode = 0777# security mask =0777# force securitymode = 0777# 指定新建文件的权限]]></content>
      <categories>
        <category>Services</category>
      </categories>
      <tags>
        <tag>文件共享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vsftpd]]></title>
    <url>%2F2016%2F02%2F18%2F2016-02-18-094442-Vsftpd%2F</url>
    <content type="text"><![CDATA[FTP FTP 是File Transfer Protocol（文件传输协议）的英文简称，用于Internet上的控制文件的双向传输。基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。 在FTP的使用当中，用户经常遇到两个概念：”下载”（Download）和”上传”（Upload）。”下载”文件就是从远程主机拷贝文件至自己的计算机上；”上传”文件就是将文件从自己的计算机中拷贝至远程主机上。 两种连接 FTP会话时包含了两个连接，一个叫控制连接，一个叫数据数据连接。 控制连接 和FTP服务器进行沟通的连接。连接FTP、发送FTP指令都是通过控制通道来完成的。在收到断开连接命令前，始终保持连接。 数据连接 和FTP服务器进行文件传输或者列表的连接。数据传输时建立，传输结束时终止。FTP协议中，控制连接均由客户端发起，而数据连接有两种工作方式：PORT方式和PASV方式 主动模式（PORT模式） FTP Client 首先和 FTP Server的 TCP 21 端口建立控制连接，通过这个连接发送命令，客户端需要接收数据时在这个控制连接上发送 PORT 命令。 PORT 命令包含了客户端用什么端口(一个大于1024的端口)接收数据。在传送数据的时候，服务器端通过自己的 TCP 20 端口主动连接客户端并发送数据。 FTP server 必须和 clien t建立一个新的连接用来传送数据。 被动模式（PASV模式） 在建立控制连接的时候和 PORT 模式类似，当客户端通过这个连接发送 PASV 命令的时候，FTP server 打开一个位于1024和5000之间的随机端口并且通知客户端在这个端口上传送数据的请求，然后 FTP server 将通过这个端口进行数据的传送，这个时候FTP server不再需要建立一个新的和客户端之间的连接传送数据。 如果从C/S模型这个角度来说，PORT对于服务器来说是OUTBOUND，而PASV模式对于服务器是INBOUND，这一点请特别注意，尤其是在使用防火墙的企业里，这一点非常关键，如果设置错了，那么客户将无法连接。 文件说明 文件 文件作用 /etc/vsftpd/vsftpd.conf 主配置文件 /usr/sbin/vsftpd Vsftpd的主程序 /etc/rc.d/init.d/vsftpd 启动脚本 /etc/pam.d/vsftpd PAM认证文件（此文件中file=/etc/vsftpd/ftpusers字段，指明阻止访问的用户来自/etc/vsftpd/ftpusers文件中的用户） /etc/vsftpd/ftpusers 禁止使用vsftpd的用户列表文件。记录不允许访问FTP服务器的用户名单，管理员可以把一些对系统安全有威胁的用户账号记录在此文件中，以免用户从FTP登录后获得大于上传下载操作的权利，而对系统造成损坏。 /etc/vsftpd/user_list 禁止或允许使用vsftpd的用户列表文件。这个文件中指定的用户缺省情况（即在/etc/vsftpd/vsftpd.conf中设置userlist_deny=YES）下不能访问FTP服务器，在设置了userlist_deny=NO时,仅允许user_list中指定的用户访问FTP服务器。 /var/ftp 匿名用户主目录；本地用户主目录为：/home/用户主目录，即登录后进入自己家目录 /var/ftp/pub 匿名用户的下载目录，此目录需赋权根chmod 1777 pub（1为特殊权限，使上载后无法删除） /etc/logrotate.d/vsftpd.log Vsftpd的日志文件，可在主配置文件进行修改 用户类型 匿名用户在FTP服务器上没有账号，用户名为anonymous或ftp，/var/ftp作为ftp访问的根目录 本地用户在FTP服务器上拥有帐号，可以登录到服务器上。该账号既可以作为登录帐号使用，也可以作为ftp帐号使用。其家目录目录作为其ftp访问的根目录。 虚拟用户（Guest用户）在FTP服务器上拥有帐号，但该账号只能作为ftp帐号使用，不能访问除家目录之外的内容。 参数配置vsftpd的配置文件中以#开始注释，配置参数要顶格写，等号前后没有空格 登录欢迎信息Login Banners12345678# 是否激活目录欢迎信息功能# 如果两个指令都做了配置，那么banner_file将覆盖ftpd_bannerftpd_banner=Welcome to blah FTP service.#banner_file=/etc/vsftpd/banner# 默认情况下，欢迎信息是通过该目录下的.message文件获得的# 此文件保存自定义的欢迎信息，由用户自己建立#dirmessage_enable=YES 禁锢用户在其家目录1234567891011# 对于ftp访问ftp服务器时应该对其chrootchroot_local_user=YES# 用户登录FTP服务器后是否具有访问自己目录以外的其他文件的权限# 设置为YES时，用户被锁定在自己的home目录中，vsftpd将在下面chroot_list_file选项值的位置寻找chroot_list文件# 必须与下面的设置项配合#chroot_list_enable=YES# 被列入此文件的用户，在登录后将不能切换到自己目录以外的其他目录# 从而有利于FTP服务器的安全管理和隐私保护。此文件需自己建立#chroot_list_file=/etc/vsftpd/chroot_list 匿名用户配置12345678910111213# 是否允许匿名登录FTP服务器，默认设置为YES允许# 用户可使用用户名ftp或anonymous进行ftp登录，口令为用户的E-mail地址。# 如不允许匿名访问则设置为NOanonymous_enable=YES# 是否允许匿名用户有写权限#anon_upload_enable=YES# 是否允许匿名用户有删除权限#anon_other_write_enable=YES# 是否允许匿名用户创建文件夹权限#anon_mkdir_write_enable=YES 连接限制1234567891011121314151617181920212223# 设置数据传输中空闲超时时间# 即当数据传输结束后，用户连接FTP服务器的时间不应超过600秒。可以根据实际情况对该值进行修改#idle_session_timeout=600# 设置数据连接超时时间，即数据传输的超时时间#data_connection_timeout=120# 最大并发连接数max_clients=100# 每IP可同时发起并发请求max_per_ip=5# 绑定监听的IP地址 #listen_address=192.168.0.2# 绑定监听的端口#listen_port=21# Make sure PORT transfer connections originate from port 20 (ftp-data).# 是否设定FTP服务器将启用FTP数据端口的连接请求# ftp-data数据传输，21为连接控制端口connect_from_port_20=YES 传输速率1234# 匿名用户的传输速率（包括上传和下载），单位为bytes/second，0为不限制anon_max_rate=51200# 本地用户传输速率，单位为“字节/秒”local_max_rate=51200 上传文件的umask123456# 上传后文件的权限掩码，本地用户默认掩码为077# 匿名用户上传文件的umaskanno_umask=022# 可以设置本地用户的文件掩码为缺省022local_umask=077 修改匿名用户上传文件的属主和属主123456789# 如果未指定属主数组，则默认为`ftp`# 设定是否允许改变上传文件的属主，与下面一个设定项配合使用# 注意，不推荐使用root用户上传文件#chown_uploads=YES# 设置想要改变的上传文件的属主，如果需要，则输入一个系统用户名# 可以把上传的文件都改成root属主。#chown_username=user1 黑白名单1234567# ftpusers中用户禁止访问（登录时可以看到密码输入提示，但仍无法访问）# 若此项设为YES，则user_list文件中的用户允许登录FTP服务器# 而如果同时设置了userlist_deny=YES，则user_list文件中的用户将不允许登录FTP服务器，甚至连输入密码提示信息都没有#userlist_enable=YES/NO# 设置是否阻止user_list文件中的用户登录FTP服务器，默认为YES#userlist_deny=YES/NO user_list配置文件有两种用法 黑名单 userlist_enable=YES userlist_deny=YES user_list中的用户都拒绝 白名单 userlist_enable=YES userlist_deny=NO user_list中的用户都不拒绝，允许 以下是两个选项的具体表现形式和两种搭配使用方式的效果： 配置 作用 userlist_enable=YES ftpusers中用户允许访问 user_list中用户允许访问 userlist_enable=NO ftpusers中用户禁止访问 user_list中用户允许访问 userlist_deny=YES ftpusers中用户禁止访问（登录时可以看到密码输入提示，但仍无法访问） user_list 中用户禁止访问 userlist_deny=NO ftpusers中用户禁止访问 user_list中用户允许访问 userlist_enable=YES 并且userlist_deny=YES ftpusers中用户禁止访问 user_list中用户禁止访问（登录时不会出现密码提示，直接被服务器拒绝） userlist_enable=YES 并且 userlist_deny=NO ftpusers中用户禁止访问 user_list中用户允许访问 被动模式设置12345678# 是否开户被动模式 pasv_enable=yes # 被动模式最小端口 pasv_min_port=5000 # 被动模式最大端口 pasv_max_port=6000 其他配置参考链接：http://os.51cto.com/art/201008/221842.htm 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# 是否允许本地用户(即linux系统中的用户帐号)登录FTP服务器，默认设置为YES允许# 本地用户登录后会进入用户主目录，而匿名用户登录后进入匿名用户的下载目录/var/ftp/pub# 若只允许匿名用户访问，前面加上#注释掉即可阻止本地用户访问FTP服务器# 主要是为虚拟宿主用户，如果该项目设定为NO那么所有虚拟用户将无法访问。#local_enable=YES# 是否允许用户对FTP服务器文件具有写权限，默认设置为YES允许#write_enable=YES # 是否允许匿名用户上传文件，须修改全局的write_enable=YES。默认为YES#anon_upload_enable=YES# 是否允许匿名用户创建新文件夹#anon_mkdir_write_enable=YES # 是否让系统自动维护上传和下载的日志文件# 默认情况该日志文件为/var/log/vsftpd.log,也可以通过下面的xferlog_file选项对其进行设定# 默认值为NOxferlog_enable=YES# 设定系统维护记录FTP服务器上传和下载情况的日志文件# /var/log/vsftpd.log是默认的，也可以另设其它# 该文件默认不存在。必须要手动touch出来#xferlog_file=/var/log/vsftpd.log# 是否以标准xferlog的格式书写传输日志文件# 默认为/var/log/xferlog，也可以通过xferlog_file选项对其进行设定# 默认值为NO#xferlog_std_format=YES# 是否将原本输出到/var/log/vsftpd.log中的日志，输出到系统日志#syslog_enable# 运行vsftpd需要的非特权系统用户，缺省是nobody#nopriv_user=ftpsecure# 是否识别异步ABOR请求。# 如果FTP client会下达“async ABOR”这个指令时，这个设定才需要启用# 而一般此设定并不安全，所以通常将其取消#async_abor_enable=YES# 是否以ASCII方式传输数据。默认情况下，服务器会忽略ASCII方式的请求。# 启用此选项将允许服务器以ASCII方式传输数据# 不过，这样可能会导致由"SIZE /big/file"方式引起的DoS攻击#ascii_upload_enable=YES#ascii_download_enable=YES# 黑名单设置。如果很讨厌某些email address，就可以使用此设定来取消他的登录权限# 可以将某些特殊的email address抵挡住。#deny_email_enable=YES# 当上面的deny_email_enable=YES时，可以利用这个设定项来规定哪些邮件地址不可登录vsftpd服务器# 此文件需用户自己创建，一行一个email address即可#banned_email_file=/etc/vsftpd/banned_emails# 是否允许递归查询。默认为关闭，以防止远程用户造成过量的I/O#ls_recurse_enable=YES# 是否允许监听。# 如果设置为YES，则vsftpd将以独立模式运行，由vsftpd自己监听和处理IPv4端口的连接请求listen=YES# 设定是否支持IPV6。如要同时监听IPv4和IPv6端口，# 则必须运行两套vsftpd，采用两套配置文件# 同时确保其中有一个监听选项是被注释掉的#listen_ipv6=YES# 设置PAM外挂模块提供的认证服务所使用的配置文件名，即/etc/pam.d/vsftpd文件# 此文件中file=/etc/vsftpd/ftpusers字段，说明了PAM模块能抵挡的帐号内容来自文件/etc/vsftpd/ftpusers中#pam_service_name=vsftpd# 禁止用户登陆FTP后使用"ls -R"的命令。该命令会对服务器性能造成巨大开销。如果该项被允许，那么挡多用户同时使用该命令时将会对该服务器造成威胁。ls_recurse_enable=NO# 是否使用tcp_wrappers作为主机访问控制方式。# tcp_wrappers可以实现linux系统中网络服务的基于主机地址的访问控制# 在/etc目录中的hosts.allow和hosts.deny两个文件用于设置tcp_wrappers的访问控制# 前者设置允许访问记录，后者设置拒绝访问记录。# 如想限制某些主机对FTP服务器192.168.57.2的匿名访问，编缉/etc/hosts.allow文件，如在下面增加两行命令：# vsftpd:192.168.57.1:DENY 和vsftpd:192.168.57.9:DENY# 表明限制IP为192.168.57.1/192.168.57.9主机访问IP为192.168.57.2的FTP服务器# 此时FTP服务器虽可以PING通，但无法连接tcp_wrappers=YES]]></content>
      <categories>
        <category>Services</category>
      </categories>
      <tags>
        <tag>文件共享</tag>
        <tag>vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础邮件服务器（Postfix+Dovecot）]]></title>
    <url>%2F2016%2F02%2F17%2F2016-02-17-094119-%E5%9F%BA%E7%A1%80%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88Postfix%2BDovecot%EF%BC%89%2F</url>
    <content type="text"><![CDATA[概述 MUA（Mail User Agent）邮件用户代理：接收邮件所使用的邮件客户端程序，使用IMAP或POP3协议与服务器通信，它提供了阅读、发送和接收电子邮件的用户接口。常见的客户端：outlook、foxmail等 MTA（Mail Transfer Agent）邮件传送代理：通过SMTP协议负责邮件的存储、发送和转发。监视MUA的请求，根据电子邮件的目标地址找出对应的邮件服务器，将信件在服务器之间传输并将接受到的邮件进行缓冲。在linux环境中常见的MTA有：sendmail、qmail等 MDA（Mail Deliver Agent）邮件投递代理：将MTA接收到的邮件保存到磁盘或指定地方，通常会进行垃圾邮件及病毒扫描。常用的MDA：procmail、dropmail等 MRA（Mail Retrieval Agent）邮件取回代理：负责实现IMAP与POP3协议，与MUA进行交互。常用的MRA：dovecot MSA（Mail Submission Agent）邮件提交代理：检查邮件安全性与垃圾等，处理额外的工作 一封邮件的流程 发件人：MUA –发送–&gt; MTA -&gt; 若干个MTA… -&gt; MTA -&gt; MDA &lt;–收取– MUA：收件人 MUA并非直接将邮件发送至收件人手中，而是通过MTA代为传递，Sendmail和Postfix就是扮演MTA的角色 一封邮件从MUA发出后，可能通过一个或多个MTA传递，最终到达MDA。然后存放在某个文件或特殊的数据库里，我们将这个长期保存邮件的地方称之为邮箱 一旦邮件到达邮箱，就原地不动了，等用户再通过MUA将其取走，就是用Outlook，Foxmail等软件收信的过程 MUA到MTA，以及MTA到MTA之间使用的协议就是SMTP协议，而收邮件时，MUA到MDA之间使用的协议最常用的是POP3或IMAP。 邮件应用协议 简单邮件传输协议(SMTP)，用来发送或中转发出的电子邮件，占用tcp 25端口。 第三版邮局协议(POP3)，用于将服务器上把邮件存储到本地主机，占用tcp 110端口。 第四版互联网信息访问协议(IMAP4)，用于在本地主机上访问邮件，占用tcp 143端口。 注意事项：如果想搭建企业级的电子邮件系统，请考虑以下几点： 反垃圾与反病毒模块：阻止垃圾邮件或病毒邮件对企业邮箱的干扰。 邮件加密：保证邮件内容不被嗅探、篡改。 邮件监控审核：监控全体职员邮件中有无敏感词，透露企业资料等。 稳定性：有较好的防DDOS攻击的能力，保证系统在线率等。 准备工作 邮件服务依赖于DNS服务，事先确保DNS服务已经为邮件应用配置完成。为了方便，此处将邮件服务器和DNS服务器配置为一台：192.168.247.108。主机名为 mail.test.com ，区域为 test.com ，邮件服务器为 mail.test.com 修改主机名 123name="mail.test.com"sed -ri 's#(HOSTNAME=).*#\1'"$&#123;name&#125;"'#' /etc/sysconfig/network hostname $&#123;name&#125; DNS配置 1234567891011zone "test.com" IN &#123; type master; file "test.com.zone"; allow-update &#123; none; &#125;;&#125;;# 邮件服务器需要用到反向解析，否则会在互联网被视为垃圾邮件服务器zone "247.168.192.in-addr.arpa" IN &#123; type master; file "192.168.247.zone"; allow-update &#123; none; &#125;;&#125;; 正向区域文件/var/named/test.com.zone 1234567891011$TTL 1D@ IN SOA ns1.test.com. admin.test.com. ( 20160217 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum IN NS ns1 IN MX 10 mailns1 IN A 192.168.247.108mail IN A 192.168.247.108 反向区域文件/var/named/192.168.247.zone 12345678910$TTL 1D@ IN SOA ns1.test.com. admin.test.com. ( 20160217 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum IN NS ns1.test.com.108 IN PTR ns1.test.com.108 IN PTR mail.test.com. 权限修改 123456cd /var/named/chown named.named test.com.zone 192.168.247.zone chmod 640 test.com.zone 192.168.247.zone # 语法检查named-checkzone "test.com" test.com.zone named-checkzone "247.168.192.in-addr.arpa" 192.168.247.zone 软件包、服务、用户环境配置 依赖包安装 123yum -y groupinstall "Development Libraries" "Development Tools"yum -y install db*-devel yum -y install cyrus-sasl* 如果系统有sendmail，需要把sendmail关掉 12service sendmail stopchkconfig sendmail off 为了更好的支持sasl，因此编译安装postfix；如果有rpm的postfix，要删除掉并且把postfix用户等信息也删除掉。 12345rpm -e postfix --nodepsuserdel -r postfixuserdel -r postdropgroupdel postfixgroupdel postdrop 部署postfix 开源邮件系统 Sendmail：资格最老，运行稳定，但安全性欠佳 Qmail：更好的执行效率，配置管理也很方便，但兼容性不高 Postfix：兼容Sendmail，采用模块化设计，在投递效率、稳定性、服务性能及安全方面都很优秀 单独使用Postfix服务程序并不能让用户完成收发邮件的操作，因为一个基础的电子邮局系统至少需要有SMTP服务器、POP3/IMAP服务器，为了能够部署一个基础的电子邮件系统，我们需要使用到下面的软件： Postfix：提供邮件发送服务，即SMTP。 Dovecot：提供邮件收取服务，即POP3。 OutLook Express：客户端收发邮件的工具。 安装postfixPostfix是一款由IBM出资研发的免费开源的邮局服务程序，兼容于Sendmail服务程序，即Sendmail用户可以很方便的迁移到Postfix程序，且收发件性能远超过Sendmail，能够自动增加减少进程的数量，保证邮局系统的高性能与稳定性，另外Postfix是由诸多的小模块组成，每个小模块完成特定的功能，使得管理员可以灵活的组合这些模块。 123456789101112131415# 创建用户组，ID号最好大于1000groupadd -g 2828 postfixuseradd -g postfix -u 2828 -s /sbin/nologin -M postfixgroupadd -g 2829 postdropuseradd -g postdrop -u 2829 -s /sbin/nologin -M postdrop# 编译安装tar xf postfix-3.2.0.tar.gzcd postfix-3.2.0make tidymake makefiles 'CCARGS=-DUSE_SASL_AUTH -DUSE_CYRUS_SASL -I/usr/include/sasl' 'AUXLIBS=-L/usr/lib64/sasl2 -lsasl2'make &amp;&amp; make install# 创建邮件别名库newaliasesll /etc/aliases* 123456# 编译报错xsasl_cyrus_server.c:638: error: ‘XSASL_CYRUS_SERVER’ has no member named ‘username’make: *** [xsasl_cyrus_server.o] Error 1make: *** [update] Error 1# 缺少依赖包 - - &gt; 执行：yum -y install cyrus-sasl* 配置postfix Postfix邮局服务程序的配置文件： 文件 作用 /usr/sbin/postfix 主服务程序 /etc/postfix/master.cf master主程序的配置文件。 /etc/postfix/main.cf postfix服务的配置文件。 /var/log/maillog 记录邮件传递过程的日志。 /usr/libexec/postfix 服务程序目录 /var/spool/postfix 邮件队列目录 Postfix服务程序主配置文件: 参数 作用 myhostname 邮件系统的主机名。 mydomain 邮件系统的域名。 myorigin 从本机寄出邮件的域名名称。 inet_interfaces 监听的网卡接口。 mydestination 可接收邮件的主机名或域名。 mynetworks 设置可转发那些主机的邮件。 relay_domains 设置可转发那些网域的邮件 编辑Postfix主配置文件直接执行辅助配置工具postconf，可列出postfix服务所支持的所有配置。结合“-n”选项可排除默认配置，只列出非默认的配置。结合“-d”选项可查看默认配置。 12345# 备份main.cf文件，创建新的main.cf文件postconf -n &gt; tmp.filemv /etc/postfix/main.cf&#123;,.bak&#125;mv tmp.file /etc/postfix/main.cfvim /etc/postfix/main.cf 123456789101112131415161718192021222324252627282930313233command_directory = /usr/sbincompatibility_level = 2daemon_directory = /usr/libexec/postfixdata_directory = /var/lib/postfixdebug_peer_level = 2debugger_command = PATH=/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin ddd $daemon_directory/$process_name $process_id &amp; sleep 5html_directory = noinet_protocols = ipv4mail_owner = postfixmailq_path = /usr/bin/mailqmanpage_directory = /usr/local/manmeta_directory = /etc/postfixnewaliases_path = /usr/bin/newaliasesqueue_directory = /var/spool/postfixreadme_directory = nosample_directory = /etc/postfixsendmail_path = /usr/sbin/sendmailsetgid_group = postdropshlib_directory = nounknown_local_recipient_reject_code = 550myhostname = mail.test.com # 邮件服务器自己的主机名，应改和邮件服务器上hostname命令结果保持一致mydomain = test.com # 邮件域myorigin = $mydomain # 发件域：发件人所在的域名，即做发件地址伪装（a@mail.test.com=&gt;a@test.com）mydestination = $myhostname, localhost.$mydomain, localhost,$mydomain# 投递域#home_mailbox = inet_interfaces = 192.168.247.108,127.0.0.1# 指定postfix系统监听的网络接口 注意： postfix服务器支持两种邮件存储方式：Mailbox和Maildir。当指定存储位置最后一位为“/”时，自动使用Maildir方式存储。Mailbox存储方式将同一用户的所有邮件内容存储在同一个文件中，通常对应为目录“/var/spool/mail”中以用户名命名的文件。Maildir存储方式使用目录结构来储存用户的邮件内容，每一个用户对应有一个文件夹，每一封邮件作为为一个独立的文件保存，通常位于用户的主目录下。 为了不修改原有的邮件存放地址，这个地方需要把home_mailbox注释掉。 在postfix的配置文件中，参数行和注释行是不能处在同一行中的； 任何一个参数的值都不需要加引号，否则，引号将会被当作参数值的一部分来使用； 每修改参数及其值后执行 postfix reload 即可令其生效；但若修改了inet_interfaces，则需重新启动postfix； 如果一个参数的值有多个，可以将它们放在不同的行中，只需要在其后的每个行前多置一个空格即可；postfix会把第一个字符为空格或tab的文本行视为上一行的延续 postfix服务 创建sysv服务脚本：/etc/rc.d/init.d/postfix 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#!/bin/bash## postfix Postfix Mail Transfer Agent## chkconfig: 2345 80 30# description: Postfix is a Mail Transport Agent, which is the program \# that moves mail from one machine to another.# processname: master# pidfile: /var/spool/postfix/pid/master.pid# config: /etc/postfix/main.cf# config: /etc/postfix/master.cf # Source function library.. /etc/rc.d/init.d/functions # Source networking configuration.. /etc/sysconfig/network # Check that networking is up.[ $NETWORKING = "no" ] &amp;&amp; exit 3 [ -x /usr/sbin/postfix ] || exit 4[ -d /etc/postfix ] || exit 5[ -d /var/spool/postfix ] || exit 6 RETVAL=0prog="postfix" start() &#123; # Start daemons. echo -n $"Starting postfix: " /usr/bin/newaliases &gt;/dev/null 2&gt;&amp;1 /usr/sbin/postfix start 2&gt;/dev/null 1&gt;&amp;2 &amp;&amp; success || failure $"$prog start" RETVAL=$? [ $RETVAL -eq 0 ] &amp;&amp; touch /var/lock/subsys/postfix echo return $RETVAL&#125; stop() &#123; # Stop daemons. echo -n $"Shutting down postfix: " /usr/sbin/postfix stop 2&gt;/dev/null 1&gt;&amp;2 &amp;&amp; success || failure $"$prog stop" RETVAL=$? [ $RETVAL -eq 0 ] &amp;&amp; rm -f /var/lock/subsys/postfix echo return $RETVAL&#125; reload() &#123; echo -n $"Reloading postfix: " /usr/sbin/postfix reload 2&gt;/dev/null 1&gt;&amp;2 &amp;&amp; success || failure $"$prog reload" RETVAL=$? echo return $RETVAL&#125; abort() &#123; /usr/sbin/postfix abort 2&gt;/dev/null 1&gt;&amp;2 &amp;&amp; success || failure $"$prog abort" return $?&#125; flush() &#123; /usr/sbin/postfix flush 2&gt;/dev/null 1&gt;&amp;2 &amp;&amp; success || failure $"$prog flush" return $?&#125; check() &#123; /usr/sbin/postfix check 2&gt;/dev/null 1&gt;&amp;2 &amp;&amp; success || failure $"$prog check" return $?&#125; restart() &#123; stop start&#125; # See how we were called.case "$1" in start) start ;; stop) stop ;; restart) stop start ;; reload) reload ;; abort) abort ;; flush) flush ;; check) check ;; status) status master ;; condrestart) [ -f /var/lock/subsys/postfix ] &amp;&amp; restart || : ;; *) echo $"Usage: $0 &#123;start|stop|restart|reload|abort|flush|check|status|condrestart&#125;" exit 1esac exit $? 启动postfix服务 1234chmod +x /etc/rc.d/init.d/postfix postfix checkchkconfig postfix onservice postfix start 部署DovecotDovecot 是一个开源的 IMAP 和 POP3 邮件服务器，支持 Linux/Unix 系统。 安装 1yum -y install openssl-devel pam-devel dovecot 服务配置 12chkconfig --add dovecotchkconfig --level 2345 dovecot on 修改主配置文件 1vim /etc/dovecot/dovecot.conf 12345678# 修改第24行的支持邮局协议。protocols = imap pop3 lmtp# 修改第26行监听选项，如果不支持IPv6使用*listen = *# 允许登陆网段地址，全部允许即为（0.0.0.0/0）#login_trusted_networks = 192.168.247.0/24 允许明文认证/etc/dovecot/conf.d/10-auth.conf 1disable_plaintext_auth = no 配置邮件的格式与存储路径/etc/dovecot/conf.d/10-mail.conf 12mail_location = mbox:~/mail:INBOX=/var/mail/%u# 这里的路径一定要和postfix的保持一致（postconf | grep mail_spool_directory） 启动Dovecot服务程序 12chkconfig dovecot onservice dovecot restart 部署Cyrus SASL在Postfix邮件系统中，可以使用Cyrus SASL（Cyrus Simple Authentication and Security Layer，Cyrus简单认证安全层）软件来实现基本的SMTP认证。Postfix通过连接Cyrus SASL的函数库，调用认证服务saslauthd来核对系统账号和密码 安装 12345yum -y install cyrus-sasl*# 设置cyrus SASL 函数库echo -e 'pwcheck_method:saslauthd\nmech_list: PLAIN LOGIN' &gt;&gt; /usr/lib64/sasl2/smtpd.confcp /usr/lib64/sasl2/smtpd.conf /etc/sasl2/ 配置 1vim /etc/sysconfig/saslauthd 123MECH=shadow# 认证方式改为帐号密码认证。# saslauthd -v 可显示当前主机saslauthd服务支持的认证方式 12service saslauthd startchkconfig --level 2345 saslauthd on 修改postfix配置文件，加入配置 123456789101112131415161718192021222324252627282930313233#####################---CYRUS-SASL---#####################broken_sasl_auth_clients = yes# 是否通过sasl来验证clientsmtpd_recipient_restrictions=permit_mynetworks,permit_sasl_authenticated,reject_invalid_hostname,reject_non_fqdn_hostname,reject_unknown_sender_domain,reject_non_fqdn_sender,reject_non_fqdn_recipient,reject_unknown_recipient_domain,reject_unauth_pipelining,reject_unauth_destination# 收件人限定# permit_mynetworks 允许本地网络# permit_sasl_authenticated 允许sasl验证通过的用户# reject_invalid_hostname 拒绝主机名不合法的主机来收发邮件# reject_non_fqdn_hostname 拒绝非fqdn格式的主机来收发邮件# reject_unknown_sender_domain 拒绝无法识别的发件人# reject_non_fqdn_sender 拒绝非fqdn格式的发件人# reject_non_fqdn_sender 拒绝非fqdn格式的收件人# reject_unknown_recipient_domain 拒绝无法识别的收件人域# reject_unauth_pipelining 拒绝无法验证的管道# reject_unauth_destination 拒绝未认证的目标，此项必须放到最后smtpd_sasl_auth_enable = yes# 启用sasl认证功能smtpd_sasl_local_domain = $myhostname# 基于sasl认证的时候，我们本地的域smtpd_sasl_security_options = noanonymous# 禁止匿名发信smtpd_sasl_path = smtpd# 指定要使用ssl功能的服务器程序 mynetworks = 127.0.0.0/8# 只允许给本地中继（注意：上面的smtpd_recipient_restrictions明确规定了permit_sasl_authenticated，允许给通过sasl认证的用户做邮件中继）# 设置内网和本地IP指定你所在的网络的网络地址# postfix根据其值来区别用户是远程的还是本地的，如果是本地网络用户则允许其访问 帐号的添加和测试 邮箱账号采用的是系统账号，属组应该为邮件组mail，所以邮箱开通的时候，实际上是创建了一个系统账号。 命令要求 123456789101112131415userdel -r test1userdel -r test2useradd -u 1300 -g mail -s /usr/bin/passwd test1echo test1 | passwd --stdin test1useradd -u 1301 -g mail -s /usr/bin/passwd test2echo test2 | passwd --stdin test2 # -c 添加新账号说明，一般是账号名称，但是每个字的首字母大写。# -u uid编号，我们添加的时候，要先查看/etc/passwd的内容，看当前最后一个账号的uid，然后确定这里填写的数字。# -g gid编号，这个必须是mail组，否则会导致权限不足# -s 的设置也是固定的，不可更改，邮箱用户将不应直接登录邮件服务器。# test1 账号名称。testsaslauthd -u test1 -p test1# 帐号认证测试 使用outlook进行两个用户之间邮件的发送接收测试 常见问题 映射表问题 12345# /var/log/mail/log中显示Recipient address rejected: User unknown in local recipient table# 修改postfix主配置local_recipient_maps = 权限问题 12345# /var/log/mail/log中显示Mar 25 02:19:34 mail dovecot: pop3(test1): Couldn't open INBOX top=0/0, retr=0/0, del=0/0, size=0Mar 25 02:19:34 mail dovecot: pop3-login: Login: user=&lt;test2&gt;, method=PLAIN, rip=192.168.247.1, lip=192.168.247.108, mpid=51169Mar 25 02:19:34 mail dovecot: pop3(test2): Error: chown(/home/test2/mail/.imap/INBOX, -1, 12(mail)) failed: Operation not permitted (egid=2831(test2), group based on /var/mail/test2)# 权限不足，添加邮件帐号时指定属组为mail即可 日志/var/log/mail/log被勿删 1234567# maillog日志是在syslog.conf文件中定义的，内容如下：# Log all the mail messages in one place.mail.* -/var/log/maillog# 重启log服务即可：service rsyslog restart 邮件服务器收发正常但OE无法收信 核对postfix中的邮箱路径 postconf -d | grep mail_spool_directory与dovecot中的邮箱路径mail_location = mbox:~/mail:INBOX=/var/mail/%u是否一致 客户端和服务器端时间是否正确及是否同步（执行/usr/sbin/ntpdate time.nist.gov进行时间同步） 为postfix开启基于hash的别名文件支持 在main.cf中添加如下配置 12alias_database = hash:/etc/aliasesalias_maps = hash:/etc/aliases 在/etc/aliases文件中定义新的别名项其格式通常为以冒号隔开的两个字段，前一个字段为初始目标邮件地址，后一个字段为实际发往的地址，如： 12net_operation : zhangsan,lisi,wangwu# 发送给net_operation@test.com的邮件将发送给张三、李四、王五 将/etc/aliases转换为hash格式： 12postalias /etc/aliasesservice postfix reload postfix基于客户端的访问控制 postfix内置了多种反垃圾邮件的机制，其中就包括“客户端”发送邮件限制。客户端判别机制可以设定一系列客户信息的判别条件： 123456smtpd_client_restrictions：当客户端发起连接请求时，判别此客户端IP的访问权限smtpd_helo_restrictions ： 限定哪些客户端可以发送helo指令smtpd_sender_restrictions ：限定哪些客户端可以发送mail from指令smtpd_recipient_restrictions：限定哪些用户可以发送rctp to指令smtpd_data_restrictions：限定哪些用户可以发送data指令以上每一项参数分别用于检查SMTP会话过程中的特定阶段，即客户端提供相应信息的阶段。 如果DATA命令之前的所有内容都被接受，客户端接着就可以开始传送邮件内容了。邮件内容通常由两部分组成，前半部分是标题(header)，其可以由header_check过滤，后半部分是邮件正文(body)，其可以由check_body过滤。这两项实现的是邮件“内容检查”。 postfix的默认配置如下： 12345678910smtpd_client_restrictions =smtpd_data_restrictions =smtpd_end_of_data_restrictions =smtpd_etrn_restrictions =smtpd_helo_restrictions =smtpd_recipient_restrictions = permit_mynetworks, reject_unauth_destinationsmtpd_sender_restrictions =# 这限制了只有mynetworks参数中定义的本地网络中的客户端才能通过postfix转发邮件，# 其它客户端则不被允许，从而关闭了开放式中继(open relay)的功能。 Postfix有多个内置的限制条件，如上面的permit_mynetworks和reject_unauth_destination，但管理员也可以使用访问表(access map)来自定义限制条件。自定义访问表的条件通常使用check_client_access, check_helo_access, check_sender_access, check_recipient_access进行，它们后面通常跟上type:mapname格式的访问表类型和名称。其中，check_sender_access和check_recipient_access用来检查客户端提供的邮件地址，因此其访问表中可以使用完整的邮件地址，如admin@test.com；也可以只使用域名，test.com；还可以只有用户名的部分，如marion@。 实现示例1这里以禁止172.16.100.200这台主机通过工作在172.16.100.1上的postfix服务发送邮件为例演示说明其实现过程。访问表使用hash的格式。 1234567891011# 首先，编辑/etc/postfix/access文件，以之作为客户端检查的控制文件，在里面定义如下一行：172.16.100.200 REJECT# 其次，将此文件转换为hash格式postmap /etc/postfix/access# 然后，配置postfix使用此文件对客户端进行检查# 编辑/etc/postfix/main.cf文件，添加如下参数：smtpd_client_restrictions = check_client_access hash:/etc/postfix/access# 最后，让postfix重新载入配置文件即可进行发信控制的效果测试了。 实现示例2这里以禁止通过本服务器向microsoft.com域发送邮件为例演示其实现过程。访问表使用hash的格式。 1234567891011# 首先，建立/etc/postfix/denydstdomains文件(文件名任取)，在里面定义如下一行：microsoft.com REJECT# 其次，将此文件转换为hash格式postmap /etc/postfix/denydstdomains# 然后，配置postfix使用此文件对客户端进行检查# 编辑/etc/postfix/main.cf文件，添加如下参数：smtpd_recipient_restrictions = check_recipient_access hash:/etc/postfix/denydstdomains, permit_mynetworks, reject_unauth_destination# 最后，让postfix重新载入配置文件即可进行发信控制的效果测试了。 检查表格式的说明 hash类的检查表都使用类似如下的格式： 123pattern action# 检查表文件中，空白行、仅包含空白字符的行和以#开头的行都会被忽略。# 以空白字符开头后跟其它非空白字符的行会被认为是前一行的延续，是一行的组成部分。 关于pattern其pattern通常有两类地址：邮件地址和主机名称/地址。 12345678910111213邮件地址的pattern格式如下：user@domain 用于匹配指定邮件地址；domain.tld 用于匹配以此域名作为邮件地址中的域名部分的所有邮件地址；user@ 用于匹配以此作为邮件地址中的用户名部分的所有邮件地址；主机名称/地址的pattern格式如下：domain.tld 用于匹配指定域及其子域内的所有主机；.domain.tld 用于匹配指定域的子域内的所有主机；net.work.addr.essnet.work.addrnet.worknet 用于匹配特定的IP地址或网络内的所有主机；network/mask CIDR格式，匹配指定网络内的所有主机； 关于action 1234567891011接受类的动作：OK 接受其pattern匹配的邮件地址或主机名称/地址；全部由数字组成的action 隐式表示OK；拒绝类的动作(部分)：4NN text 5NN text # 其中4NN类表示过一会儿重试；5NN类表示严重错误，将停止重试邮件发送；# 421和521对于postfix来说有特殊意义，尽量不要自定义这两个代码；REJECT optional text... 拒绝；text为可选信息；DEFER optional text... 拒绝；text为可选信息； 常见需求的配置特定人员发送特定邮件 公司需求只有公司高层才可以向全体员工发送邮件，除此之外均无权向全体员工发送邮件 公司高层邮箱：wanglujing@test.comrenlina@test.comcaiyanyan@test.comqinwen@test.comshiwanting@test.com 全体员工邮箱：allemp@test.com 主配置文件中需要用到的参数(具体的请参考《postfix权威指南》，在第十一章 反垃圾邮件) smtmpd_restriction_classes自定义规范等级的名称,列出管理员自定义的所有规范等级，每一组规范等级，都是由一系列UBE（挡信）限制条件组成。 check_client_access 客户端 check_sender_access 发件人 check_recipient_access 收件人 check_recipient_access maptype:mapname check_recipient_access指向一个含有邮件地址、网域名称、人名的访问表，用于对比客户端在RCPT TO命令中提供的收件地址，如果发现相符的索引键，则postfix执行相对应的值所提定的动作。 check_sender_access maptype:mapnamecheck_sender_access 指向一个含有邮件地址，网域名称,人名的访问表，用于对比客户端在MAIL FROM命令中提供的寄件人邮件地址，如果发现相符的索引键，则postfix执行相对应的值所指定的动作。 涉及的处理动作 OK 通过当前过滤规则的检查，postfix继续检查下一组过滤规则。 REJECT 拒绝邮件，后面可以加上一段简短信息，说明拒绝的理由，这段信息会连同拒绝码一起返回给客户端，并且被记录在postfix日志文件中。 解决方法 定义规范等级，分别为local_sender_all，allow_to_all 1234# 在postfix主配置文件中，末尾添加下列语句smtpd_restriction_classes = local_sender_all,allow_to_alllocal_sender_all = check_sender_access hash:/etc/postfix/plugin/local_sender_all,rejectallow_to_all = check_recipient_access hash:/etc/postfix/plugin/allow_to_all,reject 创建限定的收件人文件 12install -cdv /etc/postfix/pluginvim /etc/postfix/plugin/allow_to_all 1allemp@test.com allow_to_all 创建限定的发件人文件 1vim /etc/postfix/plugin/local_sender_all 12345wanglujing@test.com OK renlina@test.com OK caiyanyan@test.com OK qinwen@test.com OK shiwanting@test.com OK 使用postmap生成数据库文件 12postmap /etc/postfix/plugin/allow_to_all postmap /etc/postfix/plugin/local_sender_all 邮件发送控制 对于外域到本域的邮件，必须接收，否则，收不到任何来自外部的邮件 对于本域到外域的邮件，只允许从本机发出，否则其他人通过伪造本域地址就可以向外域发信 对于外域到外域的邮件，直接拒绝，否则我们的邮件服务器就是Open Relay，将被视为垃圾邮件服务器 设置发件人的规则 12smtpd_sender_restrictions = permit_mynetworks, check_sender_access hash:/etc/postfix/plugin/sender_access, permit# 以上规则先判断是否是本域地址，如果是则允许，然后再从sender_access文件里检查发件人是否存在，拒绝存在的发件人，最后允许其他发件人。 设置收件人的规则 12smtpd_recipient_restrictions = permit_mynetworks, check_recipient_access hash:/etc/postfix/plugin/recipient_access, reject# 以上规则先判断是否是本域地址，如果是则允许，然后再从recipient_access文件里检查收件人是否存在，允许存在的收件人，最后拒绝其他收件人。]]></content>
      <categories>
        <category>Services</category>
      </categories>
      <tags>
        <tag>postfix</tag>
        <tag>mail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LAMP编译安装（php基于fastcgi协议编译为php-fpm）]]></title>
    <url>%2F2016%2F02%2F16%2F2016-02-16-120546-LAMP%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%EF%BC%88php%E5%9F%BA%E4%BA%8Efastcgi%E5%8D%8F%E8%AE%AE%E7%BC%96%E8%AF%91%E4%B8%BAphp-fpm%EF%BC%89%2F</url>
    <content type="text"><![CDATA[环境准备： 12yum -y groupinstall "Compatibility libraries" "Development tools" "Server Platform Development"# 解决依赖关系，安装开发环境软件包组 MySQL5.5.53二进制通用包安装准备数据存放的文件系统 新建一个逻辑卷，并将其挂载至特定目录即可。这里不再给出过程。 逻辑卷的挂载目录为/data，而后需要创建/data/mysqldata目录做为mysql数据的存放目录。 12345678910111213141516171819202122mkdir -pv /datafdisk /dev/sdb &lt;&lt; 'EOF'np1+18Gt8ewEOFkpartx -af /dev/sdbpartx -a /dev/sdbcat /proc/partitions pvcreate /dev/sdb1vgcreate myvg /dev/sdb1lvcreate -L 10G -n mysqldata myvgmke2fs -t ext4 /dev/myvg/mysqldata echo '/dev/myvg/mysqldata /data ext4 defaults,noatime 0 0 ' &gt;&gt; /etc/fstabmount -a# 为MySQL单独挂载一块硬盘，对其进行分区，创建lvm并挂载 解决依赖关系并安装所需环境1yum -y install autoconf automake imake libxml2-devel expat-devel cmake gcc gcc-c++ libaio libaio-devel bzr bison libtool ncurses5-devel 新建用户以安全方式运行进程1234567groupadd -r mysql# 添加一个系统组useradd -g mysql -r -s /sbin/nologin mysql# 添加一个不允许登录系统的MySQL系统用户cd /data/;mkdir -pv mysqldata;chown -R mysql.mysql /data/mysqldata/# 创建mysql的数据存放目录 安装并初始化mysql-5.5.33首先下载平台对应的mysql版本至本地，这里是64位平台，因此选择的为mysql-5.5.53-linux2.6-x86_64.tar.gz，下载位置为：http://mirrors.sohu.com/mysql/MySQL-5.5/mysql-5.5.53-linux2.6-x86_64.tar.gz 。32位平台需要下载i686的包。 123456789101112tar xf mysql-5.5.53-linux2.6-x86_64.tar.gz -C /usr/local/# 解压二进制包到指定目录cd /usr/local/;ln -sv mysql-5.5.53-linux2.6-x86_64 mysql# 创建软链接，方便以后MySQL版本升级或更新cd mysqlchown -R mysql.mysql /usr/local/mysql/*# 属主、数组修改chown -R root.mysql /usr/local/mysql*cd /usr/local/mysqlscripts/mysql_install_db --datadir=/data/mysqldata/ --user=mysql# 对系统库做初始化 为mysql提供主配置文件12345678cp support-files/my-large.cnf /etc/my.cnf# 创建并修改MySQL配置文件sed -ri '/\[mysqld\]/adatadir=/data/mysqldata' /etc/my.cnf # 指定mysql数据文件的存放位置# thread_concurrency = 2sed -ri "sS(thread_concurrency =).*S\1 $(( `/bin/egrep -cw "processor" /proc/cpuinfo ` * 2 ))S" /etc/my.cnf # 修改此文件中thread_concurrency的值为你的CPU个数乘以2 为mysql提供sysv服务脚本123456789cp -a support-files/mysql.server /etc/rc.d/init.d/mysqldchmod +x /etc/rc.d/init.d/mysqldchkconfig --add mysqldchkconfig --level 2345 mysqld onchkconfig --list mysqld# 创建服务脚本，添加到系统服务service mysqld start# 启动服务 附加配置为了使用mysql的安装符合系统使用规范，并将其开发组件导出给系统使用，这里做如下配置 123456789101112131415161718192021222324252627# 输出mysql的man手册至man命令的查找路径# 编辑/etc/man.config，添加如下行即可：MANPATH /usr/local/mysql/manecho 'export PATH=/usr/local/mysql/bin:$PATH' &gt;| /etc/profile.d/mysqlbin.sh. /etc/profile.d/mysqlbin.sh#修改PATH环境变量，让系统可以直接使用mysql的相关命令ln -sv /usr/local/mysql/include/ /usr/include/mysql# 输出mysql的头文件至系统头文件路径/usr/includeecho '/usr/local/mysql/lib/' &gt; /etc/ld.so.conf.d/mysqllib.conf# 输出mysql的库文件给系统库查找路径ldconf# 让系统重新载入系统库ldconfig -p | grep mysqlmysql&gt; use mysql;mysql&gt; select user,host,password from user;mysql&gt; drop user ''@'localhost';mysql&gt; drop user ''@'test';mysql&gt; update user set password=password('hehedada') where user='root';mysql&gt; flush privileges;# 删除匿名用户，修改密码mysql -u root -P 3306 -h 127.0.0.1 -p# 测试 httpd2.4.23编译安装站点： httpd站点：http://httpd.apache.org/ apr-util站点：https://www.apache.org/dist/apr/apr-util-1.5.4.tar.bz2 apr站点：https://www.apache.org/dist/apr/apr-1.5.2.tar.bz2 解决依赖关系httpd2.4.23需要较新版本的apr和apr-util，因此需要事先对其进行升级。升级方式有两种，一种是通过源代码编译安装，一种是直接升级rpm包。这里选择使用编译源代码的方式进行。 1234567891011121314151617181920212223242526service httpd stop# 停止现有的httpd服务chkconfig httpd off# 关闭现有httpd服务的启动yum -y install pcre-devel zlib-devel gcc gcc-c++# 安装pcre(Perl语言正则表达式库)、zlib库tar xf apr-1.5.2.tar.bz2 cd apr-1.5.2./configure --prefix=/usr/local/apr-1.5.2make &amp;&amp; make install# 安装apr(apache portable runtime)tar xf apr-util-1.5.4.tar.bz2 cd apr-util-1.5.4./configure --prefix=/usr/local/apr-util-1.5.4 --with-apr=/usr/local/apr-1.5.2/make &amp;&amp; make install# 安装apr-util附：apache官方对APR的介绍：The mission of the Apache Portable Runtime (APR) project is to create and maintain software libraries that provide a predictable and consistent interface to underlying platform-specific implementations. The primary goal is to provide an API to which software developers may code and be assured of predictable if not identical behaviour regardless of the platform on which their software is built, relieving them of the need to code special-case conditions to work around or take advantage of platform-specific deficiencies or features. 安装httpd2.4.231234tar xf httpd-2.4.23.tar.bz2 cd httpd-2.4.23 ./configure --prefix=/usr/local/apache --sysconfdir=/etc/httpd2.4.23 --enable-so --enable-headers --enable-expires --enable-ssl --enable-cgi --enable-rewrite --with-zlib --with-pcre --with-apr=/usr/local/apr-1.5.2/ --with-apr-util=/usr/local/apr-util-1.5.4/ --enable-modeles=most --enable-mpms-shared=all --with-mpm=event --enable-deflatemake &amp;&amp; make install 123456789101112131415161718192021222324252627282930313233343536373839# #--prefix=/usr/local/apache# 设定httpd的安装目录#--sysconfdir=/etc/httpd2.4.23# 设定httpd的配置文件目录#--enable-so# 激活apache服务的DSO（Dynamic Shared Objects动态共享目标）# 即在以后可以以DSO的方式编译安装共享模块# 这个模块本身不能以DSO方式编译支持共享模块，如果没有这个则PHP模块无法加入#--enable-headers# 提供允许对HTTP请求头的控制 #--enable-expires# 激活通过配置文件控制HTTP的“Expires:”和“Cache-Control:”头内容# 即对网站图片、js、css等内容，提供客户端浏览器缓存的设置# 这个是apache调优的一个重要选项之一。#--enable-ssl # 支持ssl#--enable-cgi# 支持cgi#--enable-rewrite# 支持url重写#--with-zlib# 支持zlib压缩，传输层的压缩（不指定具体的路径，默认在系统中搜索）#--with-pcre# 支持正则化（不指定具体的路径，默认在系统中搜索）#--with-apr=/usr/local/apr-1.5.2/# 指定apr的路径#--with-apr-util=/usr/local/apr-util-1.5.4/# 指定apr-util的路径#--enable-modules=most# 指定要编译的模块(most/all)#--enable-mpms-shared=all# 指定要编译mpm#--with-mpm=event# 指定httpd默认的MPM的工作方式 #--enable-deflate# 提供对内容的压缩传输编码支持，一般是html、js、css等内容的站点。# 使用此参数会打打提高传输速度，提升访问者访问的体验。# 在生产环境中，这是apache调优的一个重要选项之一。 补充： 构建MPM为静态模块 在全部平台中，MPM都可以构建为静态模块。在构建时选择一种MPM，链接到服务器中。如果要改变MPM，必须重新构建。为了使用指定的MPM，请在执行configure脚本 时，使用参数 –with-mpm=NAME。NAME是指定的MPM名称。编译完成后，可以使用 ./httpd -l 来确定选择的MPM。 此命令会列出编译到服务器程序中的所有模块，包括 MPM。 构建 MPM 为动态模块 在Unix或类似平台中，MPM可以构建为动态模块，与其它动态模块一样在运行时加载。 构建 MPM 为动态模块允许通过修改LoadModule指令内容来改变MPM，而不用重新构建服务器程序。在执行configure脚本时，使用–enable-mpms-shared选项即可启用此特性。当给出的参数为all时，所有此平台支持的MPM模块都会被安装。还可以在参数中给出模块列表。默认MPM，可以自动选择或者在执行configure脚本时通过–with-mpm选项来指定，然后出现在生成的服务器配置文件中。编辑LoadModule指令内容可以选择不同的MPM。 配置备份配置文件 1cp /etc/httpd2.4.23/httpd.conf&#123;,.bak&#125; 在配置文件/etc/httpd2.4.23/httpd.conf加入pid配置 1PidFile "/var/run/httpd.pid" 提供SysV服务脚本服务脚本/etc/rc.d/init.d/httpd 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#!/bin/bash## httpd Startup script for the Apache HTTP Server## chkconfig: - 85 15# description: Apache is a World Wide Web server. It is used to serve \# HTML files and CGI.# processname: httpd# config: /etc/httpd2.4.23/httpd.conf# config: /etc/sysconfig/httpd# pidfile: /var/run/httpd.pid# Source function library.. /etc/rc.d/init.d/functionsif [ -f /etc/sysconfig/httpd ]; then . /etc/sysconfig/httpdfi# Start httpd in the C locale by default.HTTPD_LANG=$&#123;HTTPD_LANG-"C"&#125;# This will prevent initlog from swallowing up a pass-phrase prompt if# mod_ssl needs a pass-phrase from the user.INITLOG_ARGS=""# Set HTTPD=/usr/sbin/httpd.worker in /etc/sysconfig/httpd to use a server# with the thread-based "worker" MPM; BE WARNED that some modules may not# work correctly with a thread-based MPM; notably PHP will refuse to start.# Path to the apachectl script, server binary, and short-form for messages.apachectl=/usr/local/apache/bin/apachectlhttpd=$&#123;HTTPD-/usr/local/apache/bin/httpd&#125;prog=httpdpidfile=$&#123;PIDFILE-/var/run/httpd.pid&#125;lockfile=$&#123;LOCKFILE-/var/lock/subsys/httpd&#125;RETVAL=0start() &#123; echo -n $"Starting $prog: " LANG=$HTTPD_LANG daemon --pidfile=$&#123;pidfile&#125; $httpd $OPTIONS RETVAL=$? echo [ $RETVAL = 0 ] &amp;&amp; touch $&#123;lockfile&#125; return $RETVAL&#125;stop() &#123; echo -n $"Stopping $prog: " killproc -p $&#123;pidfile&#125; -d 10 $httpd RETVAL=$? echo [ $RETVAL = 0 ] &amp;&amp; rm -f $&#123;lockfile&#125; $&#123;pidfile&#125;&#125;reload() &#123; echo -n $"Reloading $prog: " if ! LANG=$HTTPD_LANG $httpd $OPTIONS -t &gt;&amp;/dev/null; then RETVAL=$? echo $"not reloading due to configuration syntax error" failure $"not reloading $httpd due to configuration syntax error" else killproc -p $&#123;pidfile&#125; $httpd -HUP RETVAL=$? fi echo&#125;# See how we were called.case "$1" in start) start ;; stop) stop ;; status) status -p $&#123;pidfile&#125; $httpd RETVAL=$? ;; restart) stop start ;; condrestart) if [ -f $&#123;pidfile&#125; ] ; then stop start fi ;; reload) reload ;; graceful|help|configtest|fullstatus) $apachectl $@ RETVAL=$? ;; *) echo $"Usage: $prog &#123;start|stop|restart|condrestart|reload|status|fullstatus|graceful|help|configtest&#125;" exit 1esacexit $RETVAL 添加权限1chmod +x /etc/rc.d/init.d/httpd 添加服务和环境变量123456789chkconfig --add httpdchkconfig --level 2345 httpd onchkconfig --list httpdecho 'export PATH=/usr/local/apache/bin/:$PATH' &gt; /etc/profile.d/apachebin.sh. /etc/profile.d/apachebin.shecho '192.1.68.2.105 www.test.com' &gt;&gt; /etc/hosts # 避免启动服务时报解析错误 服务启动和验证123service httpd startss -tnl | grep 80service httpd status 报错：httpd dead but subsys locked 解决方法：rm -f /var/lock/subsys/httpd，并检查pid配置是否正确 编译安装php-fpm解决依赖关系Mcrypt是PHP的一个扩展，完成了常用加密算法的封装。其实该扩展是对mcrypt标准类库的封装，mcrypt完成了相当多的常用加密算法，如DES, TripleDES, Blowfish (default), 3-WAY, SAFER-SK64, SAFER-SK128, TWOFISH, TEA, RC2 和 GOST加密算法，并且提供了CBC、OFB、CFB 和 ECB 四种块加密的模型。要使用该扩展，必须首先安装mcrypt标准类库，注意的是mcrypt软件依赖libmcrypt和mhash两个库。 环境和库 1234yum -y groupinstall "Desktop Platform Development" # 桌面平台环境，开发所需yum -y install zlib-devel libxml2-devel libjpeg-devel libjpeg-turbo-devel libiconv-devel libmcrypt-devel mhash mcrypt freetype-devel libpng-devel gd-devel libcurl-devel libxslt-devel libxslt-devel openssl-devel libzip# 依赖库安装 libmcrypt（安装mcrypt需要此软件包） 123456cd wget http://nchc.dl.sourceforge.net/project/mcrypt/Libmcrypt/2.5.8/libmcrypt-2.5.8.tar.gztar xf libmcrypt-2.5.8.tar.bz2 cd libmcrypt-2.5.8./configure --prefix=/usr/local/make &amp;&amp; make install mhash（安装mcrypt需要此软件包） 123456cdwget https://acelnmp.googlecode.com/files/mhash-0.9.9.9.tar.gztar xf mhash-0.9.9.9.tar.gz cd mhash-0.9.9.9./configure --prefix=/usr/local/make &amp;&amp; make install mcrypt扩展 123456789101112131415cdwget https://lcmp.googlecode.com/files/mcrypt-2.6.8.tar.gztar xf mcrypt-2.6.8.tar.gzln -s /usr/local/bin/libmcrypt-config /usr/bin/libmcrypt_config# 添加链接，以免libmcrypt未搜索到echo -e '/usr/local/lib' &gt; /etc/ld.so.conf.d/libmcrypt_lg.confldconfig# 添加库搜索路径export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH# 由于在配置Mcrypt时，会找不到libmcrypt的链接库，导致无法编译# 因为Libmcrypt的链接库在/usr/local/lib文件夹下。# 因此在配置mcrypt时要加入LD_LIBRARY_PATH=/usr/local/lib导入键接库cd mcrypt-2.6.8./configure --prefix=/usr/local/mcrypt make &amp;&amp; make install 编译安装php-fpm 5.4.27 站点 http://php.net/releases/ http://php.net/get/php-5.4.27.tar.bz2/from/a/mirror 123456789101112131415161718192021222324cdtar xf php-5.4.27.tar.bz2 cd php-5.4.27./configure \--prefix=/usr/local/php-fpm \--with-mysql=/usr/local/mysql \--with-openssl \--with-mysqli=/usr/local/mysql/bin/mysql_config \--enable-mbstring \--with-freetype-dir \--with-jpeg-dir \--with-png-dir \--with-zlib \--enable-xml \--with-libxml-dir=/usr \--enable-sockets \--enable-fpm \--with-mcrypt=/usr/local/mcrypt \--with-mhash \--with-config-file-path=/etc \--with-config-file-scan-dir=/etc/php.d \--with-bz2make &amp;&amp; make intallls /usr/local/php/ 说明 如果使用PHP5.3以上版本，为了链接MySQL数据库，可以指定mysqlnd，这样在本机就不需要先安装MySQL或MySQL开发包了。mysqlnd从php 5.3开始可用，可以编译时绑定到它（而不用和具体的MySQL客户端库绑定形成依赖），但从PHP 5.4开始它就是默认设置了。 如果MySQL和PHP不在一台主机，使用with-mysql时，都直接指定为mysqlnd，表示MySQL不在本机，而是在另外的其他主机上./configure --with-mysql=mysqlnd --with-pdo-mysql=mysqlnd --with-mysqli=mysqlnd 参数说明 123456789101112131415161718--prefix # 程序安装路径--with-mysql= # mysql安装路径，对mysql的支持--with-openssl # 启用ssl支持--with-mysqli= # mysqli扩展技术不仅可以调用MySQL的存储过程、处理MySQL事务，而且还可以使访问数据库工作变得更加稳定--enable-mbstring # 启用多字节字符串支持--with-freetype-dir # 打开对freetype字体库的支持 --with-jpeg-dir # 打开对jpeg图片的支持--with-png-dir # 打开对png图片的支持--with-zlib # 使用压缩库--enable-xml # 启用解析xml文件--with-libxml-dir= # libxml的路径--enable-sockets # 支持基于socket通信--enable-fpm # 启用fpm--with-mcrypt # mcrypt算法扩展--with-mhash # mhash算法扩展--with-config-file-path= # 配置文件路径--with-config-file-scan-dir= # 此目录下所有.ini结尾的文件都被当作配置文件的一部分--with-bz2 # 打开对bz2文件的支持 为php提供配置文件1cp php.ini-production /etc/php.ini 配置php-fpm 为php-fpm提供SysV init脚本，并将其添加至服务列表 1234cp sapi/fpm/init.d.php-fpm /etc/rc.d/init.d/php-fpmchmod +x /etc/rc.d/init.d/php-fpmchkconfig --add php-fpmchkconfig php-fpm on 为php-fpm提供配置文件 1cp /usr/local/php-fpm/etc/php-fpm.conf.default /usr/local/php-fpm/etc/php-fpm.conf 编辑php-fpm的配置文件 vim /usr/local/php/etc/php-fpm.conf 配置fpm的相关选项为你所需要的值，并启用pid文件（如下最后一行）： 123456789101112pm.max_children = 50# 最大子进程数pm.start_servers = 5# 程序启动时启动的子进程数pm.min_spare_servers = 2# 最小空闲进程数pm.max_spare_servers = 8# 最大空闲进程数pid = /usr/local/php/var/run/php-fpm.pid# pid文件路径（和php-fpm服务脚本中pid保持一致）error_log = log/php-fpm.log# 启用记录错误日志 服务验证12345678service php-fpm start# 使用如下命令来验正（如果此命令输出有中几个php-fpm进程就说明启动成功了）：ps aux | grep php-fpm# 默认情况下，fpm监听在127.0.0.1的9000端口，也可以使用如下命令验正其是否已经监听在相应的套接字。netstat -tnlp | grep php-fpmtcp 0 0 127.0.0.1:9000 0.0.0.0:* LISTEN 689/php-fpm 配置apache，支持php-fpm12service httpd stopvim /etc/httpd2.4.23/httpd.conf 定位AddType，添加如下二行 12AddType application/x-httpd-php .phpAddType application/x-httpd-php-source .phps 定位至DirectoryIndex index.html，修改为： 1DirectoryIndex index.php index.html 在Apache httpd 2.4以后已经专门有一个模块针对FastCGI的实现，此模块为mod_proxy_fcgi.so，它其实是作为mod_proxy.so模块的扩充，因此，这两个模块都要加载。将配置文件中以下两行去掉注释 12LoadModule proxy_module modules/mod_proxy.soLoadModule proxy_fcgi_module modules/mod_proxy_fcgi.so 配置虚拟主机支持使用fcgi基本结构1234 ProxyRequests Off# 关闭正向代理，而是用反向代理 ProxyPassMatch ^/(.*\.php)$ fcgi://127.0.0.1:9000/PATH/TO/DOCUMENT_ROOT/$1# 把用户请求内容转向后端代理服务 配置 1234# 关闭中心主机# DocumentRoot "/usr/local/apache/htdocs"# Virtual hostsInclude /etc/httpd2.4.23/extra/httpd-vhosts.conf 123cp /etc/httpd2.4.23/extra/httpd-vhosts.conf&#123;,.default&#125;mkdir -pv /www/&#123;a.com,b.cn&#125;/htdocsvim /etc/httpd2.4.23/extra/httpd-vhosts.conf 说明http://www.test.com/admin/index.php 对应后端服务器绝对路径：/web/host1/admin/index.php那么fcgi路径：fcgi://127.0.0.1:9000/web/hosts/admin/index.php 示例/etc/httpd2.4.23/extra/httpd-vhosts.conf 12345678910111213141516171819202122232425262728293031&lt;VirtualHost *:80&gt; ServerAdmin webadmin@a.com DocumentRoot "/www/a.com/htdocs/" ServerName www.a.com ServerAlias a.com ErrorLog "logs/www.a.com-error_log" CustomLog "logs/www.a.com-access_log" combined &lt;Directory "/www/a.com/htdocs/"&gt; Options None AllowOverride none Require all granted &lt;/Directory&gt; ProxyRequests Off ProxyPassMatch ^/(.*\.php)$ fcgi://127.0.0.1:9000/www/a.com/htdocs/$1&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt; ServerAdmin webadmin@b.cn DocumentRoot "/www/b.cn/htdocs/" ServerName www.b.cn ServerAlias b.cn ErrorLog "logs/www.b.cn-error_log" CustomLog "logs/www.b.cn-access_log" combined &lt;Directory "/www/b.cn/htdocs/"&gt; Options None AllowOverride none Require all granted &lt;/Directory&gt; ProxyRequests Off ProxyPassMatch ^/(.*\.php)$ fcgi://127.0.0.1:9000/www/b.cn/htdocs/$1 &lt;/VirtualHost&gt; 虚拟主机的测试页 /www/a.com/htdocs/index.php 1234567891011a.com&lt;?php $link = mysql_connect('127.0.0.1','root','hehedada'); if ($link) echo "Success..."; else echo "Failure..."; mysql_close(); phpinfo();?&gt; /www/b.cn/htdocs/index.php 1234567891011b.cn&lt;?php $link = mysql_connect('127.0.0.1','root','hehedada'); if ($link) echo "Success..."; else echo "Failure..."; mysql_close(); phpinfo();?&gt; 服务验证 windows和linux虚机hosts windows192.168.2.110 www.a.com192.168.2.110 www.b.cn Linux192.168.2.110 www.a.com a.com192.168.2.110 www.b.cn b.cn 重新启动httpd，或让其重新载入配置文件即可测试php是否已经可以正常使用。 123httpd -tservice httpd restarthttpd -M 启用服务器状态mod_status模块可以让管理员查看服务器的执行状态，它通过一个HTML页面展示了当前服务器的统计数据。这些数据通常包括但不限于：(1) 处于工作状态的worker进程数；(2) 空闲状态的worker进程数；(3) 每个worker的状态，包括此worker已经响应的请求数，及由此worker发送的内容的字节数；(4) 当前服务器总共发送的字节数；(5) 服务器自上次启动或重启以来至当前的时长；(6) 平均每秒钟响应的请求数、平均每秒钟发送的字节数、平均每个请求所请求内容的字节数； 状态信息不应该被所有人随意访问，因此应该限制仅允许某些特定地址的客户端查看。比如使用Require ip 172.16.0.0/16来限制仅允许指定网段的主机查看此页面 1234htpasswd -cm /etc/httpd2.4.23/.htpasswd monitor# -m 使用MD5加密用户密码# 添加第一个用户时，-c选项生成密码文件# 添加后续用户时，无需-c选项了 在配置文件/etc/httpd2.4.23/extra/httpd-vhosts.conf中添加如下内容 123456789&lt;Location /server-status&gt; Options None SetHandler server-status AuthType Basic AuthName "Private Area" AuthBasicProvider file AuthUserFile "/etc/httpd2.4.23/.htpasswd" Require valid-user&lt;/Location&gt; 1service httpd restart 安装xcache，为php加速 站点： http://xcache.lighttpd.net/ http://xcache.lighttpd.net/pub/Releases/3.0.4/xcache-3.0.4.tar.gz 安装 1234567tar -xf xcache-3.0.4.tar.gzcd xcache-3.0.4/usr/local/php-fpm/bin/phpize./configure --enable-xcache --with-php-config=/usr/local/php-fpm/bin/php-configmake &amp;&amp; make install# 安装结束时，会出现类似如下行：# Installing shared extensions: /usr/local/php/lib/php/extensions/no-debug-zts-20100525/ 编辑php.ini，整合php和xcache 1234# 将xcache提供的样例配置导入php.inimkdir /etc/php.dcp xcache.ini /etc/php.d# xcache.ini文件在xcache的源码目录中 编辑/etc/php.d/xcache.ini，找到extension开头的行，修改为如下行 1extension = /usr/local/php/lib/php/extensions/no-debug-zts-20100525/xcache.so 注意：如果php.ini文件中有多条zend_extension指令行，要确保此新增的行排在第一位。 1service php-fpm restart]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>LAMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LAMP编译安装（php编译为apache的模块）]]></title>
    <url>%2F2016%2F02%2F15%2F2016-02-15-124314-LAMP%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%EF%BC%88php%E7%BC%96%E8%AF%91%E4%B8%BAapache%E7%9A%84%E6%A8%A1%E5%9D%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[由于php既要编译成httpd的模块，又要连接mysql，因此先安装httpd和MySQL，最后安装php 环境准备： 12yum -y groupinstall "Compatibility libraries" "Development tools" "Server Platform Development"# 解决依赖关系，安装开发环境软件包组 MySQL5.5.53二进制通用包安装准备数据存放的文件系统 新建一个逻辑卷，并将其挂载至特定目录即可。这里不再给出过程。 逻辑卷的挂载目录为/data，而后需要创建/data/mysqldata目录做为mysql数据的存放目录。 1234567891011121314151617181920212223242526mkdir -pv /datafdisk /dev/sdb &lt;&lt; 'EOF'np1+18Gt8ewEOFkpartx -af /dev/sdbpartx -a /dev/sdbcat /proc/partitions pvcreate /dev/sdb1vgcreate myvg /dev/sdb1lvcreate -L 10G -n mysqldata myvgmke2fs -t ext4 /dev/myvg/mysqldata echo '/dev/myvg/mysqldata /data ext4 defaults,noatime 0 0 ' &gt;&gt; /etc/fstabmount -a# 为MySQL单独挂载一块硬盘，对其进行分区，创建lvm并挂载cd /data/;mkdir -pv mysqldata;chown -R mysql.mysql /data/mysqldata/# 创建mysql的数据存放目录 解决依赖关系并安装所需环境1yum -y install autoconf automake imake libxml2-devel expat-devel cmake gcc gcc-c++ libaio libaio-devel bzr bison libtool ncurses5-devel 新建用户以安全方式运行进程1234groupadd -r mysql# 添加一个系统组useradd -g mysql -r -s /sbin/nologin mysql# 添加一个不允许登录系统的MySQL系统用户 安装并初始化mysql-5.5.33首先下载平台对应的mysql版本至本地，这里是64位平台，因此选择的为mysql-5.5.53-linux2.6-x86_64.tar.gz，下载位置为：http://mirrors.sohu.com/mysql/MySQL-5.5/mysql-5.5.53-linux2.6-x86_64.tar.gz 。32位平台需要下载i686的包。 123456789101112tar xf mysql-5.5.53-linux2.6-x86_64.tar.gz -C /usr/local/# 解压二进制包到指定目录cd /usr/local/;ln -sv mysql-5.5.53-linux2.6-x86_64 mysql# 创建软链接，方便以后MySQL版本升级或更新cd mysqlchown -R mysql.mysql /usr/local/mysql/*# 属主、数组修改chown -R root.mysql /usr/local/mysql*cd /usr/local/mysqlscripts/mysql_install_db --datadir=/data/mysqldata/ --user=mysql# 对系统库做初始化 为mysql提供主配置文件12345678cp support-files/my-large.cnf /etc/my.cnf# 创建并修改MySQL配置文件sed -ri '/\[mysqld\]/adatadir=/data/mysqldata' /etc/my.cnf # 指定mysql数据文件的存放位置# thread_concurrency = 2sed -ri "sS(thread_concurrency =).*S\1 $(( `/bin/egrep -cw "processor" /proc/cpuinfo ` * 2 ))S" /etc/my.cnf # 修改此文件中thread_concurrency的值为你的CPU个数乘以2 为mysql提供sysv服务脚本123456789cp -a support-files/mysql.server /etc/rc.d/init.d/mysqldchmod +x /etc/rc.d/init.d/mysqldchkconfig --add mysqldchkconfig --level 2345 mysqld onchkconfig --list mysqld# 创建服务脚本，添加到系统服务service mysqld start# 启动服务 附加配置为了使用mysql的安装符合系统使用规范，并将其开发组件导出给系统使用，这里做如下配置 123456789101112131415161718192021222324252627# 输出mysql的man手册至man命令的查找路径# 编辑/etc/man.config，添加如下行即可：MANPATH /usr/local/mysql/manecho 'export PATH=/usr/local/mysql/bin:$PATH' &gt;| /etc/profile.d/mysqlbin.sh. /etc/profile.d/mysqlbin.sh#修改PATH环境变量，让系统可以直接使用mysql的相关命令ln -sv /usr/local/mysql/include/ /usr/include/mysql# 输出mysql的头文件至系统头文件路径/usr/includeecho '/usr/local/mysql/lib/' &gt; /etc/ld.so.conf.d/mysqllib.conf# 输出mysql的库文件给系统库查找路径ldconf# 让系统重新载入系统库ldconfig -p | grep mysqlmysql&gt; use mysql;mysql&gt; select user,host,password from user;mysql&gt; drop user ''@'localhost';mysql&gt; drop user ''@'test';mysql&gt; update user set password=password('hehedada') where user='root';mysql&gt; flush privileges;# 删除匿名用户，修改密码mysql -u root -P 3306 -h 127.0.0.1 -p# 测试 httpd2.4.23编译安装站点： httpd站点：http://httpd.apache.org/ apr-util站点：https://www.apache.org/dist/apr/apr-util-1.5.4.tar.bz2 apr站点：https://www.apache.org/dist/apr/apr-1.5.2.tar.bz2 解决依赖关系httpd2.4.23需要较新版本的apr和apr-util，因此需要事先对其进行升级。升级方式有两种，一种是通过源代码编译安装，一种是直接升级rpm包。这里选择使用编译源代码的方式进行。 12345678910111213141516171819202122232425service httpd stop# 停止现有的httpd服务chkconfig httpd off# 关闭现有httpd服务的启动yum -y install pcre-devel zlib-devel gcc gcc-c++# 安装pcre(Perl语言正则表达式库)、zlib库tar xf apr-1.5.2.tar.bz2 cd apr-1.5.2./configure --prefix=/usr/local/apr-1.5.2make &amp;&amp; make install# 安装apr(apache portable runtime)tar xf apr-util-1.5.4.tar.bz2 cd apr-util-1.5.4./configure --prefix=/usr/local/apr-util-1.5.4 --with-apr=/usr/local/apr-1.5.2/make &amp;&amp; make install# 安装apr-util附：apache官方对APR的介绍：The mission of the Apache Portable Runtime (APR) project is to create and maintain software libraries that provide a predictable and consistent interface to underlying platform-specific implementations. The primary goal is to provide an API to which software developers may code and be assured of predictable if not identical behaviour regardless of the platform on which their software is built, relieving them of the need to code special-case conditions to work around or take advantage of platform-specific deficiencies or features. 安装httpd2.4.231234tar xf httpd-2.4.23.tar.bz2 cd httpd-2.4.23 ./configure --prefix=/usr/local/apache --sysconfdir=/etc/httpd2.4.23 --enable-so --enable-headers --enable-expires --enable-ssl --enable-cgi --enable-rewrite --with-zlib --with-pcre --with-apr=/usr/local/apr-1.5.2/ --with-apr-util=/usr/local/apr-util-1.5.4/ --enable-modeles=most --enable-mpms-shared=all --with-mpm=event --enable-deflatemake &amp;&amp; make install 补充： 构建MPM为静态模块 在全部平台中，MPM都可以构建为静态模块。在构建时选择一种MPM，链接到服务器中。如果要改变MPM，必须重新构建。为了使用指定的MPM，请在执行configure脚本 时，使用参数 –with-mpm=NAME。NAME是指定的MPM名称。编译完成后，可以使用 ./httpd -l 来确定选择的MPM。 此命令会列出编译到服务器程序中的所有模块，包括 MPM。 构建 MPM 为动态模块 在Unix或类似平台中，MPM可以构建为动态模块，与其它动态模块一样在运行时加载。 构建 MPM 为动态模块允许通过修改LoadModule指令内容来改变MPM，而不用重新构建服务器程序。在执行configure脚本时，使用–enable-mpms-shared选项即可启用此特性。当给出的参数为all时，所有此平台支持的MPM模块都会被安装。还可以在参数中给出模块列表。默认MPM，可以自动选择或者在执行configure脚本时通过–with-mpm选项来指定，然后出现在生成的服务器配置文件中。编辑LoadModule指令内容可以选择不同的MPM。 配置备份配置文件 1cp /etc/httpd2.4.23/httpd.conf&#123;,.bak&#125; 在配置文件/etc/httpd2.4.23/httpd.conf加入pid配置 1PidFile "/var/run/httpd.pid" 提供SysV服务脚本服务脚本/etc/rc.d/init.d/httpd 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#!/bin/bash## httpd Startup script for the Apache HTTP Server## chkconfig: - 85 15# description: Apache is a World Wide Web server. It is used to serve \# HTML files and CGI.# processname: httpd# config: /etc/httpd2.4.23/httpd.conf# config: /etc/sysconfig/httpd# pidfile: /var/run/httpd.pid# Source function library.. /etc/rc.d/init.d/functionsif [ -f /etc/sysconfig/httpd ]; then . /etc/sysconfig/httpdfi# Start httpd in the C locale by default.HTTPD_LANG=$&#123;HTTPD_LANG-"C"&#125;# This will prevent initlog from swallowing up a pass-phrase prompt if# mod_ssl needs a pass-phrase from the user.INITLOG_ARGS=""# Set HTTPD=/usr/sbin/httpd.worker in /etc/sysconfig/httpd to use a server# with the thread-based "worker" MPM; BE WARNED that some modules may not# work correctly with a thread-based MPM; notably PHP will refuse to start.# Path to the apachectl script, server binary, and short-form for messages.apachectl=/usr/local/apache/bin/apachectlhttpd=$&#123;HTTPD-/usr/local/apache/bin/httpd&#125;prog=httpdpidfile=$&#123;PIDFILE-/var/run/httpd.pid&#125;lockfile=$&#123;LOCKFILE-/var/lock/subsys/httpd&#125;RETVAL=0start() &#123; echo -n $"Starting $prog: " LANG=$HTTPD_LANG daemon --pidfile=$&#123;pidfile&#125; $httpd $OPTIONS RETVAL=$? echo [ $RETVAL = 0 ] &amp;&amp; touch $&#123;lockfile&#125; return $RETVAL&#125;stop() &#123; echo -n $"Stopping $prog: " killproc -p $&#123;pidfile&#125; -d 10 $httpd RETVAL=$? echo [ $RETVAL = 0 ] &amp;&amp; rm -f $&#123;lockfile&#125; $&#123;pidfile&#125;&#125;reload() &#123; echo -n $"Reloading $prog: " if ! LANG=$HTTPD_LANG $httpd $OPTIONS -t &gt;&amp;/dev/null; then RETVAL=$? echo $"not reloading due to configuration syntax error" failure $"not reloading $httpd due to configuration syntax error" else killproc -p $&#123;pidfile&#125; $httpd -HUP RETVAL=$? fi echo&#125;# See how we were called.case "$1" in start) start ;; stop) stop ;; status) status -p $&#123;pidfile&#125; $httpd RETVAL=$? ;; restart) stop start ;; condrestart) if [ -f $&#123;pidfile&#125; ] ; then stop start fi ;; reload) reload ;; graceful|help|configtest|fullstatus) $apachectl $@ RETVAL=$? ;; *) echo $"Usage: $prog &#123;start|stop|restart|condrestart|reload|status|fullstatus|graceful|help|configtest&#125;" exit 1esacexit $RETVAL 添加权限1chmod +x /etc/rc.d/init.d/httpd 添加服务和环境变量123456789chkconfig --add httpdchkconfig --level 2345 httpd onchkconfig --list httpdecho 'export PATH=/usr/local/apache/bin/:$PATH' &gt; /etc/profile.d/apachebin.sh. /etc/profile.d/apachebin.shecho '192.1.68.2.105 www.test.com' &gt;&gt; /etc/hosts # 避免启动服务时报解析错误 服务启动和验证123service httpd startss -tnl | grep 80service httpd status 报错：httpd dead but subsys locked 解决方法：rm -f /var/lock/subsys/httpd，并检查pid配置是否正确 编译安装php-5.4.27解决依赖关系Mcrypt是PHP的一个扩展，完成了常用加密算法的封装。其实该扩展是对mcrypt标准类库的封装，mcrypt完成了相当多的常用加密算法，如DES, TripleDES, Blowfish (default), 3-WAY, SAFER-SK64, SAFER-SK128, TWOFISH, TEA, RC2 和 GOST加密算法，并且提供了CBC、OFB、CFB 和 ECB 四种块加密的模型。要使用该扩展，必须首先安装mcrypt标准类库，注意的是mcrypt软件依赖libmcrypt和mhash两个库。 环境和库 1234yum -y groupinstall "Desktop Platform Development" # 桌面平台环境，开发所需yum -y install bzip2-devel# 依赖库安装 libmcrypt（安装mcrypt需要此软件包） 12345wget http://nchc.dl.sourceforge.net/project/mcrypt/Libmcrypt/2.5.8/libmcrypt-2.5.8.tar.gztar xf libmcrypt-2.5.8.tar.bz2 cd libmcrypt-2.5.8./configure --prefix=/usr/local/make &amp;&amp; make install mhash（安装mcrypt需要此软件包） 12345https://acelnmp.googlecode.com/files/mhash-0.9.9.9.tar.gztar xf mhash-0.9.9.9.tar.gz cd mhash-0.9.9.9./configure --prefix=/usr/local/make &amp;&amp; make install mcrypt扩展 12345678910111213wget https://lcmp.googlecode.com/files/mcrypt-2.6.8.tar.gztar xf mcrypt-2.6.8.tar.gzln -s /usr/local/bin/libmcrypt-config /usr/bin/libmcrypt_config# 添加链接，以免libmcrypt未搜索到echo -e '/usr/local/lib' &gt; /etc/ld.so.conf.d/libmcrypt_lg.confldconfig# 添加库搜索路径export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH# 由于在配置Mcrypt时，会找不到libmcrypt的链接库，导致无法编译# 因为Libmcrypt的链接库在/usr/local/lib文件夹下。# 因此在配置mcrypt时要加入LD_LIBRARY_PATH=/usr/local/lib导入键接库./configure --prefix=/usr/local/mcrypt make &amp;&amp; make install 编译安装php-5.4.27 站点 http://php.net/releases/ http://php.net/get/php-5.4.27.tar.bz2/from/a/mirror 12345tar xf php-5.4.27.tar.bz2 cd php-5.4.27./configure --prefix=/usr/local/php --with-mysql=/usr/local/mysql --with-openssl --with-mysqli=/usr/local/mysql/bin/mysql_config --enable-mbstring --with-freetype-dir --with-jpeg-dir --with-png-dir --with-zlib --enable-xml --with-libxml-dir=/usr --enable-sockets --with-apxs2=/usr/local/apache/bin/apxs --with-mcrypt=/usr/local/mcrypt --with-mhash --with-config-file-path=/etc --with-config-file-scan-dir=/etc/php.d --with-bz2 --enable-maintainer-ztsmake &amp;&amp; make intallls /usr/local/php/ 说明 这里为了支持apache的worker或event这两个MPM，编译时使用了–enable-maintainer-zts选项。 如果使用PHP5.3以上版本，为了链接MySQL数据库，可以指定mysqlnd，这样在本机就不需要先安装MySQL或MySQL开发包了。mysqlnd从php 5.3开始可用，可以编译时绑定到它（而不用和具体的MySQL客户端库绑定形成依赖），但从PHP 5.4开始它就是默认设置了。 如果MySQL和PHP不在一台主机，使用with-mysql时，都直接指定为mysqlnd，表示MySQL不在本机，而是在另外的其他主机上./configure --with-mysql=mysqlnd --with-pdo-mysql=mysqlnd --with-mysqli=mysqlnd 参数说明 12345678910111213141516171819--prefix # 程序安装路径--with-mysql= # mysql安装路径，对mysql的支持--with-openssl # 启用ssl支持--with-mysqli= # mysqli扩展技术不仅可以调用MySQL的存储过程、处理MySQL事务，而且还可以使访问数据库工作变得更加稳定--enable-mbstring # 启用多字节字符串支持--with-freetype-dir # 打开对freetype字体库的支持 --with-jpeg-dir # 打开对jpeg图片的支持--with-png-dir # 打开对png图片的支持--with-zlib # 使用压缩库--enable-xml # 启用解析xml文件--with-libxml-dir= # libxml的路径--enable-sockets # 支持基于socket通信--with-apxs2=/usr/local/apache/bin/apxs # 整合 apache，apxs功能是使用mod_so中的LoadModule指令，加载指定模块到 apache，要求 apache 要打开SO模块--with-mcrypt # mcrypt算法扩展--with-mhash # mhash算法扩展--with-config-file-path= # 配置文件路径--with-config-file-scan-dir= # 此目录下所有.ini结尾的文件都被当作配置文件的一部分--with-bz2 # 打开对bz2文件的支持 --enable-maintainer-zts # 如果apache使用了event选项 提供配置文件1cp php.ini-production /etc/php.ini 配置apache，支持phpvim /etc/httpd2.4.23/httpd.conf 定位AddType，添加如下二行 12AddType application/x-httpd-php .phpAddType application/x-httpd-php-source .phps 定位至DirectoryIndex index.html，修改为： 1DirectoryIndex index.php index.html 服务验证 重新启动httpd，或让其重新载入配置文件即可测试php是否已经可以正常使用。 1service httpd restart 生成验证页面 12cd /usr/local/apache/htdocs/mv index.html index.php 测试页面index.php链接MySQL示例如下 12345678910&lt;?php $link = mysql_connect('127.0.0.1','root','hehedada'); if ($link) echo "Success..."; else echo "Failure..."; mysql_close(); phpinfo();?&gt; 安装xcache，为php加速 站点： http://xcache.lighttpd.net/ http://xcache.lighttpd.net/pub/Releases/3.0.4/xcache-3.0.4.tar.gz 安装 1234567tar -xf xcache-3.0.4.tar.gzcd xcache-3.0.4/usr/local/php/bin/phpize./configure --enable-xcache --with-php-config=/usr/local/php/bin/php-configmake &amp;&amp; make install# 安装结束时，会出现类似如下行：# Installing shared extensions: /usr/local/php/lib/php/extensions/no-debug-zts-20100525/ 编辑php.ini，整合php和xcache 1234# 将xcache提供的样例配置导入php.inimkdir /etc/php.dcp xcache.ini /etc/php.d# xcache.ini文件在xcache的源码目录中 编辑/etc/php.d/xcache.ini，找到zend_extension开头的行，修改为如下行 1zend_extension = /usr/local/php/lib/php/extensions/no-debug-zts-20100525/xcache.so 注意：如果php.ini文件中有多条zend_extension指令行，要确保此新增的行排在第一位。 启用服务器状态mod_status模块可以让管理员查看服务器的执行状态，它通过一个HTML页面展示了当前服务器的统计数据。这些数据通常包括但不限于：(1) 处于工作状态的worker进程数；(2) 空闲状态的worker进程数；(3) 每个worker的状态，包括此worker已经响应的请求数，及由此worker发送的内容的字节数；(4) 当前服务器总共发送的字节数；(5) 服务器自上次启动或重启以来至当前的时长；(6) 平均每秒钟响应的请求数、平均每秒钟发送的字节数、平均每个请求所请求内容的字节数； 状态信息不应该被所有人随意访问，因此应该限制仅允许某些特定地址的客户端查看。比如使用Require ip 172.16.0.0/16来限制仅允许指定网段的主机查看此页面 1234htpasswd -cm /etc/httpd2.4.23/.htpasswd monitor# -m 使用MD5加密用户密码# 添加第一个用户时，-c选项生成密码文件# 添加后续用户时，无需-c选项了 在配置文件/etc/httpd2.4.23/extra/httpd-info.conf中添加如下内容 123456789&lt;Location /server-status&gt; Options None SetHandler server-status AuthType Basic AuthName "Private Area" AuthBasicProvider file AuthUserFile "/etc/httpd2.4.23/.htpasswd" Require valid-user&lt;/Location&gt; 在/etc/httpd2.4.23/httpd.conf搜索下行，去掉#注释，对status文件包含 12# Real-time info on requests and configuration Include /etc/httpd2.4.23/extra/httpd-info.conf 附加测试测试环境： 主机CPU：Intel(R) Core(TM) i7-4710MQ CPU @ 2.50GHz 内存大小：1000MBab测试示例：未启用xcache和启用xcache后，对phpMyAdmin的主而面进行请求测试的结果如下所示： 1ab -c 10 -n 1000 http://192.168.2.110/phpmyadmin/index.php xcache之前 Requests per second: 27.99 [#/sec] (mean)Time per request: 357.221 [ms] (mean)Time per request: 35.722 [ms] (mean, across all concurrent requests) xcache之后 Requests per second: 110.27 [#/sec] (mean)Time per request: 90.690 [ms] (mean)Time per request: 9.069 [ms] (mean, across all concurrent requests)]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>LAMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LAMP（前言）]]></title>
    <url>%2F2016%2F02%2F14%2F2016-02-14-164135-LAMP%EF%BC%88%E5%89%8D%E8%A8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LAMPLAMP指的Linux（操作系统）、Apache（HTTP 服务器），MySQL（有时也指MariaDB，数据库软件） 和PHP（有时也是指Perl或Python） 的第一个字母，一般用来建立web应用平台。 CGI（协议） CGI(Common Gateway Interface) 公共网关接口，是外部应用程序（CGI程序）与WEB服务器之间的接口标准。CGI规范允许Web服务器执行外部程序，并将它们的输出发送给Web浏览器。 CGI是一个规定要传哪些数据、以什么样的格式传递给后端处理这个请求的协议。 CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php,perl,tcl等。 FastCGI（协议）FastCGI，快速公共网关接口协议 每当客户请求CGI的时候，WEB服务器就请求操作系统生成一个新的CGI解释器进程(如php-cgi.exe)，当CGI满足要求后，WEB服务器就杀死这个进程。所以，CGI解释器的反复加载是CGI性能低下的主要原因，如果CGI解释器保持在内存中并接受FastCGI进程管理器调度，则可以提供良好的性能、伸缩性、Fail-Over特性等等。 FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次。 支持分布式的运算, 即 FastCGI 程序可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求。 FastCGI程序启动时先启动一个master，解析配置文件，初始化执行环境，然后再启动多个worker。当请求过来时，master会传递给一个worker，然后立即可以接受下一个请求。这样就避免了重复的劳动，提高了效率。而且当worker不够用时，master可以根据配置预先启动几个空闲worker；当然空闲worker太多时，也会停掉一些，这样就提高了性能，也节约了资源。这就是fastcgi的对进程的管理。 PHP-FPMPHP的解释器是php-cgi。php-cgi只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理，所以就出现了一些能够调度php-cgi进程的程序，例如由lighthttpd分离出来的spawn-fcgi。 PHP-FPM(FastCGI Process Manager：FastCGI进程管理器)对于PHP 5.3.3之前的php来说，是一个补丁包，旨在将FastCGI进程管理整合进PHP包中。 如果你使用的是PHP5.3.3之前的PHP的话，就必须将它patch到你的PHP源代码中，在编译安装PHP后才可以使用。 PHP5.3.3已经集成php-fpm了，不再是第三方的包了。 PHP-FPM提供了更好的PHP进程管理方式，可以有效控制内存和进程、可以平滑重载PHP配置，比spawn-fcgi具有更多优点，所以被PHP官方收录了。在./configure的时候带 –enable-fpm参数即可开启PHP-FPM。 Apache和PHP的结合方式php编译为apache的模块将php编译为apache的模块，作为httpd进程的一个子功能实现，而不会新建一个子进程 如果apache工作在prefork模式下：php将被编译成进程式的libphp5.so 如果apache工作在worker，event模式下：前端的httpd是以线程方式工作，php被编译成线程式的libphp5-zts.so 要把php编译成模块，需要用到apache的apxs程序：/usr/local/apache/bin/apxs 基于cgi协议CGI解释器的反复加载导致CGI性能低下，尽可能不用 基于fastcgi协议编译为php-fpmphp被编译为php-fpm，被调用为一个进程而启动，自行启动一个服务进程，监听在某个套接字上，为了快速响应请求，会在内部启动N个子工作进程 用户向前端http server发送.php、.phps文件的请求，前端的apache将基于fastcgi协议与后端的php联系 前端http server只转发php的请求到后端服务器，所有的静态内容都由前端向用户提供 前端将用户请求的PHP资源发往后端时，仅发送的是链接，url等，并且基于fastcti协议]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>LAMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux五种IO模型]]></title>
    <url>%2F2016%2F02%2F12%2F2016-02-12-150414-Linux%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[调用方式网络编程中常见到的四种调用方式：同步、异步、阻塞、非阻塞。 同步(Sync) 某程序在发出一个功能调用时，在没有得到结果之前，该调用就不返回。即：必须一件一件事做,等上一件做完之后才能继续做下一件事。 普通B/S模式（同步）：提交请求-&gt;等待服务器处理-&gt;处理完毕返回 这个期间客户端浏览器不能干任何事 异步(Async) 某程序在发出一个功能调用后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。 ajax请求（异步）: 请求通过事件触发-&gt;服务器处理（这是浏览器仍然可以作其他事情）-&gt;处理完毕 阻塞(Block)/ 在调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。 非阻塞(Unblock) 在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。 小结 同步IO和异步IO的区别在于：数据拷贝的时候进程是否阻塞阻塞IO和非阻塞IO的区别在于：应用程序的调用是否立即返回 同步：我调用一个功能，该功能没有结束前，我一直等着结果异步：我调用一个功能，不需要知道该功能结果，该功能有结果后通知我（回调通知）阻塞：调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。非阻塞： 调用我（函数），我（函数）立即返回，通过select通知调用者 五种I/O模型同步阻塞 进程一直阻塞，直到数据拷贝完成 应用程序调用一个IO函数，导致应用程序阻塞，等待数据准备好。 如果数据没有准备好，一直等待….数据准备好了，从内核拷贝到用户空间，IO函数返回成功指示。 同步非阻塞 非阻塞IO通过进程反复调用IO函数（多次系统调用，并马上返回）；在数据拷贝的过程中，进程是阻塞的； I/O复用 主要是select和epoll；对一个IO端口，两次调用，两次返回，比阻塞IO并没有什么优越性；关键是能实现同时对多个IO端口进行监听； 信号驱动 两次调用，两次返回； 异步I/O 数据拷贝的时候进程无需阻塞。 参考：http://blog.csdn.net/jay900323/article/details/18141217/]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>IO</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[httpd页面压缩及压力测试]]></title>
    <url>%2F2016%2F02%2F11%2F2016-02-11-161333-httpd%E9%A1%B5%E9%9D%A2%E5%8E%8B%E7%BC%A9%E5%8F%8A%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[httpd页面压缩及压力测试调用模块压缩 使用mod_deflate模块压缩纯文本页面优化传输速度，可以写为一行，也可以写多行，默认为gzip 如果服务器CPU比较空闲，带宽比较紧张可考虑压缩；若CPU比较繁忙则建议关闭压缩 12345httpd -M | grep deflate# 检查模块vim /etc/httpd/conf.d/deflate.conf# 创建自定义压缩配置 1234567891011121314151617181920212223242526272829303132SetOutputFilter DEFLATE# 启用DEFLATE过滤器来实现输出内容过滤，并完成文件压缩# mod_deflate configuration&lt;IfModule mod_deflate.c&gt; # Restrict compression to these MIME types # 明确说明对哪种格式的文档做压缩 AddOutputFilterByType DEFLATE text/plain AddOutputFilterByType DEFLATE text/html AddOutputFilterByType DEFLATE application/xhtml+xml AddOutputFilterByType DEFLATE text/xml AddOutputFilterByType DEFLATE application/xml AddOutputFilterByType DEFLATE application/x-javascript AddOutputFilterByType DEFLATE text/javascript AddOutputFilterByType DEFLATE text/css # Level of compression (Highest 9 - Lowest 1)默认为6 # 压缩比 DeflateCompressionLevel 9 # 判定哪种格式的浏览器不使用压缩机制 # Netscape 4.x has some problems. BrowserMatch ^Mozilla/4 gzip-only-text/html # Netscape 4.06-4.08 have some more problems BrowserMatch ^Mozilla/4\.0[678] no-gzip # MSIE masquerades as Netscape, but it is fine BrowserMatch \bMSI[E] !no-gzip !gzip-only-text/html&lt;/IfModule&gt; apache扩展命令 apachectl：Apache HTTP服务控制工具 ab： Apache HTTP服务器性能测试工具 apxs：Apache 扩展工具 configure：配置源代码 dbmmanage：为基本认证创建和更新DBM格式的用户认证文件 htcacheclean：清理磁盘缓存 htdigest：为摘要认证创建和更新用户认证文件。 htdbm：操作 DBM 密码数据库。 htpasswd：为基本认证创建和更新用户认证文件。 httxt2dbm：为 RewriteMap 创建 dbm 文件。 logresolve：将 Apache 日志文件中的 IP 地址解析到主机名称。 rotatelogs：不关闭 Apache 而切换日志文件。 suexec：执行外部程序前切换用户。 资源限定 软限制：可以超出的限制，但仅能超出一定时长 123ulimit：只能修改软限制 -n [N]：显示或限制能打开的最大的文件句柄数 -u [N]：所能够打开的最大进程数 硬限制：绝对不能超出的限制 主配置：/etc/security/limits.conf 扩展配置：/etc/security/limits.d/*.conf 1234# 修改/etc/security/limits.conf# 对谁进行限定 类型 要限定的选项 值apache hard nofile 65535apache hard nproc 30000 123# 立即生效ulimit -n 65535ulimit -u 30000 ab工具的初步使用 -c 模拟的并发数 -n 模拟的总请求数 12ab -c 100 -n 5000 http://192.168.237.68/index.html # 一般并发数应该小于等于请求数 其他压力测试工具 http_load webbench seige(只做参考) tcp_copy]]></content>
      <categories>
        <category>Services</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[httpd2.4.23配置实践]]></title>
    <url>%2F2016%2F02%2F10%2F2016-02-10-121429-httpd2.4.23%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[文件说明 /etc/httpd2.4.23/httpd.conf # 主配置文件/etc/httpd2.4.23/extra/httpd-default.conf # 默认配置文件(包括keepalive和AccessFileName设置等)/etc/httpd2.4.23/extra/httpd-userdir.conf # 用户目录配置文件/etc/httpd2.4.23/extra/httpd-mpm.conf # MPM配置文件/etc/httpd2.4.23/extra/httpd-ssl.conf # SSL配置文件/etc/httpd2.4.23/extra/httpd-vhosts.conf # 虚拟主机配置文件/etc/httpd2.4.23/extra/httpd-info.conf # server-status页面配置文件 监听配置1vim /etc/httpd2.4.23/httpd.conf 123# 此指令可出现多次，用于同时监听不同的套接字#Listen 12.34.56.78:80Listen 80 Keep-alive1vim /etc/httpd2.4.23/extra/httpd-default.conf 12345KeepAlive OnMaxKeepAliveRequests 100# 一次连接最多接受的请求数量KeepAliveTimeout 5# 超时时间 页面访问属性1vim /etc/httpd2.4.23/httpd.conf 12345&lt;Directory "/usr/local/apache/htdocs"&gt; Options Indexes FollowSymLinks AllowOverride None Require all granted&lt;/Directory&gt; 12345678910# 选项说明Options： None 所有选项都不启用 All 所有选项都启用 Indexes 缺少指定的默认页面时，允许将目录中的所有文件以列表形式返回给客户端，比较危险； FollowSymLinks 允许跟随符号链接所指向的原始文件 ExecCGI 允许使用mod_cgi模块执行CGI脚本 Includes 允许使用mod_include模块实现服务器包含 MutilViews 允许使用mod_negotiation实现内容协商 SymLinksIfOwnerMatch 在链接文件属主属组与原始文件的属主数组向同时,允许跟随符号链接所指向的原始文件 默认主页面1vim /etc/httpd2.4.23/httpd.conf 123&lt;IfModule dir_module&gt; DirectoryIndex index.html&lt;/IfModule&gt; 配置用户目录1vim /etc/httpd2.4.23/httpd.conf 12345LoadModule autoindex_module modules/mod_autoindex.soInclude /etc/httpd2.4.23/extra/httpd-autoindex.confLoadModule userdir_module modules/mod_userdir.soInclude /etc/httpd2.4.23/extra/httpd-userdir.conf# 开启这几项 1vim /etc/httpd2.4.23/extra/httpd-autoindex.conf 12345678IndexOptions FancyIndexing HTMLTable VersionSort NameWidth=* FoldersFirst Charset=UTF-8 SuppressDescription SuppressHTMLPreamble# FancyIndexing 支持美化显示；# HTMLTable 允许底层代码把文件列表生成在一个table元素里面；# VersionSort 安装版本排序；# NameWidth=* 页面自动匹配文件名宽度；# FoldersFirst 安装文件夹优先排列；# Charset=UTF-8 支持中文显示；# SuppressDescription 不显示文件描述 1vim /etc/httpd2.4.23/extra/httpd-userdir.conf 12345678# 默认配置，无需修改即可使用UserDir public_html&lt;Directory "/home/*/public_html"&gt; AllowOverride FileInfo AuthConfig Limit Indexes Options MultiViews Indexes SymLinksIfOwnerMatch IncludesNoExec Require method GET POST OPTIONS&lt;/Directory&gt; 123mkdir -pv /home/litingjie/public_htmlchmod +x /home/litingjie/for i in &#123;1..10&#125;;do echo $i &gt; /home/litingjie/public_html/$&#123;i&#125;.txt;done 使用浏览器访问测试：192.168.237.68/~litingjie mpm模块切换配置12#LoadModule mpm_event_module modules/mod_mpm_event.soLoadModule mpm_prefork_module modules/mod_mpm_prefork.so 基于IP访问控制 允许所有主机访问：Require all granted 拒绝所有主机访问：Require all deny 控制特定ip访问： Require ip IPADDR：授权指定来源的主机访问 Require not ip IPADDR：拒绝指定来源地址的主机访问 IPADDR： 单个IP：192.168.1.1 network/mask： 192.168.1.0/255.255.255.0 network/Lenth：192.168.1.0/24 net：192.168.1 控制特定主机访问： Require host HOSTNAME Require no host HOSTNAME HOSTNAME: FQDN：www.nettest.com，具体的主机 DOMAIN：.nettest.com，域内的所有主机 1234567&lt;Directory "/usr/local/apache/htdocs"&gt; Options Indexes FollowSymLinks AllowOverride None Require ip 192.168.2.1 Require not ip 192.168.1.0/255.255.255.0 Require no host .nettest.com&lt;/Directory&gt; 基于用户访问控制 认证类型 basic：基本认证，帐号和密码明文发送；（模块：mod_auth_basic） digest：摘要认证，hash编程之后发送；（模块：mod_auth_digest） 认证提供者（即帐号和密码的存放位置） File(默认)：模块mod_authn_file SQL数据库：模块mod_authn_dbd dbm：模块mod_authn_dbm ldap：模块mod_authnz_ldap 1234htpasswd -cm /etc/httpd2.4.23/.htpasswd monitor# -m 使用MD5加密用户密码# 添加第一个用户时，-c选项生成密码文件# 添加后续用户时，无需-c选项了 1vim /etc/httpd2.4.23/httpd.conf 12345678910# 在 httpd.conf 中编写如下配置&lt;Location /server-status&gt; Options None SetHandler server-status AuthType Basic AuthName "Private Area" AuthBasicProvider file AuthUserFile "/etc/httpd2.4.23/.htpasswd" Require valid-user&lt;/Location&gt; 虚拟主机配置基于IP，port和FQDN；基于FQDN不再需要NameVirtualHost指令 注释掉中心主机 1vim /etc/httpd2.4.23/httpd.conf 12345# DocumentRoot: The directory out of which you will serve your# documents. By default, all requests are taken from this directory, but# symbolic links and aliases may be used to point to other locations.## DocumentRoot "/usr/local/apache/htdocs" 开启虚拟主机 1vim /etc/httpd2.4.23/httpd.conf 12# Virtual hostsInclude /etc/httpd2.4.23/extra/httpd-vhosts.conf 配置虚拟主机 1vim /etc/httpd2.4.23/extra/httpd-vhosts.conf 123456789101112131415161718192021222324252627&lt;VirtualHost *:80&gt; DocumentRoot "/www/a.com/htdocs/" ServerAdmin webadmin@a.com ServerName www.a.com ServerAlias a.com ErrorLog "logs/www.a.com-error_log" CustomLog "logs/www.a.com-access_log" combined &lt;Directory "/www/a.com/htdocs/"&gt; Options None AllowOverride none Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt; DocumentRoot "/www/b.cn/htdocs/" ServerAdmin webadmin@b.cn ServerName www.b.cn ServerAlias b.cn ErrorLog "logs/www.b.cn-error_log" CustomLog "logs/www.b.cn-access_log" combined &lt;Directory "/www/b.cn/htdocs/"&gt; Options None AllowOverride none Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt; CGI配置 文件配置 1vim /etc/httpd2.4.23/httpd.conf 1234567891011&lt;IfModule alias_module&gt; # # 中间注释部分省略 # ScriptAlias /cgi-bin/ "/usr/local/apache/cgi-bin/"&lt;/IfModule&gt;&lt;IfModule mpm_prefork_module&gt; LoadModule cgi_module modules/mod_cgi.so # 启用模块&lt;/IfModule&gt; 创建测试脚本 1vim /usr/local/apache/cgi-bin/test.sh 12345678910111213#!/bin/bash#cat &lt;&lt; EOFContent-Type: text/html#这里要有一个空行否则可能会测试不成功&lt;pre&gt;&lt;h1&gt;Hello world&lt;/h1&gt;The hostname is: `hostname`.The time is: `date`.&lt;/pre&gt;EOF 1chmod +x /usr/local/apache/cgi-bin/test.sh 测试在浏览器地址栏访问192.168.237.68/cgi-bin/test.sh 页面压缩 使用模块mod_deflate，压缩页面优化传输速度以节约带宽成本，cpu比较繁忙的服务器不建议压缩 启用压缩模块：gzip,deflate 具体配置如下: 1234567891011121314151617181920212223242526# 开启压缩模块LoadModule deflate_module modules/mod_deflate.so# 在 httpd.conf 尾部编写如下配置SetOutputFilter DEFALTE# 使用mod_deflate模块&lt;IfModule deflate_module&gt;# Restrict compression to these MIME types# 明确说明对哪种格式的文档做压缩AddOutputFilterByType DEFLATE text/plainAddOutputFilterByType DEFLATE text/htmlAddOutputFilterByType DEFLATE application/xhtml+xmlAddOutputFilterByType DEFLATE text/xmlAddOutputFilterByType DEFLATE application/xmlAddOutputFilterByType DEFLATE application/x-javascriptAddOutputFilterByType DEFLATE text/javascriptAddOutputFilterByType DEFLATE text/css# Level of compression (Highest 9 - Lowest 1)默认为6# 压缩等级(0-9),数值越大CPU压力也就越大DeflateCompressionLevel 9# 非Mozilla4标准浏览器仅开启gzip压缩BrowserMatch ^Mozilla/4 gzip-only-text/html# Mozilla4.06,4.07,4.08版本不开启压缩BrowserMatch ^Mozilla/4\.0[678] no-gzip# IE浏览器不开启压缩BrowserMatch \bMSI[E] !no-gzip !gzip-only-text/html&lt;/IfModule&gt; Server Info httpd内生的status信息，且此信息可以通过web予以显示，为服务器监控提供便利 处理器：文件被调用时Apache内部表现形式：一般每种文件类型都有其隐式处理器；否则需要自己定义 显式的定义使用的处理器：SetHandler 12345# SetHandler中的内容必要要经过用户认证htpasswd -cm /etc/httpd2.4.23/.htpasswd monitor# -m 使用MD5加密用户密码# 添加第一个用户时，-c选项生成密码文件# 添加后续用户时，无需-c选项了 1vim /etc/httpd2.4.23/httpd.conf 12# Real-time info on requests and configuration Include /etc/httpd2.4.23/extra/httpd-info.conf 1vim /etc/httpd2.4.23/extra/httpd-info.conf 12345678910# 在文件中中编写如下配置&lt;Location /server-status&gt; Options None SetHandler server-status AuthType Basic AuthName "Private Area" AuthBasicProvider file AuthUserFile "/etc/httpd2.4.23/.htpasswd" Require valid-user&lt;/Location&gt; 12345678# 其他SetHandler可设置的值及对应模块default-handler: 使用 default_handler() 发送文件，它是用来处理静态内容的处理器(核心)。send-as-is: 直接发送，不增加 HTTP 头(mod_asis)。cgi-script: 按 CGI 脚本处理(mod_cgi)。imap-file: 按 imagemap 规则处理(mod_imagemap)。server-info: 取得服务器配置信息(mod_info)。server-status: 取得服务器状态报告(mod_status)。type-map: 用于内容协商，按类型映射文件处理(mod_negotiation)。 测试在浏览器地址栏访问192.168.237.68/server-status]]></content>
      <categories>
        <category>Services</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[httpd2.4.23编译安装]]></title>
    <url>%2F2016%2F02%2F09%2F2016-02-09-150619-httpd2.4.23%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[新增特性 1) MPM支持在运行时装载--enable-mpms-shared=all --with-mpm=event # 启用默认的event2) 支持event3) 异步读写4) 在每模块及每目录上指定日志级别5) 每请求配置： 6) 增强版的表达式分析器7) 毫秒级的keepalive timeout8) 支持主机名的虚拟主机不再需要NameVirtualHost指令9) 支持使用自定义变量 新增模块 mod_proxy_fcgi mod_ratelimit mod_request mod_remoteip 修改 对于基于IP的访问做了修改，不在使用order,allow,deny这些机制；而是统一使用require进行 下载站点 httpd站点：http://httpd.apache.org/ apr-util站点：https://www.apache.org/dist/apr/apr-util-1.5.4.tar.bz2 apr站点：https://www.apache.org/dist/apr/apr-1.5.2.tar.bz2 编译安装123456789101112131415161718192021222324# 停止现有的httpd服务service httpd stop# 关闭现有httpd服务的启动chkconfig httpd off# 解决依赖关系，安装开发环境软件包组yum -y groupinstall "Compatibility libraries" "Development tools" "Server Platform Development"# 安装pcre(Perl语言正则表达式库)、zlib及zlib库、gcc及gcc++yum -y install pcre-devel zlib-devel gcc gcc-c++# httpd依赖于更高版本的apr和apr-util# 安装apr(apache portable runtime)及tar xf apr-1.5.2.tar.bz2 cd apr-1.5.2./configure --prefix=/usr/local/apr-1.5.2make &amp;&amp; make install# 安装apr-utiltar xf apr-util-1.5.4.tar.bz2 cd apr-util-1.5.4./configure --prefix=/usr/local/apr-util-1.5.4 --with-apr=/usr/local/apr-1.5.2/make &amp;&amp; make install# 安装httpd2.4.23tar xf httpd-2.4.23.tar.bz2 cd httpd-2.4.23 ./configure --prefix=/usr/local/apache --sysconfdir=/etc/httpd2.4.23 --enable-so --enable-headers --enable-expires --enable-ssl --enable-cgi --enable-rewrite --with-zlib --with-pcre --with-apr=/usr/local/apr-1.5.2/ --with-apr-util=/usr/local/apr-util-1.5.4/ --enable-modeles=most --enable-mpms-shared=all --with-mpm=event --enable-deflatemake &amp;&amp; make install 123456789101112131415161718192021222324252627282930313233343536373839# #--prefix=/usr/local/apache# 设定httpd的安装目录#--sysconfdir=/etc/httpd2.4.23# 设定httpd的配置文件目录#--enable-so# 激活apache服务的DSO（Dynamic Shared Objects动态共享目标）# 即在以后可以以DSO的方式编译安装共享模块# 这个模块本身不能以DSO方式编译支持共享模块，如果没有这个则PHP模块无法加入#--enable-headers# 提供允许对HTTP请求头的控制 #--enable-expires# 激活通过配置文件控制HTTP的“Expires:”和“Cache-Control:”头内容# 即对网站图片、js、css等内容，提供客户端浏览器缓存的设置# 这个是apache调优的一个重要选项之一。#--enable-ssl # 支持ssl#--enable-cgi# 支持cgi#--enable-rewrite# 支持url重写#--with-zlib# 支持zlib压缩，传输层的压缩（不指定具体的路径，默认在系统中搜索）#--with-pcre# 支持正则化（不指定具体的路径，默认在系统中搜索）#--with-apr=/usr/local/apr-1.5.2/# 指定apr的路径#--with-apr-util=/usr/local/apr-util-1.5.4/# 指定apr-util的路径#--enable-modules=most# 指定要编译的模块(most/all)#--enable-mpms-shared=all# 指定要编译mpm#--with-mpm=event# 指定httpd默认的MPM的工作方式 #--enable-deflate# 提供对内容的压缩传输编码支持，一般是html、js、css等内容的站点。# 使用此参数会打打提高传输速度，提升访问者访问的体验。# 在生产环境中，这是apache调优的一个重要选项之一。 后续配置 添加环境变量 123echo 'export PATH=/usr/local/apache/bin:$PATH' &gt; /etc/profile.d/httpd.sh# 新建终端登录验证echo $PATH 修改用户和组vim /etc/httpd2.4.23/httpd.conf 12345#User daemon#Group daemonUser apacheGroup apache 修改ServerName 12#ServerName www.example.com:80ServerName localhost:80 导出头文件：此步骤非必选，开发好的程序有可能会调用 1ln -sv /usr/local/appache/include /usr/include/httpd 导出库文件 123456ldconfig -p | grep apr# 显示当前系统的库文件ldconfig -v | grep aprecho "/usr/local/apr-util-1.5.4/lib/" &gt;&gt; /etc/ld.so.conf.d/httpd.conf echo "/usr/local/apr-1.5.2/lib/" &gt;&gt; /etc/ld.so.conf.d/httpd.confldconfig -v | grep apr 导出帮助文件/etc/man.config文件配置： 新增一行MANPATH /usr/local/apache/man手动指定：man -M /usr/local/apache/man httpd验证：执行man htpasswd验证 加入系统服务 12345cp /usr/local/apache/bin/apachectl /etc/init.d/httpdservice httpd startnetstat -lntp|grep 80lsof -i :80echo '/usr/local/apache/bin/apachectl start' &gt;&gt; /etc/rc.d/rc.local]]></content>
      <categories>
        <category>Services</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[httpd及安装配置]]></title>
    <url>%2F2016%2F02%2F08%2F2016-02-08-135437-httpd%E5%8F%8A%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[简介httpdhttpd是Apache超文本传输协议(HTTP)服务器的主程序。被设计为一个独立运行的后台进程，它会建立一个处理请求的子进程或线程的池。 版本 httpd-1.3 httpd-2.0 httpd-2.2 httpd-2.4 目前为止最新的版本是httpd-2.4，不同版本配置可能会有所不同，本文以rpm包httpd-2.2为例 站点 Apache官方站点：httpd.apache.org 市场占有率分析站点：www.netcraft.com 模块 httpd：DSO高度模块化 DSO：Dynamic Shared Object 动态模块对象 MPM：Multipath Processing Module 多处理模块 多处理模块，并非一个模块，而是对一种特性的称谓 prefork：一次一个进程响应一个请求，其中进程会预先创建好 worker：一个进程生成多个线程，一个线程响应一个请求 event：一个进程响应多个请求，不生成线程；2.2版本中的event用于测试 event-driven：基于事件驱动，主要目的在于实现一个进程响应多个请求 功能特性 路径别名：alias 用户认证：authentication 虚拟主机：virtual host 反向代理 负载均衡：反向代理的一个子特性 用户站点 CGI：Common Gateway Interface 安装及文件 安装 1yum -y install httpd 服务启动 1service httpd start 文件说明 123456789101112131415161718# 服务脚本/etc/rc.d/init.d/httpd# 服务脚本配置文件/etc/sysconfig/httpd# 服务脚本运行目录/etc/httpd # 主配置文件/etc/httpd/conf/httpd.conf # 扩展配置文件/etc/httpd/conf.d/*.conf # 默认的站点根目录/var/www/html# 默认主页面文件/var/www/html/index.html# CGI目录/var/www/cgi-bin/# SOCKET80/tcp 443/tcp 日志滚动日志以时间或空间作为衡量维度来做切割 主配置文件 存放位置/etc/httpd/conf/httpd.conf 内容说明 配置指令不区分字符大小写 值有可能区分大小写 有些指令可以重复出现多次 区段分类主机配置区段和虚拟主机配置区段不能同时使用,如需配置虚拟主机则要将主机转换成虚拟主机其中之一 12345678910grep 'Section' /etc/httpd/conf/httpd.conf### Section 1: Global Environment# 全局配置区段：应用于所有### Section 2: 'Main' server configuration# 主机配置区段：用于仅提供一个站点时### Section 3: Virtual Hosts# 虚拟主机配置区段：用于提供多个站点时 语法测试 123service httpd configtest# 或httpd -l 基本配置监听套接字ListenSocketListen [IP]:port此指令可以出现多次，用于指定监听多个不同的套接字 12Listen 80Listen 192.168.237.68:8080 持久连接KeepAlive 参数说明 123456Keepalive off# 是否开启持久连接MaxKeepAliveRequests 100# 在保持连接中的最大请求个数KeepAliveTimeout 15# 保持连接中的超时时长 效果测试 1234567891011121314151617181920212223242526272829# 配置KeepAlive参数使用telnet命令进行效果测试，为安全起见，不建议线上环境安装telnet[root@CentOS6_8 ~]$ telnet 192.168.237.68 80Trying 192.168.237.68...Connected to 192.168.237.68.Escape character is '^]'.# 请求首部GET /index.html http/1.1Host: 192.168.237.68 ### 以下为响应中的各种首部HTTP/1.1 200 OK# version statusDate: Sat, 10 Dec 2016 13:39:57 GMT# 日期Server: Apache/2.2.15 (CentOS)# 服务器程序的名称及版本Last-Modified: Mon, 10 Jun 2013 09:24:36 GMT# 页面文件上次修改时间ETag: "41ba7-40d5-4dec9595e7d00"# 扩展标记Accept-Ranges: bytes# 接受的范围，纯字节码Content-Length: 16597# 内容长度Connection: close# 连接关闭，由于KeepAlive配置为关闭，因此此处没有持久连接，响应完就关闭Content-Type: text/html; charset=UTF-8# 内容类型 123456&lt;!--实体部分--&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;Hello World!&lt;/title&gt;&lt;/head&gt; 12Connection closed by foreign host.# 连接被远程主机关闭 多处理模块MPM 模块httpd安装完默认使用prefork模块 12345# 查看多处理模块ls /usr/sbin/httpd*# 查看编译进内核的模块httpd -lhttpd.worker -l 切换模块配置修改/etc/sysconfig/httpd 123HTTPD=/usr/sbin/httpd.worker# 默认此行注释未启用,意味着系统中使用的脚本默认为httpd# 文件中如果没有event配置项说明当前event只是测试使用 重启服务绝大多数配置修改后，可以用过service httpd reload 来生效，如果修改了监听的地址、端口、模块类型等，必须重启服务才能生效 1234service httpd restart# 服务重启ps -aux | egrep 'h[t]tp'# 进程查看，主进程主要用于子进程的创建和回收 主配置说明 123456789# preforck模块&lt;IfModule preforck.c&gt; # 判断模块是否存在 StartServers 8 # 默认启动的工作进程数 MinSpareServers 5 # 最少空闲进程数 MaxSpareServers 20 # 最大空闲进程数 ServerLimit 256 # 最大活动进程数 MaxClients 256 # 最大并发连接数，最多允许发起的连接请求的个数 MaxRequestsPerChild 4000 # 每个子进程在生命周期内最大允许服务的最多请求个数&lt;/IfModule&gt; 123456789# worker模块&lt;IfModule worker.c&gt; StartServers 4 # 启动的子进程的个数 MaxClients 300 # 最大并发连接数，最多允许发起的连接请求的个数 MinSpareThreads 25 # 最少空闲线程数 MaxSpareThreads 75 # 最大空闲线程数 ThreadsPerChild 25 # 每个子进程生成的线程数 MaxRequestsPerChild 0 # 每个子进程在声明周期内最大允许服务的最多请求个数&lt;/IfModule&gt; DSO模块加载方式1234# LoadModule module_name /path/to/module# 如果使用相对路径，则对于ServerRoot所定义的位置而言LoadMoudule php5_module /usr/lib64/httpd/modules/php.so# 若要取消加载，注释掉即可 12345# 让服务重载配置文件方能生效httpd -tservice httpd reload# 列出与加载到所有DSO模块与非DOS模块httpd -m 站点根目录1DocumentRoot /path/to/somewhere 页面访问属性1234567891011121314151617&lt;Direcotry "/path/to/somewhere"&gt; Options 选项 Indexes：缺少指定的默认页面时，允许将目录中的所有文件以列表形式返回给用户：危险：慎用 FollowsymLinks:允许跟随符号链接所指向的原始文件：危险，慎用 None：所有选项都不启用 All：所有选项都启用 ExecCGI：允许使用mod_cgi模块执行CGI脚本 Includes：允许使用mod_include模块实现服务器端包含(SSI) IncludesNOEXEC：允许包含但不允许执行脚本 MultiViews：允许使用mod_negotiation实现内容协商 SymLinksIfOwnerMatch:在链接文件属主属组与原始文件的属主属组相同时，允许跟随符号连接所指向的原始文件 AllowOverride # 指明Apache服务器是否去找.htacess文件作为配置文件， # 设置为none,那么服务器将忽略.htacess文件 # 设置为All,那么所有在.htaccess文件里有的指令都将被重写 &lt;/Direcotry&gt;# 可以使用正则表达式，使用~ 定义默认主页面1DirectoryIndex 依次查找 用户目录如果期望让每个用户都可以创建个人站点：http://Server_IP/~Username/ 123userdir disablied:禁止userdir public_html:# public_html是用户家目录下的目录名称，所有位于此目录中的文件均可通过前述的访问路径进行访问 12用户的家目录得赋予进行httpd进程的用户拥有执行权限setfacl -m u:apache:x ~Username 日志功能 存放路径/var/log/http/ 文件说明 access.log：访问日志，其需要记录的内容需要自定义 error.log：错误日志 访问日志文件格式 1CustomLog "/path/to/log_file" LogFormat 12345678910111213# LogFormat定义日志格式 "%h %l %u %t \"%r\" %&gt;s %b \"%&#123;Referer&#125;i\" \"%&#123;User-Agent&#125;i\"" %h:：remote host客户端地址 %l：remote logname远程的登录名，通常为- %u：认证时的远程用户名，通常为- %t：接收到的请求时的时间，为标准英文格式时间+时区 \"：转义，显示"" %r：请求报文的起始行 %&gt;s：响应状态码， %b：以字节响应报文的长度，不包含http报文 %&#123;Referer&#125;i：指明了请求当前资源的原始资源的URL，i表示请求首部当中这个首部的内容 %&#123;Header_Name&#125;i:记录指定请求报文首部的内容（value） %U：请求的URL 详情参考：http://httpd.apache.org/docs/2.2/mod/mod_log_config.html#logformat 路径别名12Alias /alias/ "/path/to/somewhere"# 意味着访问http://Server_IP/alias时，其页面文件来自于/path/to/somewhere中 默认字符集1AddDefaultCharset UTF-8 CGI脚本路径别名调用服务器上的脚本程序，但不希望脚本放在网站的目录下 CGICommon Gateway Interface（通用网关接口），使WEB可以跟一个应用程序进行通信，从通信环境中获得结果。但是CGI是不安全的。 文件配置 12ScriptAlias /cgi-bin/ "/www/cgi-bin/" # 路径下的文件应当可被执行# 定义cgi脚本路径别名 测试脚本vim /wwww/cgi-bin/test # 创建测试脚本 1234567891011#!/bin/bashcat &lt;&lt; EOFContent-Type:text/html#这里要有一个空行否则可能会测试不成功&lt;pre&gt;&lt;h1&gt;Hello world&lt;/h1&gt;The hostname is `hostname`.The date is `date`.&lt;/pre&gt;EOF 测试http://192.168.237.68/cgi-bin/test页面应该显示为脚本执行后的结果 访问控制基于主机的访问控制12345678910&lt;Direcotry "/path/to/somewhere"&gt; Options AllowOverride None 不禁用Order，allow，deny order 次序，写在后面的为默认 allow,deny: 没有允许的都拒绝 deny,allow：没有拒绝的都允许 Allow from Deny from &lt;/Direcotry&gt; 如果都匹配或都不匹配时以默认为准，否则则以匹配到的为准 最佳匹配：从列表中找出最小的能匹配到访问者的地址的条目为最终生效的 123456# Allow from Deny from支持的格式# IP,Network Address 192.16 192.16.0.0 192.16.0.0/16 192.16.0.0/255.255.0.0 基于用户做访问控制 当网站或者站点的某个路径只想让授权的用户访问时，可以使用基于用户的访问控制 创建的用户为虚拟用户：不是系统用户，只是为了获取某种资源类型的一种虚拟的用户 账户存放文件为/etc/httpd/conf/.htpasswd，可实现账户管理的工具有SQL数据库、dbm、ldap等 认证类型 basic：基本认证，账号和密码明文发送 digest：摘要认证，hash编码之后发送 配置说明 authn 认证提供者(authentication provider):账号和密码的存放位置 authz 授权机制(authorization):根据什么进行授权 1[root@CentOS6_8 ~]$ grep auth /etc/httpd/conf/httpd.conf 示例基于文件，做基本认证，根据用户进行授权 编辑配置 12345678&lt;Directory "/www/htdocs/fin"&gt; # options None # 不启用所有选项 AllowOverride AuthConfig # 使用认证配置 AuthType Basic # 使用基本认证 AuthName "Private Area" # 质询时标题 AuthUserFile /etc/httpd/conf/.htpasswd # 密码的存放位置 Require vaild-user # 允许访问的用户；可以指定单个用户，直接写用户即可，用户名可以写多个用空格分开；也可以指定所有用户： valid-user&lt;/Directory&gt; 创建帐号并浏览测试使用htpsswdm命令使用生成认证库 1htpasswd -c -m /etc/httpd/conf/.htpasswd monitor 12345htpasswd -c 创建密码，创建第一个用户时使用，创建第二个以上的用户使使用该项会覆盖文件 -m MD5格式存放 -b 批量模式 -D 删除用户 基于URL访问属性12&lt;Location [~] ""&gt;&lt;/Location &gt; 基于单个文件访问属性1234567&lt;File [~] ""&gt;&lt;/File&gt;# 也可以使用&lt;LocationMatch ""&gt;&lt;/LocationMatch&gt;# 来实现正则表达式的配置# 如果要配置其属性的URL能映射到某具体文件系统路径，建议使用&lt;Directory&gt; 虚拟主机一个物理服务器提供多个站点；使用虚拟主机得先取消中心主机 不同方式实现虚拟主机 基于不同的IP对IP进行变更 基于不同的port对port进行变更 基于不同主机名对ServerName的值进行变更，通过请求报文中的HOST来实现不同的虚拟主机访问 针对虚拟主机可以做以下单独配置 用户认证 访问日志 错误日志 别名 脚本别名 注释主服务器,添加虚拟主机 12# DocumentRoot "/var/www/html"# 注释掉 文件配置 123456789101112131415161718NameVirtualHost *:80&lt;VirtualHost *:80&gt; ServerName wwww.a.com DocumentRoot "/web/a.com/htdocs" CustomLog "/var/log/httpd/www.a.com.acclog_log" combined&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt; ServerName wwww.b.cn DocumentRoot "/web/b.cn/htdocs" CustomLog "/var/log/httpd/www.b.cn.acclog_log" combined&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt; ServerName wwww.c.org DocumentRoot "/web/c.org/htdocs" CustomLog "/var/log/httpd/www.c.org.acclog_log" combined&lt;/VirtualHost&gt; 测试 12345678910111213141516mkdir -pv /web/&#123;a.com,b.cn,c.org&#125;/htdocs# 创建站点目录httpd -t # 检查配置文件语法echo www.a.com &gt; /web/a.com/htdocs/index.html echo www.b.cn &gt; /web/b.cn/htdocs/index.html echo www.c.org &gt; /web/c.org/htdocs/index.html # 创建测试页面service httpd restart# 重启服务elinks -dump www.a.com# 使用elinks测试站点 Server Status httpd内生的status信息，且此信息可以通过web予以显示 处理器：文件被调用时Apache内部表现形式：一般每种文件类型都有其隐式处理器；否则需要自己定义 显式的定义使用的处理器：SetHandler 1234567891011# 配置信息# 由于status页面信息敏感，因此建议对页面做访问控制&lt;Location /server-status&gt; SetHandler server-status AuthType Basic AuthName "Server Status" AuthUserFile "/etc/httpd/conf/.htpasswd" Require User "monitor" Order deny,allow Allow from all&lt;/Location&gt; 在URL后添加/server-status访问测试http://192.168.237.68/server-status curl命令curl是基于URL语法在命令行方式下工作的文件传输工具，它支持FTP, FTPS, HTTP, HTTPS, GOPHER, TELNET, DICT, FILE及LDAP等协议。curl支持HTTPS认证，并且支持HTTP的POST、PUT等方法， FTP上传， kerberos认证，HTTP上传，代理服务器， cookies， 用户名/密码认证， 下载文件断点续传，上载文件断点续传,，http代理服务器管道（ proxy tunneling）， 甚至它还支持IPv6， socks5代理服务器,，通过http代理服务器上传文件到FTP服务器等等，功能十分强大。 -I，--head 只显示响应报文首部信息 1234567891011-A/--user-agent &lt;string&gt; 设置用户代理发送给服务器，即告诉服务器浏览器是什么-e/--referer &lt;URL&gt; 来源网址，跳转过来的网址-basic 使用HTTP基本验证 -I/--head 只显示响应报文首部信息 -H/--header &lt;line&gt;自定义头信息传递给服务器--tcp-nodelay 使用TCP_NODELAY选项--cacert &lt;file&gt; 指定CA证书 (SSL)--compressed 要求返回是压缩的形势，如果文件本身为一个压缩文件，则可以下载至本地--limit-rate &lt;rate&gt; 设置传输速度-u/--user &lt;user[:password]&gt;设置服务器的用户和密码-0/--http1.0 使用HTTP 1.0]]></content>
      <categories>
        <category>Services</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP 基础]]></title>
    <url>%2F2016%2F02%2F07%2F2016-02-07-083128-HTTP%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[HTTP协议超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。http是一种stateless（无状态）协议，一次事务结束后连接将立即断开。 协议版本 http0.9：只能传输html文档，1991年 http1.0：支持多媒体数据的处理，保持连接。具有缓存功能 http1.1：支持更多的请求方法，更加精细的缓存控制，持久连接 HTTP报文HTTP报文由从客户机到服务器的请求和从服务器到客户机的响应构成。 请求报文1234# 请求行 － 通用信息头 － 请求头 － 实体头 － 报文主体&lt;method&gt;&lt;request-url&gt;&lt;version&gt;&lt;headers&gt;&lt;entity-body&gt; 响应报文1234# 状态行 － 通用信息头 － 响应头 － 实体头 － 报文主体&lt;version&gt;&lt;status&gt;&lt;reason-phrase&gt;&lt;headers&gt;&lt;entity-body&gt; 1234567&lt;method&gt; # 请求方法，希望服务器端执行的动作，如GET、HEAD、POST等&lt;request-url&gt; # 请求的资源，可以是相对路径，也可以是完整的URL&lt;version&gt; # 协议版本，格式HTTP/&lt;major&gt;。&lt;minor&gt;，如http/1.0&lt;headers&gt; # HTTP首部&lt;status&gt; # 状态码&lt;reason-phrase&gt; # 原因短语，数字状态吗易读信息&lt;entity-body&gt; # 主体部分 请求方法 安全方法：客户端只需要请求而不需要操作服务器的资源 GET：请求获取一个资源，需要服务器发送传回响应 HEAD：跟GET相似，但不需要服务发送资源而仅传回响应报文首部 提交表单方法 POST：支持HTML表单提交，表单中有用户填入的数据，这些数据会发送到服务器端，由服务器存储至某位置 危险方法： PUT：与GET相反，向服务写入文档、发布系统 DELETE：请求删除URL指向的资源 OPTIONS：探测服务器端对某资源所支持的请求方法 TRACE：追踪请求资源要经过的防火墙、代理或网关等 扩展方法： LOCK MKCOL COPY MOVE 常见状态码 1XX：客户端信息性状态码 100 Continue：服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。 101 Switching Protocols：服务器转换协议，服务器将遵从客户的请求转换到另外一种协议。 2XX：成功状态码 200 OK：请求成功（其后是对GET和POST请求的应答文档） 201 Created：请求被创建完成，同时新的资源被创建 202 Accepted：供处理的请求已被接受，但是处理未完成 3XX：重定向状态码 301 Moved Permanebtly：永久重定向，在响应报文中使用首部“Location：URL”指定资源现在所在的位置 302 Found：临时重定向，在响应报文中使用首部“Location：URL”指定临时资源位置 304 Not Modified：条件式请求中使用 4XX：客户端错误 403 Forbidden：请求被服务器拒绝 404 Not Found：服务器无法找到请求的URL 405 Method Not Allowed：不允许使用此方法请求响应的URL 5XX：服务器错误 500 Internal Server Error：服务器内部错误 502 Bad Gateway：代理服务器从上游收到一条伪（无效的）响应 503 Service Unavailable：服务器此时无法提供服务，但将来可能可用 504 Gateway Timeout：网关超时 HTTP首部通用首部请求和响应都可以使用的 Connection：定义C/S之间关于请求/响应的有关选项，对于http/1.0：Connection keep-alibe Via：显示了报文经过的中间节点 Cache-Control：缓存指示 请求首部只有请求首部的 Cilent-IP：请求端IP Host：请求的主机名和端口号，虚拟主机环境下用于标识不同的虚拟主机 Referer：指明了请求当前资源的原始资源的URL，即跳转到当前资源的来源URL User-Agent：用户代理，使用什么工具发出的请求 Accept首部：用户标明客户自己更倾向于支持使用的方式 Accept：指明服务器能发送的媒体类型 Accept-Charset：支持使用的字符集 Accept-Encoding：支持使用的编码方式 Accept-Language：支持使用语言 条件请求首部： Expect：期望的行为 If-Modified-Since：是否在指定的时间以来修改过此资源 If-None-Match： 跟安全相关的请求首部： Authorication：客户端提交给服务端的认证数据，如账号和密码 Cookie：客户端发送给服务器端身份标识 Cookie2 响应首部只有响应首部的 Age：响应持续的时间 Server：向客户端标明服务器程序名称和版本 协商首部： Accept-Ranges：对当前资源来讲，服务器所能够接受的范围类型 Vary：首部列表，服务器会根据列表中的内容挑选出最适合的版本发送给客户端跟安全相关的响应首部 Set-Cookie：服务器端在某客户端第一次请求时发给的令牌 Set-Cookie2： WWW-Authenication：质询，即要求客户端提供账号和密码 实体首部用于定义实体属性的 Location：资源的新位置 Allow：允许对此资源使用的请求方法 内容首部：用来表明内容格式、类型等 Contern-Encoding：内容编码 Contern-Language：内容语言 Contern-Length：内容长度 Contern-type：内容类型 Contern-Range：内容范围 Contern-Location：内容位置 缓存首部： ETag：实体标签 Expires：过期标签 Last-Modified：上一次的修改时间 扩展首部非标准首部，可能是由程序开发者创建的，例如X-Forward-For 事务一次请求以及与其对应的响应，称为一个事务。 提高事务处理性能的方法： 持久连接 并行连接 并行连接的缺点： 每个事务都会打开/关闭一条新的连接，耗费时间和带宽 由于TCP的慢启动特性，每条新连接的性能都会有所降低 可打开的并行连接数量实际上是有限的. 一次基本的web服务请求过程 Web服务器的输入输出结构 单线程I/O结构 多线程I/O结构 复用的I/O结构（一个进程响应多个请求） 复用多线程I/O结构：多个线程，每个线程响应多个请求]]></content>
      <categories>
        <category>Services</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DHCP Service]]></title>
    <url>%2F2016%2F02%2F06%2F2016-02-06-164633-DHCP%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[DHCP DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）是一个局域网的网络协议，使用UDP协议工作。主要有两个用途：给内部网络或网络服务供应商自动分配IP地址。 DHCP有3个端口，其中 UDP 67 和 UDP 68 为正常的DHCP服务端口，分别作为DHCP Server和DHCP Client的服务端口；546 端口用于DHCPv6 Client，而不用于DHCPv4，是为DHCP failover服务，这是需要特别开启的服务，DHCP failover是用来做“双机热备”的。 功能 保证任何IP地址在同一时刻只能由一台DHCP客户机所使用。 DHCP应当可以给用户分配永久固定的IP地址。 DHCP应当可以同用其他方法获得IP地址的主机共存（如手工配置IP地址的主机）。 DHCP服务器应当向现有的BOOTP客户端提供服务。 工作原理 DHCP Client以广播方式发出DHCP Discover报文。 所有的DHCP Server都能够接收到DHCP Client发送的DHCP Discover报文，所有的DHCP Server都会给出响应，向DHCP Client发送一个DHCP Offer报文。 DHCP Offer报文中“Your(Client) IP Address”字段就是DHCP Server能够提供给DHCP Client使用的IP地址，且DHCP Server会将自己的IP地址放在“option”字段中以便DHCP Client区分不同的DHCP Server。DHCP Server在发出此报文后会存在一个已分配IP地址的纪录。 DHCP Client只能处理其中的一个DHCP Offer报文，一般的原则是DHCP Client处理最先收到的DHCP Offer报文。 DHCP Client会发出一个广播的DHCP Request报文，在选项字段中会加入选中的DHCP Server的IP地址和需要的IP地址。 DHCP Server收到DHCP Request报文后，判断选项字段中的IP地址是否与自己的地址相同。如果不相同，DHCP Server不做任何处理只清除相应IP地址分配记录；如果相同，DHCP Server就会向DHCP Client响应一个DHCP ACK报文，并在选项字段中增加IP地址的使用租期信息。 DHCP Client接收到DHCP ACK报文后，检查DHCP Server分配的IP地址是否能够使用。如果可以使用，则DHCP Client成功获得IP地址并根据IP地址使用租期自动启动续延过程；如果DHCP Client发现分配的IP地址已经被使用，则DHCP Client向DHCPServer发出DHCP Decline报文，通知DHCP Server禁用这个IP地址，然后DHCP Client开始新的地址申请过程。 DHCP Client在成功获取IP地址后，随时可以通过发送DHCP Release报文释放自己的IP地址，DHCP Server收到DHCP Release报文后，会回收相应的IP地址并重新分配。 分配机制注意：只有动态分配可以重复使用客户端不再需要的地址。 自动分配方式（Automatic Allocation） DHCP服务器为主机指定一个永久性的IP地址，一旦DHCP客户端第一次成功从DHCP服务器端租用到IP地址后，就可以永久性使用该地址。 动态分配方式（Dynamic Allocation） DHCP服务器给主机指定一个具有时间限制的IP地址，时间到期或主机明确表示放弃该地址时，该地址可以被其他主机使用。 手工分配方式（Manual Allocation） 客户端的IP地址是由网络管理员指定的，DHCP服务器只是将指定的IP地址告诉客户端主机。 安装配置安装软件包yum -y install dhcp 生成配置文件模板cp /usr/share/doc/dhcp-4.1.1/dhcpd.conf.sample /etc/dhcp/dhcpd.conf 注意：新版默认目录 /etc/dhcp/dhcpd.conf 。旧版是 /etc/dhcpd.conf 文件配置vim /etc/dhcp/dhcpd.conf 1234567891011121314151617181920212223242526272829303132ddns-update-style interim; #表示dhcp服务器和dns服务器的动态信息更新模式ignore client-updates;#忽略客户端更新 subnet 192.168.247.0 netmask 255.255.255.0 &#123; #dhcp服务器所分配的ip地址所在的网段为192.168.247.0 子网掩码为255.255.255.0 option routers 192.168.247.1; #路由器地址，即给客户端提供的网关地址 option subnet-mask 255.255.255.0; #子网掩码 # option domain-name "example.org"; # 搜索域，具体为/etc/resov.conf中search行对应的域 option domain-name-servers 114.114.114.114; # DNS服务器地址，最多三个，以逗号隔开 range 192.168.247.100 192.168.247.200; # 租用IP地址的范围，linux环境下从后往前分配 default-lease-time 600; #默认租约时间 max-lease-time 7200; #最大租约时间 host myhost &#123; #固定分配，myhost为标识符，无实际意义 hardware ethernet MAC_ADDRESS; #指定dhcp客户的mac地址 fixed-address 192.168.247.155; #给指定的mac地址分配ip &#125; &#125; 服务启动service dhcpd start]]></content>
      <categories>
        <category>Services</category>
      </categories>
      <tags>
        <tag>DHCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS服务]]></title>
    <url>%2F2016%2F02%2F05%2F2016-02-05-123530-DNS%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[DNS服务DNS基础DNS（Domain Name System，域名系统），在Internet上作为域名与IP地址相互映射的一个分布式数据库，能够使用户更方便的使用域名访问互联网，而不用去记住只能被机器识别的IP地址。域名(FQDN)和IP地址之间的转换工作称为域名解析（或主机名解析）。 ICANN ICANN，全称Internet Corporation for Assigned Names and Numbers(互联网名称与数字地址分配机构)，是一个非盈利性的国际组织，负责互联网协议(IP)地址的空间分配，协议标示符的指派，通用顶级域名 (gTLD)以及国家和地区顶级域名(ccTLD)系统的管理，以及根服务器系统的管理。官方网址是：http://www.icann.org ICANN的作用：负责协调管理DNS各技术要素以确保普遍可解析性，使所有的互联网用户都能够找到有效的地址。它是通过监督互联网运作当中独特的技术标示符的分配以及顶级域名的授权来做到这点的。 hosts映射 早期，名字到地址的转换过程十分简单。每台计算机保存一个hosts文件，里面列出所有计算机名字和对应的IP地址，然后定期从一个维护此文件的站点更新里面的记录。当我们访问某个计算机名字时，先在hosts文件找到对应的IP，然后就可以建立连接。 随着网络规模的扩大，这种方法渐渐吃不消了。主要有以下三个原因： hosts文件变得非常大 主机名字会冲突 集中的维护站点会不堪重负 域名结构 通常 Internet 主机域名的一般结构为：主机名.三级域名.二级域名.顶级域名。 Internet 的顶级域名由 Internet网络协会域名注册查询负责网络地址分配的委员会进行登记和管理，它还为 Internet的每一台主机分配唯一的 IP 地址。全世界现有三个大的网络信息中心： 位于美国的 Inter-NIC，负责美国及其他地区； 位于荷兰的RIPE-NIC，负责欧洲地区；位于日本的APNIC，负责亚太地区 监听的端口 12353/udp # 普通查询53/tcp # 从服务器到主服务器进行数据传输，为保证数据完整性，使用tcp协议953/tcp# rndc远程域名服务器控制器 DNS的功能 每个IP地址都可以有一个主机名，主机名由一个或多个字符串组成，字符串之间用小数点隔开。有了主机名，就不用死记硬背每台IP设备的IP地址，只要记住相对直观有意义的主机名就行了。这就是DNS协议所要完成的功能。 正反解析 正向解析：从域名到ip地址的解析过程 反向解析：从ip地址到域名的解析过程，反向解析一般用来进行服务器的身份验证 DNS查询 查询的优先级本地hosts文件---&gt;本地缓存---&gt;本地DNS区域文件 分级查询从根域开始，依次查询每一级域名的NS记录，直到查到最终的IP地址。DNS服务器根据域名的层级，进行分级查询。每一级域名都有自己的NS记录，NS记录指向该级域名的域名服务器。这些服务器知道下一级域名的各种记录。 递归查询：客户端向DNS服务器发送一次请求，DNS服务器逐级完成查询完成后直接返回结果。对于客户端来讲为递归查询，对于DNS服务器来讲是迭代查询。 迭代查询：客户端需要发起多次请求才可得到结果 默认情况下，DNS服务器使用递归方式来解析域名。递归的含义就是DNS服务器作为DNS客户端向其他DNS服务器查询此解析请求，直到获得解析结果，在此过程中，原客户端则等待DNS服务器的回复。 参考链接： http://blog.csdn.net/lycb_gz/article/details/11720247 DNS应答 权威应答如果DNS服务器在自己的区域文件里找到了客户端需要查询的记录，就会返回一个权威性应答。如果DNS服务器最近被查找过该主机记录，就会在缓存里找到记录应答客户端。如果找不到主机的A记录，就会返回（RecordNotFound）应答――同样是权威性应答。 非权威应答如果接到DNS查询请求的服务器不是指定域的名称服务器，则：首先查询其他DNS服务器直到找到，然后此服务器将找到的内容返回给客户端――非权威性应答。其次，推荐客户端到上一级DNS服务器找。―――非权威性应答。 DNS冗余 为保证服务的高可用性，DNS要求使用多台名称服务器冗余支持每个区域。某个区域的资源记录通过手动或自动方式更新到单个主名称服务器（称为主DNS服务器）上，主 DNS 服务器可以是一个或几个区域的权威名称服务器。 其它冗余名称服务器（称为辅 DNS 服务器）用作同一区域中主服务器的备份服务器，以防主服务器无法访问或宕机。辅 DNS服务器定期与主 DNS 服务器通讯，确保它的区域信息保持最新。如果不是最新信息，辅DNS服务器就会从主服务器获取最新区域数据文件的副本。这种将区域文件复制到多台名称服务器的过程称为区域复制。 服务器类型 主从服务器：主服务器数据修改，辅助服务器请求数据同步 缓存服务器 转发器 资源记录 为了将名字解析为IP地址，服务器查询它们的区(DNS数据库文件)。区中包含组成相关DNS域资源信息的资源记录（RR）。 某些资源记录不仅包括DNS域中服务器的信息，还可以用于定义域，即指定每台服务器授权了哪些域，这些资源记录就是SOA和NS资源记录。 数据库中的每一个条目称作是一个资源记录(Resource Record，RR)，它是一个五元组，可以用以下格式表示： 1234567Domain_name Time_to_live Class Type Value## Domain_name 指出这条记录适用于哪个域名# Time_to_live 用来表明记录的生存周期，也就是说最多可以缓存该记录多长时间，可省略# Class 一般总是IN；对应的是internet# Type 资源记录的类型# Value 记录的值，如果是A记录，则value是一个IPv4地址 名称 TTL值(可选) Internet 资源记录类型 值 NAME TTL IN RRT VALUE www.nettest.net 600 IN A 161.202.43.78 161.202.43.78 600 IN PTR www.nettest.net 资源记录及类型 Bind安装配置Bind 全称是Berkeley Internet Name Domain(伯克利因特网名字域系统)。 官方网址：http://www.isc.org/ 它主要有3个版本：BIND 4，BIND 8，BIND9。 业务需求 购买的域名以及IP资源 netpas.infonetpas.co36.110.137.112/2860.12.69.160/27106.38.222.176/28 需求 主从权威名称服务器ns1.netpas.info 36.110.137.123(虚拟机使用192.168.247.123代替)ns2.netpas.info 60.12.69.164(虚拟机使用192.168.247.164代替) 邮件服务器mail.netpas.co 36.110.137.123 网站服务器www.netpas.co 36.110.137.126 ftp服务器ftp.netpas.co 106.38.222.181 别名www2.netpas.co -&gt; www.netpas.co 安装配置 配置yum源，安装bind的rpm包 12yum list all | grep '^bind'yum -y install bind 文件说明 1234567891011121314/usr/sbin/named# 主程序文件/etc/named.conf# 主配置文件options&#123;....&#125;;# 全局配置段logging&#123;....&#125;;# 日志配置段zone&#123;.....&#125;;# 由本机负责解析的区域或转发的区域/var/named/# 数据文件目录/var/named/named.ca# 存放根域的配置文件 区域配置的语法结构 区域 12345zone "ZONE NAME" IN &#123; type &#123;master|slave|hint|forward&#125;; ;主 |从 |根 |转发器 file "区域数据文件";&#125;; 主区域 1file "区域数据文件"; 从区域 12file "区域数据文件";masters &#123; master_ip; &#125;; 在主机192.168.247.123配置named.conf编辑/etc/named.conf 123456789101112131415161718192021222324252627282930313233343536options &#123; listen-on &#123; 192.168.247.123;&#125;; allow-transfer &#123;"none";&#125;; allow-recursion &#123;"any";&#125;; recursion yes; allow-query &#123;any;&#125;; max-cache-ttl 900; directory "/var/named"; pid-file "/var/named/named.pid"; dump-file "/var/named/named_dump.db"; statistics-file "/var/named/named.status";&#125;;zone "." IN &#123; type hint; file "named.ca";&#125;;zone "localhost" IN &#123; type master; file "named.localhost";&#125;;zone "0.0.127.in-addr.arpa" IN &#123; type master; file "named.loopback";&#125;;zone "netpas.info" IN &#123; type master; file "zone.netpas.info";&#125;;zone "netpas.co" IN &#123; type master; file "zone.netpas.co";&#125;;zone "137.110.36.in-addr.arpa" IN &#123; type master; file "zone.36.110.137";&#125;; 修改语法，检查配置，启动服务 12345678chown root:named /etc/named.confnamed-checkconfnamed-checkzone "localhost" /var/named/named.localhost named-checkzone "0.0.127.in-addr.arpa" /var/named/named.loopback setenforce disabled/bin/sed -ri 's/(^SELINUX=).*/\1disabled/' /etc/selinux/config/usr/sbin/named -u root -c /etc/named.conf echo "/usr/sbin/named -u root -c /etc/named.conf" &gt;&gt; /etc/rc.local 修改本地DNS，进行测试 1sed -ri 's#^(nameserver).*#\1 192.168.247.123#' /etc/resolv.conf 1234567891011121314dig -t NS . @192.168.247.123 +short # 确保网络畅通c.root-servers.net.g.root-servers.net.l.root-servers.net.f.root-servers.net.m.root-servers.net.e.root-servers.net.j.root-servers.net.a.root-servers.net.k.root-servers.net.i.root-servers.net.b.root-servers.net.h.root-servers.net.d.root-servers.net. 1234dig @192.168.247.123 www.baidu.com +shortwww.a.shifen.com.61.135.169.12561.135.169.121 1234567ping www.baidu.com -c 2PING www.a.shifen.com (61.135.169.121) 56(84) bytes of data.64 bytes from 61.135.169.121: icmp_seq=1 ttl=56 time=7.63 ms64 bytes from 61.135.169.121: icmp_seq=2 ttl=56 time=7.56 ms--- www.a.shifen.com ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1008msrtt min/avg/max/mdev = 7.566/7.599/7.633/0.093 ms 区域文件/var/named/zone.netpas.info 1234567891011$TTL 600@ IN SOA @ memory.netpas.co. ( 2006103002 ; Serial at current time 1D ; Refresh after 1 day 1H ; Retry after 1 houre 1M ; Expire after 1 month 1W) ; Minimum TTL of 1 weeknetpas.info. IN NS ns1.netpas.info.@ IN NS ns2 ; 区域名称可省略，自动补全ns1 IN A 192.168.247.123ns2 IN A 192.168.247.164 区域文件/var/named/zone.netpas.co 12345678910111213141516$TTL 600@ IN SOA @ memory.netpas.co. ( 2010111004 ;Serial at current time 86400 ;Refresh after 1 day 3600 ;Retry after 1 houre 2419200 ;Expire after 1 month 60480 ;Minimum TTL of 1 week)@ IN NS ns1.netpas.info.@ IN NS ns2.netpas.info.@ IN MX 10 mail.netpas.co.www IN A 36.110.137.126www2 IN CNAME wwwftp IN A 36.110.137.181mail IN A 36.110.137.123* IN A 36.110.137.126 ;*代表所有，即*.netpas.co 对区域进行检查和文件权限，属主属组的修改；重读配置文件进行测试 12chmod 640 /var/named/zone.netpas.*chown root:named /var/named/zone.netpas.* 123named-checkzone "netpas.co" /var/named/zone.netpas.co named-checkzone "netpas.info" /var/named/zone.netpas.infopkill -1 named 12345dig @192.168.247.123 -t NS netpas.codig @192.168.247.123 -t A ftp.netpas.codig @192.168.247.123 -t A ns1.netpas.infodig @192.168.247.123 -t MX netpas.co dig -x 36.110.137.123 主从复制及区域传送Bind配置从服务器（slave）192.168.247.164 bind配置，配置完成后进行主、从DNS日期时间同步 123456789setenforce disabledsed -ri 's/(^SELINUX=).*/\1disabled/' /etc/selinux/configyum list all | grep '^bind'yum -y install bindchown -R named:named /var/named/ chmod 770 /var/named/ cd /etc/ ; mv named.conf&#123;,.orig&#125;scp -p 2828 root@192.168.247.123:/etc/named.conf ./ chown root:named /etc/named.conf 主配置文件配置生成区域文件的工具: http://pgl.yoyo.org/adservers/bind-zone-file-creator.php 主DNS (/etc/named.conf)12345678910111213141516171819202122232425262728293031323334353637options &#123; listen-on &#123;192.168.247.123;&#125;; allow-transfer &#123;"none";&#125;; allow-recursion &#123;"any";&#125;; recursion yes; notify yes;;启用通知从服务器同步功能 allow-query &#123;any;&#125;; max-cache-ttl 900; directory "/var/named"; pid-file "/var/named/named.pid"; dump-file "/var/named/named_dump.db"; statistics-file "/var/named/named.status";zone "localhost" IN &#123; type master; file "named.localhost"; allow-transfer &#123;none;&#125;;&#125;;zone "0.0.127.in-addr.arpa" IN &#123; type master; file "named.loopback"; allow-transfer &#123;none;&#125;;&#125;;zone "netpas.info" IN &#123; type master; file "zone.netpas.info"; allow-transfer &#123;192.168.247.164;&#125;;&#125;;zone "netpas.co" IN &#123; type master; file "zone.netpas.co"; allow-transfer &#123;192.168.247.164;&#125;;&#125;;zone "137.110.36.in-addr.arpa" IN &#123; type master; file "zone.36.110.137"; allow-transfer &#123;192.168.247.164;&#125;;&#125;; 从DNS (/etc/named.conf)1234567891011121314151617181920212223242526272829303132options &#123; listen-on &#123;192.168.247.164;&#125;; allow-transfer &#123;"none";&#125;; allow-recursion &#123;"any";&#125;; recursion yes; allow-query &#123;any;&#125;; max-cache-ttl 900; directory "/var/named"; pid-file "/var/named/named.pid"; dump-file "/var/named/named_dump.db"; statistics-file "/var/named/named.status"; masterfile-format text; ;以防出现乱码&#125;;zone "." IN &#123; type hint; file "named.ca";&#125;;zone "netpas.info" IN &#123; type slave; ;类型为从服务器 masters &#123; 192.168.247.123; &#125;; ;定义主服务器 file "zone.netpas.info";&#125;;zone "netpas.co" IN &#123; type slave; masters &#123; 192.168.247.123; &#125;; file "zone.netpas.co";&#125;;zone "137.110.36.in-addr.arpa" IN &#123; type slave; masters &#123; 192.168.247.123; &#125;; file "zone.36.110.137";&#125;; 区域传送测试 重启进程 12pkill -9 named;/usr/sbin/named -u named -c /etc/named.confpkill -9 named;/usr/sbin/named -u named -c /etc/named.conf 查看日志此处以私网地址模拟公网实际情况 主(tail /var/log/messages) 辅(tail /var/log/messages) 从服务器更新测试 修改主服务器区域文件，添加一条NS记录并修改序列号 主服务器重启进程，测试从服务器是否正常同步 rndc远程控制 在主DNS生成rndc.conf配置文件 12rndc-confgen -s 127.0.0.1 -r /dev/urandom &gt; /etc/rndc.confchown named:named /etc/rndc.conf 1234567891011121314151617181920212223cat /etc/rndc.conf # Start of rndc.confkey "rndc-key" &#123; algorithm hmac-md5; secret "01w5DHWUh7M4C+klEDKUjg==";&#125;;options &#123; default-key "rndc-key"; default-server 127.0.0.1; default-port 953;&#125;;# End of rndc.conf# Use with the following in named.conf, adjusting the allow list as needed:# key "rndc-key" &#123;# algorithm hmac-md5;# secret "01w5DHWUh7M4C+klEDKUjg==";# &#125;;# # controls &#123;# inet 127.0.0.1 port 953# allow &#123; 127.0.0.1; &#125; keys &#123; "rndc-key"; &#125;;# &#125;;# End of named.conf 将开头的”key”节覆盖到/etc/rndc.key 12345# Start of rndc.confkey "rndc-key" &#123; algorithm hmac-md5; secret "01w5DHWUh7M4C+klEDKUjg==";&#125;; 将#开头的行写到/etc/named.conf文件中，并修改 12345678key "rndc-key" &#123; algorithm hmac-md5; secret "01w5DHWUh7M4C+klEDKUjg==";&#125;;controls &#123; inet 192.168.247.123 port 953 allow &#123; any; &#125; keys &#123; "rndc-key"; &#125;;&#125;; 修改/etc/rndc.conf 1234567891011# Start of rndc.confkey "rndc-key" &#123; algorithm hmac-md5; secret "01w5DHWUh7M4C+klEDKUjg==";&#125;;options &#123; default-key "rndc-key"; default-server 192.168.247.123; default-port 953;&#125;;# End of rndc.conf 命令测试 1234rndc -c /etc/rndc.conf status rndc -c /etc/rndc.conf notify "xingxing.com" # 手动通知区域rndc -c /etc/rndc.conf flush # 清空缓存rndc -c /etc/rndc.conf stop # 停止dns服务 从DNS（slave dns server ）远程控制本机 12scp -P 22 /etc/rndc.conf 192.168.247.164:/root/rndc -c /root/rndc.conf status 子域授权 应用场景子域授权，在原有的域上再划分出一个小的区域并指定新DNS服务器。在这个小的区域中如果有客户端请求解析，则只要找新的子DNS服务器。这样的做的好处可以减轻主DNS的压力，也有利于管理。这里只做正向区域的子域授权。 文件配置以子域m.netpas.co.为例 主DNS配置在主DNS的/var/named/zone.netpas.co添加子域资源记录并修改序列号，重新加载进程完成主从同步 12m IN NS ns1.m.netpas.co.ns1.m IN A 192.168.247.68 子域服务器配置在子域m.netpas.co.服务器进行相关配置，启动服务 123456789101112131415161718192021222324# /etc/named.confoptions &#123; listen-on &#123;192.168.247.68;&#125;; recursion yes; allow-query &#123;any;&#125;; directory "/var/named";&#125;;zone "m.netpas.co" IN &#123; type master; file "zone.m.netpas.co";&#125;;# /var/named/zone.m.netpas.co$TTL 600@ IN SOA @ memory.netpas.co. ( 2006103001; Serial at current time 1D ; Refresh after 1 day 1H ; Retry after 1 houre 1M ; Expire after 1 month 1W) ; Minimum TTL of 1 week@ IN NS ns1ns1 IN A 192.168.247.68www IN A 192.168.247.69 主DNS测试 12dig -t ns m.netpas.co dig www.m.netpas.co 子域DNS测试 12dig @192.168.247.68 www.netpas.co# 无法获取正常结果，需要向父域转发 转发器在DNS服务器的配置中，如果采用默认的配置，其实效率是较低的，因为默认情况下，我们所有的非权威解析都会被发送到根服务器进行迭代查询。如果采用转发，如将我们的DNS解析请求转发到一些公共DNS服务器上，由于公共DNS服务器上缓存了大量的解析，因此能较原始的迭代查询快。全局转发：作用：实现对非权威解析（已缓存的除外）都转发到特定DNS服务器配置办法 配置参数说明 123forward &#123; only | first &#125; ;only 先转发到转发器，如果得不到答案自己不会尝试解析 ;first 先转发到转发器，如果得不到答案则向根发起请求 子域DNS服务器配置文件 123456# 在子域DNS服务器的`/etc/named.conf`加入以下两行 forward first; forwarders &#123; 192.168.247.123; &#125;;# 如果仅设置“forwarders”，则在无法联系转发器时，就会尝试自己解析，即转发到根服务器迭代查询实现解析（如果配置有根zone）。# 如果想服务器在联系不到转发器时不进行多余操作，则可以加上“forward only; ”；这样如果联系不上转发器时，服务器将只查询权威解析和本地缓存的解析。 # 区域转发：从BIND9.1开始，引入一个新特新：转发区（forward zone ），及允许查询特定区域时，将其转发到指定DNS服务器上。 测试 12# 重启服务，测试dig @192.168.247.68 www.netpas.co DNS视图 智能DNS智能DNS是域名服务在业界首创的智能解析服务。能自动判断访问者的IP地址并解析出对应的IP地址，使网通用户会访问到网通服务器，电信用户会访问到电信服务器。 ACL 和 VIEW ACL的应用与配置在named.conf的全局配置中，有如下这样的一行定义允许为那些客户端进行递归查询：allow-query { 192.168.8.0/24; };这里只允许了这一个IP段，如果是大型企业或者公网我们需要允许的客户端有上百个IP段时，这里会写很长而且如果在多个地方需要用到，则需写多次，配置麻烦且影响查看。因此引入ACL，可以实现集中定义，所有位置均可引用。ACL类似程序开发中的函数。例如: 12345678910acl trust &#123; 172.16.100.0/24； 10.35.0.0/24； 192.168.0.0/24； 127.0.0.1；&#125;;options &#123; allow-query &#123; trust; &#125;; ;引用上面定义的ACL……其他配置省略……&#125;;` 视图viewview将不同IP地址段发来的查询响应到不同的DNS解析。例如需要对多个不同IP地址段进行配置，就需要明确这些IP地址段，这样View功能才会有效。注意，一旦使用view，所有域都必须定义在view。 使用bind实现智能DNS 需求说明 创建tel_ip、cnc_ip、cm_ip、crc_ip、edu、other 6个访问控制列表表示不同来源(电信，联通，移动，铁通，教育，其他，默认)，以区域netpas.cc和netpas.co为例，实现智能DNS 由于IP地址段数量较大，因此在/var/named/目录下创建目录acl存放不同来源的IP段 配置步骤 1234mkdir -pv /var/named/aclcd /var/named/aclchown -R named:named /var/named/acl/ touch &#123;tel,cnc,cm,crc,edu,other&#125;_ip 分别在不同文件创建对应的acl，以下为范例： 1234567891011# tel_ip acl tel_ip&#123; 1.0.1.0/24; 223.255.252.0/23;&#125;;# cnc_ip acl cnc_ip&#123; 1.24.0.0/13; 223.166.0.0/15;&#125;;# 以上地址段只写了两个,实际情况需要写上百条,每个地址段占用一行,以分号结尾 在/etc/named.conf中添加视图配置以及对acl文件进行include包含 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132 options &#123; listen-on &#123;192.168.247.123;&#125;; allow-transfer &#123;"none";&#125;; allow-recursion &#123;"any";&#125;; recursion yes; allow-query &#123;any;&#125;; max-cache-ttl 900; directory "/var/named"; pid-file "/var/named/named.pid"; dump-file "/var/named/named_dump.db"; statistics-file "/var/named/named.status";&#125;;view "tel" &#123; match-clients &#123; tel_ip;&#125;; zone "netpas.info" in &#123; type master; file "zone.netpas.info"; allow-update&#123;none;&#125;; &#125;; zone "netpas.co" in &#123; type master; file "zone.netpas.co.tel"; allow-update&#123;none;&#125;; &#125;;&#125;;view "cnc" &#123; match-clients &#123; cnc_ip; &#125;; zone "netpas.info" in &#123; type master; file "zone.netpas.info"; allow-update&#123;none;&#125;; &#125;; zone "netpas.co" in &#123; type master; file "zone.netpas.co.cnc"; allow-update&#123;none;&#125;; &#125;;&#125;;view "cm" &#123; match-clients &#123; cm_ip; &#125;; zone "netpas.info" in &#123; type master; file "zone.netpas.info"; allow-update&#123;none;&#125;; &#125;; zone "netpas.co" in &#123; type master; file "zone.netpas.co.tel"; allow-update&#123;none;&#125;; &#125;;&#125;;view "crc" &#123; match-clients &#123; crc_ip;&#125;; zone "netpas.info" in &#123; type master; file "zone.netpas.info"; allow-update&#123;none;&#125;; &#125;; zone "netpas.co" in &#123; type master; file "zone.netpas.co.crc"; allow-update&#123;none;&#125;; &#125;;&#125;;view "edu" &#123; match-clients &#123; edu_ip;&#125;; zone "netpas.info" in &#123; type master; file "zone.netpas.info"; allow-update&#123;none;&#125;; &#125;; zone "netpas.co" in &#123; type master; file "zone.netpas.co.edu"; allow-update&#123;none;&#125;; &#125;;&#125;;view "other" &#123; match-clients &#123; other_ip;&#125;; zone "netpas.info" in &#123; type master; file "zone.netpas.info"; allow-update&#123;none;&#125;; &#125;; zone "netpas.co" in &#123; type master; file "zone.netpas.co.tel"; allow-update&#123;none;&#125;; &#125;;&#125;;view "default" &#123; match-clients &#123;any; 172.20.32.0/23; &#125;; zone "netpas.info" in &#123; type master; file "zone.netpas.info"; allow-update&#123;none;&#125;; &#125;; zone "netpas.co" in &#123; type master; file "zone.netpas.co"; allow-update&#123;none;&#125;; &#125;;&#125;;include "/var/named/acl/tel_ip";include "/var/named/acl/cnc_ip";include "/var/named/acl/cm_ip";include "/var/named/acl/crc_ip";include "/var/named/acl/edu_ip";include "/var/named/acl/other_ip"; 在/var/named下分别创建对应的区域文件(可拷贝),并将相关记录改成对应运营商的IP 123named-checkconf pkill -9 named/usr/sbin/named -u root -c /etc/named.conf 测试使用dig命令在不同环境下进行测试 日志 Loggingbind中我们可以通过配置logging来记录日志信息，以便以后对服务器的分析及问题的跟踪。logging语句为域名服务器设定了一个多样性的logging选项。它的channel短语对应于输出方式、格式选项和分类级别，它的名称可以与category短语一起定义多样的日志信息。如果打开日志功能可能会降低dns的性能，因此不建议开启日志功能。 开启日志功能只需要在option里面加入一个选项即可。man named.conf 12345options &#123; directory "/var/named"; querylog yes;&#125;; 之后查看/var/log/messages就能看到日志信息；这样会浪费大量的空间。可以使用catagory日志系统，帮我们定制需要对哪些行为进行日志检测。 日志的设置和定义 12345678910channel通道：作用主要定义日志输出的方式；在定义通道的语句里有哪些子语句： 通道的名称，即自定义通道的名称，即是什么类别。 输出方式和路径； 输出日志的轮转；即日志1，日志2，日志3...; 输出日志的大小限制； 输出到syslog 定义消息的级别：severity critical |err |warning |notice |info |debug |dynamic 定义类别的输出：print-category yes or no 定义等级的输出：print-severity yes or no 定义时间的输出：print-time yes or no 1234567891011category类别：定义了那些数据需要记录，即在日志里输出那些日志内容。哪一类的类别使用哪个或哪几个已经定义好的通道 类别的种类： default，没有配置的分类使用default的分类日志配置。 general，许多没有分类的内容都在此分类； database，named使用的，用来存储和缓存的内部数据库信息； security，接受和拒绝的请求 config配置文件分析和处理 resolver DNA解析； xfer-in：服务器收到的域传输； xfer-out：服务器发送的域传输。 queries 请求。 日志系统bind的日志系统，提供了两个子系统，一个叫做channel，一个叫做category。 123456789catagory: 日志源（指的是产生日志的日志源，比如说有的是跟查询有关的，有的是跟区域传送相关的。）所以catagory可以让我们定义日志来源。 查询 区域传送； 可以通过catagory自定义日志来源；一个catagory，可以存放到多个位置；一个channel只能存放一个catagory。channel: 定义日志的日志保存位置； syslog：系统日志；使用日志级别的概念。/var/log/messages. file: 自定义保存日志信息的文件。 默认channel下面是named 提前定义的四个通道，用于指定缺省的日志。 123456789101112131415channel "default_syslog" &#123; syslog daemon; # 发送给syslog 的daemon facility severity info; # 只发送此优先级和更高优先级的信息&#125;;channel "default_debug" &#123; file "named.run"; # 写入工作目录下的named.run 文件。注意：如果服务器用-f 参数启动，则"named.run"会被stderr 所替换。 severity dynamic; # 按照服务器当前的debug 级别记录日志&#125;;channel "default_stderr"&#123; stderr; # 写到stderr severity info; # 只发送此优先级和更高优先级的信息&#125;;channel "null" &#123; null; # 丢弃所有发到此通道的信息&#125;; default_debug 通道有特殊的性质：只有当服务器的debug级别非0的时候，它才产生输出。一般来说，它会在服务器的工作目录中写入named.run文件。因为安全原因，当在命令行选项中使用了“-u”参数后，只有当named使用了新的UID后，named.run文件才会产生，以root身份启动和运行的named所产生的debug信息将会被丢弃。如果用户需要得到这些输出，则必须使用“-g”参数运行服务器，并重新将标准错误定向到一个文件中去。一旦定义好一个通道，它就不能被重新定义。这样就不能修改内置的通道，但是可以通过把分类指向你已经定义的通道，来修改默认的日志记录。 示例 1234567891011logging &#123; file "log.msgs" version 3 size 10k; #一旦达到10k，就开始滚动，日志是可以滚动的； severity dynamic; #定义日志级别； &#125;; channel my_syslog &#123; syslog local0; #定义syslog里面local0的信息存放到哪里去； severity info; #定义local0里面的普通信息放到固定位置去。 &#125;; category xfer-in &#123; my_file; &#125;; #传入 #将传入日志保存到my_file里面去； category update &#123; my_syslog; &#125;; #更新信息 &#125;;]]></content>
      <categories>
        <category>Services</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenSSH]]></title>
    <url>%2F2016%2F02%2F04%2F2016-02-04-141338-OpenSSH%2F</url>
    <content type="text"><![CDATA[SSH SSH(Secure Shell Protocol)，由IETF网络工作小组（Network working Group）指定；在进行数据传输之前，SSH先对联机数据包通过加密技术进行加密处理，加密后在进行数据传输。确保了传递的数据安全。 SSH是专为远程登录会话和其他网络服务提供的安全性协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题，在当前的生产环境运维工作中，绝大多数企业普遍采用SSH协议服务来代替传统的不安全的远程联机服务软件，如telnet（23/tcp，非加密）。 默认状态下，SSH服务监听在应用层协议的TCP协议的22号端口，建立在应用层和传输层基础上。主要提供了两个服务功能，一个是提供类似Telnet远程联机服务器的服务，即SSH服务；另一个是类似FTP服务的sftp-server，借助SSH协议来传输数据，提供更安全的SFTP服务（vsftp，proftp）。 SSH版本目前有1.x和2.x，由于1.x的漏洞原因，目前使用安全协议SSH2。SSH客户端包含ssh远程连接命令，以及远程拷贝scp命令。 SSH服务是一个守护进程（daemon），他在后台运行并响应来自客户端的连接请求，SSH服务端的进程名为sshd，负责实时监听远程SSH客户端的连接请求，并进行处理，一般包括公共密钥认证、密钥交换、对称密钥加密和非安全连接等。 认证过程 基于口令 1、Server：将自己对应算法的公钥发送给Client2、Client：yes，接受Server的主机公钥，并生成一个一次性（临时）（IKE）对称密钥，将用户名使用临时的（IKE）对称密钥加密，然后用Server的公钥加密用户名和对称密钥发送给Server3、Server：解密数据，得到临时密钥和用户名，解密用户名，使用算法和解密的验证码比对，确定有此用户，则要求Client发送密码4、Client使用单向加密加密密码发送给Server 基于密钥一台主机为客户端（基于某个用户实现） 12345# 1、生成一对密钥ssh-keygen -t rsa -f a.key -N '' -C"root@zhangsan"# 2、将公钥传输至服务器端某用户的家目录下的.ssh/authorized_keys文件中ssh-copy-id -i /root/a.key.pub root@192.168.2.2# 3、测试登录 服务配置配置文件：/etc/ssh/sshd_config 123456789101112131415 # ssh连接端口默认为22，修改端口号可以提高安全性 Port 52113 # 禁止root远程登录PermitRootLogin no # 禁止空密码的用户登录PermitEmptyPasswords no # UseDNS 选项打开状态下，当客户端试图登录SSH服务器时，服务器端先根据客户端的IP地址进行DNS PTR反向查询出客户端的主机名# 然后根据查询出的客户端主机名进行DNS正向A记录查询，验证与其原始IP地址是否一致，这是防止客户端欺骗的一种措施，但一般我们的是动态IP不会有PTR记录，打开这个选项会导致登录过慢。UseDNS no # 是否允许使用基于 GSSAPI 的用户认证.默认值为"no".仅用于SSH-2.GSSAPIAuthentication no 常用命令 ssh：远程登录命令 -b 指定源地址，也可使用-oBindAddress= -p 指定端口号，也可使用-oPort= -v 显示详细信息 1234# 登录：ssh -l user host # 或 ssh user@host # 或ssh user@host 'command' ssh-keygen：密钥生成器 -f 指定密钥保存文件的路径 -N ‘’ 指定密码 -t rsa|dsa 加密类型 ssh-copy-id：将公钥传输至远程服务器 -i 指定公钥路径 scp：跨主机安全复制工具 -r 递归拷贝 -P 指定端口号 -p 在拷贝前后保持文件或目录属性 123# 拷贝scp USERNAME@HOST:/path/to/somefile /path/to/localscp /path/to/local USERNAME@HOST:/path/to/somewhere sftp：ssh服务附带的sftp功能命令 sftp -oPort=52113 root@192.168.247.164 sftp&gt; cd /root sftp&gt; ? 参考链接：http://blog.chinaunix.net/uid-16728139-id-3265394.html]]></content>
      <categories>
        <category>Services</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>OpenSSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是数字签名？]]></title>
    <url>%2F2016%2F02%2F03%2F2016-02-03-150040-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[鲍勃有两把钥匙，一把是公钥，另一把是私钥。 鲍勃把公钥送给他的朋友：帕蒂、道格、苏珊，每人各自一把。 苏珊要给鲍勃写一封保密信。她写完后用鲍勃的公钥加密，就可以达到保密的效果。 鲍勃收信后，用私钥解密，就看到了信件内容。这里要强调的是，只要鲍勃的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。 鲍勃给苏珊回信，决定采用”数字签名”。他写完后先用Hash函数，生成信件的摘要（digest）。 然后鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。 鲍勃将这个签名，附在信件下面，一起发给苏珊。 苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。 苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。 复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。此时，苏珊实际拥有的是道格的公钥，但是还以为这是鲍勃的公钥。因此，道格就可以冒充鲍勃，用自己的私钥做成”数字签名”，写信给苏珊，让苏珊用假的鲍勃公钥进行解密。 后来，苏珊感觉不对劲，发现自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate）。 鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。 苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。 参考文献：http://www.youdzone.com/signature.htmlhttp://www.2cto.com/Article/201308/232594.html]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[私有CA及https]]></title>
    <url>%2F2016%2F02%2F02%2F2016-02-02-151925-%E7%A7%81%E6%9C%89CA%E5%8F%8Ahttps%2F</url>
    <content type="text"><![CDATA[说明 x509.3证书格式 证书格式的版本号 证书序列号 证书签名算法 证书颁发者 有效期 持有者的名称 持有者的公钥 CA的ID 持有者的ID 其他扩展信息 基本约束 证书策略 密钥的使用限制 CA签名 SSL握手要完成的工作 交换协议版本号 选择一个双方都支持的加密方式 对两端实现身份验证 密钥交换 SSL会话基于IP地址进行：不支持在基于主机名的虚拟主机上实现 客户端验证服务器端证书 日期检查：证书是否在有效期内 证书颁发者的可信度 证书的签名检测 持有者的身份检测 配置私有CA服务器 修改ca默认项配置 1vim /etc/pki/tls/openssl.cnf 12345678910111213141516171819202122232425[ req_distinguished_name ]countryName = Country Name (2 letter code)countryName_default = CN # 默认国家设置为CNcountryName_min = 2countryName_max = 2stateOrProvinceName = State or Province Name (full name)#stateOrProvinceName_default = Default ProvincestateOrProvinceName_default = BEIJING # 默认省、州设置为BEIJINGlocalityName = Locality Name (eg, city)localityName_default = chaoyang # 默认城市设置为朝阳0.organizationName = Organization Name (eg, company)0.organizationName_default = Nettest # 默认公司名称organizationalUnitName = Organizational Unit Name (eg, section)organizationalUnitName_default = NetworkOpertion # 默认部门名称设为网络运维部#organizationalUnitName_default =commonName = Common Name (eg, your name or your server\'s hostname) # 申请证书的主服务器名称commonName_max = 64emailAddress = Email Address # 证书管理员邮箱地址 创建私有CA 12345678910111213cd /etc/pki/CA/(umask 077;openssl genrsa -out private/cakey.pem 2048)# 生成CA的私钥openssl req -new -x509 -key private/cakey.pem -out cacert.pem -days 3655# 创建CA自签署证书mkdir -pv /etc/pki/CA/&#123;certs,crl,newcerts&#125;# 创建所需目录touch index.txt serial# 创建所需文件echo 01 &gt; serial # 写入序列号 https的实现httpd基于mod_ssl模块实现对ssl的支持 安装httpd支持ssl模块 1yum -y install mod_ssl 创建目录存放密钥文件和证书请求文件、证书 1mkdir -pv /etc/httpd/conf/ssl 生成私钥 12cd /etc/httpd/conf/ssl(umask 077; openssl genrsa -out httpd.key 1024) web server 生成证书申请 123cd /etc/httpd/conf/sslopenssl req -new -key httpd.key -out httpd.csr # 生成一个证书颁发请求并填写相关信息 CA证书签署 1234openssl ca -in httpd.csr -out httpd.crt -days 3655# 将web服务器的申请证书发送给私有CA服务器# 私有CA服务器盖章，并发送给web服务器# 这里CA服务器和web服务器为同一台 修改httpd的ssl配置 1vim /etc/httpd/conf.d/ssl.conf 1234DocumentRoot "/var/www/html"ServerName www.test.com:443SSLCertificateFile /etc/httpd/conf/ssl/httpd.crtSSLCertificateKeyFile /etc/httpd/conf/ssl/httpd.key 12httpd -tservice httpd restart 导入CA证书测试 证书路径：/etc/pki/CA/cacert.pem windows测试拷贝证书至windows环境，后缀名改为crt导入即可 Linux测试openssl s_client -connet：验证的地址：端口 -CAfile:CA证书的路径openssl s_client -connect www.test.com:443 -CAfile /etc/pki/CA/cacert.pem]]></content>
      <categories>
        <category>Services</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenSSL]]></title>
    <url>%2F2016%2F02%2F01%2F2016-02-01-105633-OpenSSL%2F</url>
    <content type="text"><![CDATA[SSL简介Secure Sockets Layer 安全套接层，及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。 服务功能 认证用户和服务器，确保数据发送到正确的客户机和服务器； 保证数据的机密性，防止数据中途被窃取； 维护数据的完整性，确保数据在传输过程中不被篡改。 服务器类型 Tomcat 5.x Nginx IIS Apache 2.x IBM HTTP SERVER 6.0[1] 工作流程 服务器认证阶段 客户端向服务器发送一个开始信息“Hello”以便开始一个新的会话连接； 服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含生成主密钥所需的信息； 客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器 服务器回复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。 用户认证阶段 在此之前，服务器已经通过了客户认证 经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，从而向服务器提供认证。 SSL简介OpenSSL 是一个安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。他是SSL的开源实现。 库文件 libcrypto：通用加密库 libssl：TLS/SSL的实现，基于回话的实现了身份认证，数据机密性和回话完整性的库文件 命令和选项openssl是一个多功能命令行工具，可以实现私有证书颁发机构。 选项 12345-a # 对加密后的数据进行base64编码，或解密前先对数据进行base64解码-des3 # 加密算法，自己根据需要来指定-salt # 加盐，加盐后相同的明文可以得到不同的密文-in # 要读取的文件-out # 要输出的文件 命令 1234567891011121314151617181920openssl ? # 获得子命令openssl version # 获得版本号openssl speed # 测试所有算法在本机的加密速度openssl speed des # 测试des加密在本机的性能openssl enc -des3 -salt -a -in install.log -out install.des3# 使用des3加密文件openssl enc -des3 -salt -d -in a.des3 -out a.t# 使用des3解密文件openssl dgst -sha1 a.t# 计算文件的校验码md5sum a.t # 计算文件的校验码sha1sum a.t # 计算文件的校验码openssl passwd -1 -salt QAZXsw2 # 为用户生成密码串openssl rand -base64 100# 生成随机字符openssl genrsa# 生成一个私钥，默认为512位openssl genrsa 2048# 生成一个2048位的私钥 工作流程 服务器认证阶段 客户端向服务器发送一个开始信息“Hello”以便开始一个新的会话连接； 服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含生成主密钥所需的信息； 客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器 服务器回复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。 用户认证阶段 在此之前，服务器已经通过了客户认证 经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，从而向服务器提供认证。]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密类型及算法]]></title>
    <url>%2F2016%2F01%2F31%2F2016-01-31-081037-%E5%8A%A0%E5%AF%86%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[TCP/IP 安全因素 数据机密性 保证数据密文传输，中间人不能破解数据真实内容。 常见的不机密通信：ftp、http、smtp、telnet。这些协议的通信过程中都是明文传输，无法保证数据的机密性。 数据完整性 数据是否被篡改：入侵者不能使用假数据代替合法数据，否则数据将丧失完整性。 身份验证 验证身份的真实性，防止非法者冒充。 加密技术及算法对称加密简介 加密（encryption）与解密（decryption）使用的是同样的密钥（secret key），密码学中叫对称加密算法。 保证数据的机密性。 解密方事先必须知道加密密钥，否则无法解密。 算法 常用的算法有：DES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK、AES等。 优势 算法公开、计算量小、加密速度快、加密效率高。 缺点 在数据传送前，发送方和接收方必须商定好密钥，然后使双方都能保存好密钥。 双方使用同样的密钥，安全性无法得到保证。若一方的密钥被泄露，那么加密信息就不安全。 每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一密钥，使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。 单向加密简介 不可逆加密，在加密过程中不使用密钥，明文由系统加密算法处理成密文，密文无法解密。 提取数据的指纹及特征码，用于校验，保证数据的完整性。 特征 输入一样，输出必然一样 雪崩效应：输入的一点改变，引起结果的巨大改变，常用于防暴力破解。 定长输出：无论输入的长度多长，输出的结果都一样长。 不可逆：无法根据特征码还原数据。 无法进行身份验证和保证数据的机密性。 算法 MD4 MD5 message-digest algorithm 5（信息-摘要算法，输出结果固定长度128bit SHA1：secure hash algorithm（安全散列算法）,输出结果固定长度160bit SHA192，SHA256，SHA384 CRC-32 不加密，只提供校验功能 实现过程 发送方为了防止明文数据Data被其他人篡改，对数据使用单向加密算法，计算得到特征码A。 发送方将数据Data和特征码A一起发送给接收方。 接收方收到数据Data和特征码A。对数据Data使用相同的单向加密算法，计算出一个特征码B。 如果特征码A和B相同，则说明数据是完整的；否则数据被篡改，丧失完整性。 遗留问题 如果发送方在传递数据Data给接收方的过程中时，遭到中间人攻击，导致数据都被中间人截获。 中间人冒充发送方，对数据Data也进行单向加密算法，计算出特征码C，再将Data和特征码C一起发送给接收方。 接收方收到数据后对其进行单向加密算法，计算出的特征码和C一样。虽然特征码是相同的，但这并不是真实的发送方发来的数据。 接收方最终无法判断数据的来源，陷入身份验证的困境，因此引入了密钥交换。 密钥交换 互联网密钥交换：Internet Key Exchange，简称IKE 基于Diffie-Hellman协议协商生成密码。 实现双方使眼色交换密钥，而且密钥本身不在互联网上传播 IKE大致原理 主机A和B协商选择两个数字：P，g（大素数，生成器数） A在本机随机选择一个数字x，B在本机随机选择一个数字y。x只有A知道，y只有B知道，且x和y不在互联网传输 A将g^x%P计算结果Ra发送给B B将g^y%P计算结果Rb发送给A 互联网中的用户能看到的数字有四个：P，g，Ra，Rb 由于离散对数的原理，根据暴露的4个数字几乎不可能推算出x和y的值 A主机对Rb取x次方：(g^y%P)^x=g^yx%P B主机对Ra取y次方：(g^x%P)^y=g^xy%P 二者结果相同进而生成密钥，密钥交换问题解决。 陷入困境 A和B已经事先约定好数字后传输不需再次事先商定数字P和g，每次发送数据只需都进行一次计算，进行一次密钥交换即可。因此保证了身份验证。 但是，如果A和B从未见过面，第一次进行传输时，在商定数字的过程中遭到中间人攻击，则来源身份就可能被冒充，B又再次陷入身份验证的僵局。 要完成用户的身份验证，就需要使用非对称加密。 非对称加密简介 非对称加密也叫公钥加密。 公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密；如果用私钥对数据进行加密，那么只有用对应的公钥才能解密。因为加密和解密使用的是两个不同的密钥，所以叫作非对称加密。 密钥对 公钥：public key，从私钥中抽出的一段特征，只能用与之对应的私钥解密。 私钥：private key，只能用与之对应的公钥解密。 A用B的公钥加密数据，传输后的数据只有B用自己的私钥才能解开，以此保证了数据的机密性 A用自己的私钥加密数据，私钥只有A知道，只要B用A的公钥能解密数据就说明是数据A加密的，以此保证了身份验证 密钥对原则 一个公钥对应一个私钥。 让大家都知道的是公钥，不告诉大家只有自己知道的是私钥。 如果用其中一个密钥加密数据，则只有对应的那个密钥才可以解密。 如果用其中一个密钥可以进行解密数据，则该数据必然是对应的那个密钥进行的加密。 非对称密钥的主要应用就是公钥加密和公钥认证，而公钥加密的过程和公钥认证的过程是不一样的。 工作原理 A和B通信，双方事先产生一对用于自己加密和解密的公钥和私钥。 A的私钥保密，公钥公开；B的私钥保密，公钥发送给A。 A给B发送数据 为了保证数据完整性，使用单向加密算法计算出数据的特征码。将特征码附着在数据后发送给B。 中间人C获取数据后，使用A的公钥解密得到了特征码。 对数据进行篡改后，使用单向加密算法算出来的特征码无法还原成A计算出的特征码。 为了保证身份验证，防止特征码被中间人冒充，A使用自己的私钥对特征码进行加密。 中间人C截获数据后(即便无任何修改)，使用自己的私钥对A计算的特征码加密，冒充A将截获的数据及自己私钥加密后的特征码发送给B。 B收到C（冒充A）发来的数据，此时仍然认为发送方是A。 B使用A的公钥却无法解密冒充者C私钥加密的特征码。 为了保证数据的机密性，A使用B的公钥对所有数据加密。 B收到数据后 使用自己的私钥解密所有数据。 使用A的公钥成功解密得到了特征码，则验证了A的身份。 只有A私钥加密的数据发过来才能用A的公钥解密。因为A的私钥只有A一个人有。 使用单向加密算法计算数据的特征码，与发送过来解密后的特征码作比较，如果相同则说明数据完好无损。 用自己的私钥解密A使用B的公钥加密后发送过来的数据。其他人都无法解密，因为只有B才有自己的私钥。保证了数据的机密性。 加密算法 RSA：可进行数据加密、解密、签名 1234567891011openssl genrsa -out private.key 1024# 生成一个私钥，密钥长度为1024bitopenssl rsa -in private.key -pubout -out pub.key# 通过密钥文件private.key 提取公钥 echo -n "123456" | openssl rsautl -encrypt -inkey pub.key -pubin &gt;encode.result# 使用公钥加密信息 cat encode.result | openssl rsautl -decrypt -inkey private.key # 使用私钥解密信息 DSA：只能用于数字签名及其认证 12345678910111213openssl dsaparam -out dsaparam.pem 1024openssl gendsa -out privkey.pem dsaparam.pem# 生成一个密钥(私钥)openssl dsa -in privkey.pem -out pubkey.pem -puboutrm -fr dsaparam.pem # 生成公钥 echo -n "123456" | openssl dgst -dss1 -sign privkey.pem &gt; sign.result# 使用私钥签名echo -n "123456" | openssl dgst -dss1 -verify pubkey.pem -signature sign.result# 使用公钥验证 在DSA数字签名和认证中，发送者使用自己的私钥对文件或消息进行签名，接受者收到消息后使用发送者的公钥来验证签名的真实性。 DSA算法和RSA不同之处在于它不能用作加密和解密，也不能进行密钥交换，只用于签名，因此速度比RSA要快很多。 特点 加密速度慢，比对称加密慢3个数量级1000倍（一个数量级：10倍） 一般不用于加密大量数据，主要用于实现用户认证和帐号信息加密。 公钥验证 非对称加密过程中，无法保证公钥的来源的可靠性，因此引入了第三方认证机构。 双方在通信时都出示证件，这个证件由某个权威机构发放，只要验证证件内的有效信息就可以验证对方的身份。 为了防止在发证的时候出现中间人现欺骗，一些操作系统在安装时就已经将一些权威的发证机构的证书放在系统里了。 数字证书认证 CA(Certficate Authority)，数字证书认证中心，是整个网上电子交易安全的关键环节。它主要负责产生、分配并管理所有参与网上交易的实体所需的身份认证数字证书。 PKI：Public Key Infrastructure（公钥基础设施）。CA证书颁发机构，双方在通信时都出示证件，这个证件由某个权威机构发放，只需要验证证件内的有效信息 为了验证公钥发送方的合法性，因此有了证书颁发机构（要自己事先为自己颁发一个证书） 证书的格式：X509，PKCS 证书吊销列表：CRL(Certificate Revocation List) 三重验证 假设A和B彼此间是可靠的彼此认证的通信。即A和B通过CA机构颁发的证书彼此认可对方的公钥。 A和B通信，双方事先产生一对用于自己加密和解密的公钥和私钥。 A给B发送数据 事先获取B的公钥。 A和B基于DH协议，互相协商后生成两个数字（P，g） 为了保证数据的完整性，使用单向加密算法得到数据的特征码。将特征码附着在数据后。 为了保证身份验证，防止特征码被中间人冒充，A使用自己的私钥对特征码进行加密。 为了保证数据的机密性，A在本机生成一段随机数字(x)当作解开所有数据的对称密码，对数据加密，这个密码发送前只有A知道。 A使用B的公钥将对称密码加密，将加密的数据、对称密码发送给B。 B收到数据后 使用自己的私钥解密数据，得到了A的对称密码和对称密码加密的数据。使用A的对称密码解密数据。保证了数据机密性。 中间人即便获得数据也无法解开对称密码，因为对称密码使用的是B的公钥加密，只有B的私钥才能解开。对称密码加密后的数据及特征码也无从得知。 使用A的公钥解密得到（A私钥加密的）特征码。解密成功，则A的身份得到验证。 使用单向加密算法计算数据的特征码与解密得到的特征码作比较，如果相同则说明数据完好无损。]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用whiptail创建交互式shell对话框]]></title>
    <url>%2F2016%2F01%2F15%2F2016-01-15-160358-%E4%BD%BF%E7%94%A8whiptail%E5%88%9B%E5%BB%BA%E4%BA%A4%E4%BA%92%E5%BC%8Fshell%E5%AF%B9%E8%AF%9D%E6%A1%86%2F</url>
    <content type="text"><![CDATA[在终端环境下安装新的软件时，经常会看到信息对话框弹出，需要你的输入。对话框的类型有密码箱，检查表，菜单，等等。他们可以引导你以一种直观的方式输入必要的信息，使用这样的用户友好的对话框的好处是显而易见的。如下图所示： 当你想要写一个交互式shell脚本时，你可以使用这样的对话框来接受用户的输入。whiptail可以在shell脚本中创建基于终端的对话框，消息框的过程，类似于Zenity或xdialog GUI脚本代码。预先安装在所有的Linux发布版本中。 相关链接: https://en.wikibooks.org/wiki/Bash_Shell_Scripting/Whiptail 创建消息框 语法 1whiptail --title "&lt;message box title&gt;" --msgbox "&lt;text to show&gt;" &lt;height&gt; &lt;width&gt; 实例 12#!/bin/bashwhiptail --title "Test Message Box" --msgbox "Create a message box with whiptail. Choose Ok to continue." 10 60 效果 创建yes/no对话框 语法 1whiptail --title "&lt;dialog box title&gt;" --yesno "&lt;text to show&gt;" &lt;height&gt; &lt;width&gt; 实例 12345if (whiptail --title "Test Yes/No Box" --yesno "Choose between Yes and No." 10 60) then echo "You chose Yes. Exit status was $?."else echo "You chose No. Exit status was $?."fi 效果 或者可以是“–yes-button” , “–no-button”选项。 123456#!/bin/bashif (whiptail --title "Test Yes/No Box" --yes-button "Skittles" --no-button "M&amp;M's" --yesno "Which do you like better?" 10 60) then echo "You chose Skittles Exit status was $?."else echo "You chose M&amp;M's. Exit status was $?."fi 创建一个表单输入框如果你想用户输入任意的文本，您可以使用一个输入框。 语法 1whiptail --title "&lt;input box title&gt;" --inputbox "&lt;text to show&gt;" &lt;height&gt; &lt;width&gt; &lt;default-text&gt; 实例 12345678#!/bin/bashPET=$(whiptail --title "Test Free-form Input Box" --inputbox "What is your pet's name?" 10 60 Wigglebutt 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3)exitstatus=$?if [ $exitstatus = 0 ]; then echo "Your pet name is:" $PETelse echo "You chose Cancel."fi 效果 创建一个密码框当用户需要输入敏感信息时密码框是有用的。 语法 1whiptail --title "&lt;password box title&gt;" --passwordbox "&lt;text to show&gt;" &lt;height&gt; &lt;width&gt; 实例 12345678#!/bin/bashPASSWORD=$(whiptail --title "Test Password Box" --passwordbox "Enter your password and choose Ok to continue." 10 60 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3)exitstatus=$?if [ $exitstatus = 0 ]; then echo "Your password is:" $PASSWORDelse echo "You chose Cancel."fi 效果 创建一个菜单栏当你想让用户选择一个任意数量的选择中，你可以使用菜单框。 语法 1whiptail --title "&lt;menu title&gt;" --menu "&lt;text to show&gt;" &lt;height&gt; &lt;width&gt; &lt;menu height&gt; [ &lt;tag&gt; &lt;item&gt; ] . . . 实例 123456789101112#!/bin/bashOPTION=$(whiptail --title "Test Menu Dialog" --menu "Choose your option" 15 60 4 \"1" "Grilled Spicy Sausage" \"2" "Grilled Halloumi Cheese" \"3" "Charcoaled Chicken Wings" \"4" "Fried Aubergine" 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3)exitstatus=$?if [ $exitstatus = 0 ]; then echo "Your chosen option:" $OPTIONelse echo "You chose Cancel."fi 效果 创建radiolist单选对话框 语法 1whiptail --title "&lt;radiolist title&gt;" --radiolist "&lt;text to show&gt;" &lt;height&gt; &lt;width&gt; &lt;list height&gt; [ &lt;tag&gt; &lt;item&gt; &lt;status&gt; ] . . . 实例 12345678910111213#!/bin/bashDISTROS=$(whiptail --title "Test Checklist Dialog" --radiolist \"What is the Linux distro of your choice?" 15 60 4 \"debian" "Venerable Debian" ON \"ubuntu" "Popular Ubuntu" OFF \"centos" "Stable CentOS" OFF \"mint" "Rising Star Mint" OFF 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3)exitstatus=$?if [ $exitstatus = 0 ]; then echo "The chosen distro is:" $DISTROSelse echo "You chose Cancel."fi 效果 创建一个表对话框当你想让用户选择一个列表中选择多个选项的清单对话框是有用的，radiolist对话框，只允许选择一个。 语法 1whiptail --title "&lt;checklist title&gt;" --checklist "&lt;text to show&gt;" &lt;height&gt; &lt;width&gt; &lt;list height&gt; [ &lt;tag&gt; &lt;item&gt; &lt;status&gt; ] . . . 实例 12345678910111213#!/bin/bashDISTROS=$(whiptail --title "Test Checklist Dialog" --checklist \"Choose preferred Linux distros" 15 60 4 \"debian" "Venerable Debian" ON \"ubuntu" "Popular Ubuntu" OFF \"centos" "Stable CentOS" ON \"mint" "Rising Star Mint" OFF 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3)exitstatus=$?if [ $exitstatus = 0 ]; then echo "Your favorite distros are:" $DISTROSelse echo "You chose Cancel."fi 效果 创建一个进度条进度条是一个用户友好的对话框。whiptail从标准输入读取一个百分数（0～100），显示一个表内相应的计数。 语法 1whiptail --gauge "&lt;test to show&gt;" &lt;height&gt; &lt;width&gt; &lt;inital percent&gt; 实例 1234567#!/bin/bash&#123; for ((i = 0 ; i &lt;= 100 ; i+=20)); do sleep 1 echo $i done&#125; | whiptail --gauge "Please wait while installing" 6 60 0 效果]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Bash</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iftop流量监控工具]]></title>
    <url>%2F2015%2F11%2F15%2F2015-11-15-210510-iftop%E6%B5%81%E9%87%8F%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[简介iftop是一款类似于top命令的实时流量监控工具，监控TCP/IP连接等，缺点就是无报表功能。可以用来监控网卡的实时流量（可以指定网段）、反向解析IP、显示端口信息等。必须以root身份才能运行。 安装方法 源码包编译安装 下载最新的源码包。建议使用网络yum源(最好是自带的) 准备编译所需的环境，make、gcc、autoconf等。安装libpcap和libcurses依赖包 123456789101112131415# CentOS上安装所需依赖包：yum -y install flex byacc libpcap ncurses ncurses-devel libpcap-devel# Debian上安装所需依赖包：# apt-get install flex byacc libpcap0.8 libncurses5# 下载源码包wget http://www.ex-parrot.com/~pdw/iftop/download/iftop-0.17.tar.gz# 解压tar zxvf iftop-0.17.tar.gz# 编译安装cd iftop-0.17./configure --prefix=/mysoft/iftop/make &amp;&amp; make install rpm包安装 1234567# CentOS系统：yum -y install flex byacc libpcap ncurses ncurses-develwget ftp://fr2.rpmfind.net/linux/dag/redhat/el5/en/i386/dag/RPMS/iftop-0.17-1.el5.rf.i386.rpmrpm -ivh iftop-0.17-1.el5.rf.i386.rpm# Debian系统：apt-get install iftop 界面说明 &lt;= 和 =&gt; 是流量的方向 TX：发送流量 RX：接收流量 TOTAL：总流量 Cumm：运行iftop到目前时间的总流量 peak：流量峰值 rates：分别表示过去 2s 10s 40s 的平均流量 参数说明-i 设定监测的网卡，如：# iftop -i eth1-B 以bytes为单位显示流量(默认是bits)-n 使host信息默认直接都显示IP，如：# iftop -n-N 使端口信息默认直接都显示端口号，如: # iftop -N-F 显示特定网段的进出流量，如# iftop -F 10.10.1.0/24或# iftop -F 10.10.1.0/255.255.255.0-h display this message，帮助，显示参数信息-p 使用这个参数后，中间的列表显示的本地主机信息，出现了本机以外的IP信息;-b 使流量图形条默认就显示;-f 过滤计算包;-P 使host信息及端口信息默认就都显示;-m 设置界面最上边的刻度的最大值，刻度分五个大段显示，例：# iftop -m 100M 操作命令进入iftop画面后的操作命令: 按h切换是否显示帮助; 按n切换显示本机的IP或主机名; 按s切换是否显示本机的host信息; 按d切换是否显示远端目标主机的host信息; 按t切换显示格式为2行/1行/只显示发送流量/只显示接收流量; 按N切换显示端口号或端口服务名称; 按S切换是否显示本机的端口信息; 按D切换是否显示远端目标主机的端口信息; 按p切换是否显示端口信息; 按P切换暂停/继续显示; 按b切换是否显示平均流量图形条; 按B切换计算2秒或10秒或40秒内的平均流量; 按T切换是否显示每个连接的总流量; 按l打开屏幕过滤功能，输入要过滤的字符，比如ip,按回车后，屏幕就只显示这个IP相关的流量信息; 按L切换显示画面上边的刻度;刻度不同，流量图形条会有变化; 按j或按k可以向上或向下滚动屏幕显示的连接记录; 按1或2或3可以根据右侧显示的三列流量数据进行排序; 按&lt;根据左边的本机名或IP排序; 按&gt;根据远端目标主机的主机名或IP排序; 按o切换是否固定只显示当前的连接; 按f可以编辑过滤代码 按!可以使用shell命令 按q退出监控。]]></content>
      <categories>
        <category>杂货铺</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux使用中文man帮助手册]]></title>
    <url>%2F2015%2F10%2F28%2F2015-10-28-083210-Linux%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87man%E5%B8%AE%E5%8A%A9%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[下载中文手册包man-pages下载链接：https://manpages-zh.googlecode.com/files/manpages-zh-1.5.1.tar.gzGithub：https://github.com/manpages-zh 配置安装1234567891011# 查看系统支持的字符集locale -a # 设置语言环境为中文 export LANG=zh_CN.utf8# 编译安装tar -zxvf manpages-zh-1.5.1.tar.gzcd manpages-zh-1.5.1./configure --disable-zhtwmake &amp;&amp; make install 测试12345678# 查看man中文手册是否加入到man路径里面man --path# 列出所有和passwd相关的帮助手册man 5 -a --path passwd# 查看man手册是否变成中文man find 参考链接：http://www.cnblogs.com/chengmo/archive/2010/10/27/1862553.html]]></content>
      <categories>
        <category>杂货铺</category>
      </categories>
      <tags>
        <tag>manual</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用lrzsz进行Windows与Linux间文件的上传/下载]]></title>
    <url>%2F2015%2F10%2F14%2F2015-10-14-160710-%E4%BD%BF%E7%94%A8lrzsz%E8%BF%9B%E8%A1%8CWindows%E4%B8%8ELinux%E9%97%B4%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8A%E4%BC%A0-%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[简述 lrzsz是一款在linux里可代替ftp上传和下载的程序 lrzsz是一个unix通信套件提供的X，Y，和ZModem文件传输协议 之前我们基本上都用的FTP或SFTP来进行Windows和Linux之间的文件传输，在Linux上安装lrzsz之后结合SecureCRT进行文件传输显得更为方便 安装 检查当前系统是否安装 1rpm -q lrzsz 使用yum安装lrzsz 1yum -y install lrzsz 使用 文件上传 1rz 文件下载 需要对SecureCRT进行Windows接受文件路径的设置 SecureCRT版本：Version 8.0.2 (x64 build 1118) Options ==&gt; Global Options ==&gt; General ==&gt; Default Session ==&gt; Edit Default Settings... ==&gt; Connection ==&gt; SSH2 ==&gt; SFTP Session ==&gt; Local directory 1sz /path/to/filename]]></content>
      <categories>
        <category>杂货铺</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux配置ADSL拨号上网]]></title>
    <url>%2F2015%2F10%2F03%2F2015-10-03-184310-Linux%E9%85%8D%E7%BD%AEADSL%E6%8B%A8%E5%8F%B7%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[安装1yum install rp-pppoe.x86_64 配置PPPOE客户端软件安装完软件包后，必须配置pppoe的配置文件/etc/ppp/pppoe.conf，从而让ADSL拨号时使用配置文件中的用户名、密码等参数。使用adsl-setup进行配置： 123456789101112131415161718/usr/sbin/adsl-setup&gt;&gt;&gt; Enter your PPPoE user name :# 输入ADSL帐号的用户名&gt;&gt;&gt; Enter the Ethernet interface connected to the ADSL modemFor Solaris, this is likely to be something like /dev/hme0.For Linux, it will be ethn, where ‘n’ is a number.(default eth0):# 输入 eth0 ，这是ADSL相连的网卡的名字。&gt;&gt;&gt; Enter the demand value (default no):# 输入 no&gt;&gt;&gt; Enter the DNS information here:# 输入 server，这表示使用ADSL拨号自动获得的DNS服务器IP地址&gt;&gt;&gt; Please enter your PPPoE password:# 输入ADSL帐号的密码&gt;&gt;&gt; Choose a type of firewall (0-2):# 输入 0 ，不使用防火墙&gt;&gt;&gt; Accept these settings and adjust configuration files (y/n)?# 如果输入的信息正确，输入 y ,完成配置，否则，输入 n 重新输入。 启动PPPOE客户端软件123456789101112/usr/sbin/adsl-start# 启动PPPOE客户端软件,进行连接# 如果成功，将出现Connected；如果不成功，请检查网线、ADSL MODEM等物理设备，并查看 /var/log/messages中的信息/usr/sbin/adsl-stop# 关闭和ISP的连接/usr/sbin/adsl-status# 查看当前连接的状态chkconfig --add adsl# 将在当前的运行级下加入ADSL的自启动脚本。 测试1234567ifconfig -a# 在输出中应该含有关于 ppp0 的一堆信息，其中还绑定了 IP 地址,说明已经从拨号中获得了IP地址。netstat -nr# 查看路由表信息，这时的默认路由应该是上面获得的IP地址。# 如果没有默认路由，我们可以手动增加：route add default gw 上面获得的IP地址 维护添加计划任务定时拨号 16 7 * * * root /usr/sbin/adsl-stop /etc/ppp/pppoe-eth1.conf;/usr/sbin/adsl-start /etc/ppp/pppoe-eth1.conf &gt; /dev/null 2&gt;&amp;1]]></content>
      <categories>
        <category>杂货铺</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过受限bash创建只读用户]]></title>
    <url>%2F2015%2F07%2F25%2F2015-07-25-232810-%E9%80%9A%E8%BF%87%E5%8F%97%E9%99%90bash%E5%88%9B%E5%BB%BA%E5%8F%AA%E8%AF%BB%E7%94%A8%E6%88%B7%2F</url>
    <content type="text"><![CDATA[受限bash bash本身也有一定的限制功能，就是通过其(受限shell) restricted shell 功能。 如果bash是以rbash为名启动，或者使用-r选项运行，它就称为受限shell。 受限bash所做的限制包括： 阻止用户改变目录和环境变量 重定向输出 使用绝对路径运行命令 使用exec命令和其它一些操作 限制的操作受限shell能够使系统环境更好控制。如果启动受限shell，以下操作将被禁止： 使用cd命令切换目录； 设置或者取消SHELL、PATH、ENV或者BASH_ENV环境变量; 以绝对路径运行命令(即命令名中不能包含目录分隔符“/”); 以绝对路径指定的文件名作为内置命令”.”的参数; 在启动时通过 shell 环境导入函数定义; 在启动时通过 shell 环境解析 SHELLOPTS 的值; 使用&gt;、&gt;|、&gt;&amp;、&amp;&gt;和&gt;&gt;等重定向操作重定向输出； 使用exec命令使其它的命令代替当前shell; 通过enable内置命令的 -f 和 -d 选项增加或删除内置命令; 执行内置命令command时加上 -p 选项; 通过 set +r 或 set +o restricted 关闭受限模式; 配置步骤123456789101112131415161718192021222324ln -sv /bin/bash /bin/rbash# 为限制用户创建rbashinstall -cdv /work/ # 创建主工作目录useradd -d /work/ -s /bin/rbash loveyou# 创建限制用户，指定家目录为/work，跳过skel文件复制，指定shell为/bin/rbashpasswd loveyou# 为限制用户创建密码mkdir -pv /work/subin# 为限制用户创建允许使用的命令目录test `/usr/bin/id -g` -eq 500 &amp;&amp; export PATH=/work/subin# 修改环境变量/etc/profile，判断组ID，使可用命令为家目录下的subin目录ln -sv /bin/su /work/subin/suln -sv /bin/cat /work/subin/cat# 创建允许使用的命令alias su='su -l'# 在/etc/profile前面定义别名]]></content>
      <categories>
        <category>shell基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echo输出带颜色的文本]]></title>
    <url>%2F2015%2F07%2F24%2F2015-07-24-085410-%E4%BD%BF%E7%94%A8echo%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BA%E5%B8%A6%E9%A2%9C%E8%89%B2%E7%9A%84%E6%96%87%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[Bash tips: Colors and formatting (ANSI/VT100 Control sequences) 说明echo命令改变样式，以输出不同颜色的文本，必须有 -e 选项(开启echo中的转义)。格式如下： 12echo -e "\033[字背景颜色；文字颜色m 字符串\033[0m" echo -e "\033[1;36;41m Something here \033[0m" \代表转义 033 代表键盘的Control键 1代表字体行为(高亮，闪烁，下划线等)； 36代表字体的颜色 41的位置代表背景色 注： 字背景颜色和文字颜色之间是英文的分号’;’ 文字颜色后面有个m 字符串前后可以没有空格，如果有的话，输出也是同样有空格 文字和背景颜色搭配字体颜色 30~37 12345678echo -e "\033[30m 黑色字 \033[0m"echo -e "\033[31m 红色字 \033[0m"echo -e "\033[32m 绿色字 \033[0m"echo -e "\033[33m 黄色字 \033[0m"echo -e "\033[34m 蓝色字 \033[0m"echo -e "\033[35m 紫色字 \033[0m"echo -e "\033[36m 天蓝字 \033[0m"echo -e "\033[37m 白色字 \033[0m" 字背景颜色范围 40~47 12345678echo -e "\033[40;37m 黑底白字 \033[0m" echo -e "\033[41;37m 红底白字 \033[0m" echo -e "\033[42;37m 绿底白字 \033[0m" echo -e "\033[43;37m 黄底白字 \033[0m" echo -e "\033[44;37m 蓝底白字 \033[0m" echo -e "\033[45;37m 紫底白字 \033[0m" echo -e "\033[46;37m 天蓝底白字 \033[0m" echo -e "\033[47;30m 白底黑字 \033[0m" 控制选项说明1234567891011121314151617181920\033[0m # 关闭所有属性 \033[1m # 设置高亮度 \033[4m # 下划线 \033[5m # 闪烁 \033[7m # 反显 \033[8m # 消隐 \033[30m — \33[37m # 设置前景色 \033[40m — \33[47m # 设置背景色 \033[60A # 光标上移60行 \033[60B # 光标下移60行 \033[60C # 光标右移60行 \033[60G # 光标右移60行\033[60D # 光标左移60行 \033[y;xH # 设置光标位置 \033[2J # 清屏 \033[K # 清除从光标到行尾的内容 \033[s # 保存光标位置 \033[u # 恢复光标位置 \033[?25l # 隐藏光标 \033[?25h # 显示光标 额外说明 前景颜色各数字是对应背景颜色减去10 结束非常规字符序列的”m”要紧跟前面的数字，不能有空格 命令也可以写成echo -e &quot;^[[44;37;5m ME \033[0m COOL&quot;，其中的”^[“需要先按Ctrl-V,然后再按ESC生成 使用建议 写脚本时可调用系统的定义:/etc/sysconfig/init 1234567891011121314151617# color =&gt; new RH6.0 bootup# verbose =&gt; old-style bootup# anything else =&gt; new style bootup without ANSI colors or positioningBOOTUP=color# column to start "[ OK ]" label in RES_COL=60# terminal sequence to move to that column. You could change this# to something like "tput hpa $&#123;RES_COL&#125;" if your terminal supports itMOVE_TO_COL="echo -en \\033[$&#123;RES_COL&#125;G"# terminal sequence to set color to a 'success' color (currently: green)SETCOLOR_SUCCESS="echo -en \\033[0;32m"# terminal sequence to set color to a 'failure' color (currently: red)SETCOLOR_FAILURE="echo -en \\033[0;31m"# terminal sequence to set color to a 'warning' color (currently: yellow)SETCOLOR_WARNING="echo -en \\033[0;33m"# terminal sequence to reset to the default color.SETCOLOR_NORMAL="echo -en \\033[0;39m" 参考/etc/init.d/functions中的echo_success等函数，写个适合自己的函数 123456789101112# Declare a default return valueRETVAL=0# Echo log message to screen log_msg() &#123; if test $&#123;RETVAL&#125; -eq 0;then echo -n "$@"; echo_success; echo else echo -n "$@"; echo_failure; echo fi&#125;]]></content>
      <categories>
        <category>Linux命令</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell相关的面试题]]></title>
    <url>%2F2015%2F07%2F22%2F2015-07-22-232310-shell%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[CentOS Linux系统默认的shell是（） 解答：bash查看方法： 12345&gt; [root@centos-7.3 ~]# echo $SHELL&gt; /bin/bash&gt; [root@centos-7.3 ~]# awk -F &apos;:&apos; &apos;/^root/&#123;print $NF&#125;&apos; /etc/passwd&gt; /bin/bash&gt; 已知如下命令及返回结果，请问echo $user的返回结果是（） 12345678&gt; [root@test ~]# cat test.sh &gt; #!/bin/bash&gt; user=`whoami`&gt; [root@test ~]# sh test.sh &gt; &gt; [root@test ~]# echo $user&gt; ？？？&gt;]]></content>
      <categories>
        <category>shell基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell的学习建议]]></title>
    <url>%2F2015%2F07%2F21%2F2015-07-21-224610-shell%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%BB%BA%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[在做Linux系统相关的运维工作中，经常会编写shell脚本来完成服务的一键配置，定时维护等任务。shell脚本严格意义上讲，并不是编程语言。很多人在写脚本的时候，想到哪里就写到哪里，多人协作的时候代码很难得到规范和统一。为了更高效地写shell脚本，结合自己的经验，查阅了一些资料，罗列了一些建议。 规范自己的代码风格根据自己的使用习惯，写脚本时遵循一致的代码风格。最简单的一个就是缩进如果习惯了是4个空格那就一直保持，最好不要是今天写的时候缩进是4个空格，明天写的时候成了两个空格或一个制表符。 开头的解释器 shebang 其实就是在很多脚本的第一行出现的以#!开头的注释，指明了当我们没有指定解释器的时候默认的解释器，一般是下面这样： 1#!/bin/bash 直接使用./a.sh 来执行这个脚本的时候，如果没有 shebang，那么它就会默认用 $SHELL 指定的解释器，否则就会用 shebang 指定的解释器 上面的写法可能不太具备适应性，一般我们会用下面的方式来指定，而且这也是比较推荐的使用方式 1#!/usr/bin/env bash 解释器分很多种，可以用下面的命令查看本机支持的解释器： 1234567[user1@test ~]$ cat /etc/shells /bin/sh/bin/bash/sbin/nologin/bin/tcsh/bin/csh/bin/ksh 内容做到注释 不管是其他开发语言也好，shell这种脚本语言也要，在写代码的过程中养成良好的注释习惯。没有注释的情况下，在三四个月之后你可能回头看自己的代码时不知道当初的自己是如何想的，以及不知道代码实现了什么功能；另一方面注释可以提高可读性，和别人协作的时候，别人看了也不至于头大。 注释一般包括以下几个方面： shebang 脚本的参数 脚本的用途 脚本的注意事项 脚本的写作时间，作者，版权等 各个函数前的说明注释 一些较复杂的单行命令注释 参数要规范当我们的脚本需要接受参数的时候，一定要先判断参数是否合乎规范，并给出合适的回显，方便使用者了解参数的使用。至少需要判断下参数的个数： 12345678910if test $# -le 1;then echo "Usage : $(basename $0) srcip &lt; destip | dest domainname &gt;" exit 0else echo "....." fi 环境变量的定义一般情况下我们会将一些重要的环境变量定义在开头，确保这些变量的存在。最典型的应用就是，当我们本地安装了很多 java 版本时，我们可能需要指定一个 java 来用。那么这时我们就会在脚本开头重新定义 JAVA_HOME 以及 PATH 变量来进行控制。 1234567# load profilesource /etc/profile# Set up a default search path.PATH="/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/sbin:/usr/local/bin:/root/bin"export PATH 缩进要规矩 正确的缩进是很重要的，尤其是在写函数的时候，否则我们在阅读的时候很容易把函数体跟直接执行的命令搞混。 对于 shell 脚本，因为很多需要缩进的地方 (比如 if，for 语句) 都不长，很多人因此都懒得去缩进，而且很多人不习惯用函数，导致缩进功能被弱化。 常见的缩进方法主要有”soft tab” 和”hard tab” 两种 soft tab：就是使用 n 个空格进行缩进 (n 通常是 2 或 4) hard tab： 指的就是制表符\t 根据自己的使用习惯选择适合自己的缩进方式，并一直保持下去 对于 if 和 for 语句之类的，我们最好不要把 then，do 这些关键字单独写一行，这样看上去比较丑。下面是示例 123for i in &#123;1..10&#125;;do echo $&#123;i&#125;done 12345678# Check networkdstname="mirrors.163.com"if (ping $&#123;dstname&#125; -c 3 -i 0.01 -w 2 -q 1&gt;/dev/null 2&gt;&amp;1)then echo "Network is OK "else echo "Network is unreachable " exit 2fi 脚本和变量命名要标准遵循合理的规范： 文件名规范：以. sh 结尾，方便识别 变量名规范： 最好见名知意 统一命名风格， 一般用小写字母加下划线（file_path），或使用驼峰语法（filePath） 编码要统一 在写脚本的时候尽量使用 UTF-8 编码，能够支持中文等一些奇奇怪怪的字符。虽然能写中文，但是在写注释以及打 log 的时候还是尽量英文，因为很多机器还是没有直接支持中文的，打出来可能会有乱码。 尤其需要注意一点，当我们是在 windows 下用 utf-8 编码来写 shell 脚本的时候，一定要注意这个 utf-8 是否是有 BOM 的。默认情况下 windows 判断 utf-8 格式是通过在文件开头加上三个 EF BB BF 字节来判断的，但是在 Linux 中默认是无 BOM 的。因此如果我们是在 windows 下写脚本的时候，一定要注意将编码改成 Utf-8 无 BOM，一般用 notepad++ 之类的编辑器都能改。否则，在 Linux 下运行的时候就会识别到开头的三个字符，从而报一些无法识别命令的错。 使用统一的执行方式执行shell脚本的方式大致有如下几种 1bash /tmp/test.sh 1/tmp/test.sh 1./test.sh 其中后面两种是需要脚本有执行权限的，这也是建议的执行方式。不加执行权限导致无法直接执行。 日志回显 日志的重要性不必多说，能够方便我们回头纠错，在大型的项目里是非常重要的。 如果这个脚本是供用户直接在命令行使用的，那么我们最好还要能够在执行时实时回显执行过程，方便用户掌控。 为了提高用户体验，我们可以在回显中添加一些特效，比如颜色、闪烁等 不在脚本中使用密码安全很重要，不要把密码硬编码在脚本里，尤其是当脚本托管在类似 Github 这类平台中时，明文密码就暴露在互联网中了。 代码太长要分行在源码包编译安装软件时，参数可能会很长，为了保证较好的阅读体验，我们可以用反斜杠来分行： 1234./configure \ –prefix=/usr \ –sbin-path=/usr/sbin/nginx \ –conf-path=/etc/nginx/nginx.conf \ 注意: 在\前要有个空格 编码的细节和规范使用新的语法这里的新语法不是指有多厉害，而是指我们可能更希望使用较新引入的一些语法，更多是偏向代码风格的，比如 尽量使用 func(){}来定义函数，而不是func{} 尽量使用[[]]来代替[] 尽量使用$()将命令的结果赋给变量，而不是反引号 在复杂的场景下尽量使用 printf代替 echo进行回显 事实上，这些新写法很多功能都比旧的写法要强大，用的时候就知道了。 让自己的代码更简短这里的简短不单单是指代码长度，而是用到的命令个数。这不仅牵涉到代码的可读性，而且也关乎代码的执行效率。 原则上应该做到： 能一条命令解决的问题绝不用两条命令解决 能直接读取文件就不要用管道 命令能少尽可能少，管道并不是越多越好 题外话：你用的管道太多会让别人感觉你很low 示例 12cat /etc/passwd | grep root grep root /etc/passw 其实代码简短在还能某种程度上能保证效率的提升，比如下面的例子： 12345#method1 find . -name '*.txt' |xargs sed -i s/233/666/g find . -name '*.txt' |xargs sed -i s/235/626/g find . -name '*.txt' |xargs sed -i s/333/616/g find . -name '*.txt' |xargs sed -i s/233/664/g 12#method1 find . -name '*.txt' |xargs sed -i "s/233/666/g;s/235/626/g;s/333/616/g;s/233/664/g" 这两种方法做的事情都一样，就是查找所有的. txt后缀的文件并做一系列替换。前者是多次执行find，后者是执行一次 find，但是增加了sed的模式串。第一种可读性更好一点，但是当替换的量变大的时候，第二种的速度就会比第一种快很多。这里效率提升的原因，就是第二种只要执行一次命令，而第一种要执行多次。 让自己的代码更有效率在使用命令的时候要了解命令的具体做法，尤其当数据处理量大的时候，要时刻考虑该命令是否会影响效率。比如下面的两个 sed 命令： 123456sed -n '1p' filesed -n '1p;1q' file# 他们的作用一样，都是获取文件的第一行# 但是第一条命令会读取整个文件，而第二条命令只读取第一行。# 当文件很大的时候，仅仅是这样一条命令不一样就会造成巨大的效率差异。 在敏感操作时变量引用要严谨对一个值为路径的变量进行删除、移动操作时，一定要先判断该变量是否为空 示例 123path=/server/backupfind $path -name "*.tar.gz" -type f | xargs rm -f # 一旦变量为空，则会删除当前目录 避免方法 删除操作之前，切换到一个临时目录 使用变量展开，若变量未定义或者为空则赋一个值给这个变量， 示例 1[ $RETVAL = 0 ] &amp;&amp; rm -f $&#123;pidfile:=/tmp/test&#125; /var/lock/subsys/$&#123;prog:=/tmp/test&#125; 勤用双引号 示例1 12345#!/bin/bash # 已知当前文件夹有一个a.sh的文件 var="*.sh" echo $var echo "$var" 运行结果如下： 12a.sh*.sh 这是因为shell对*进行了解释，变成了下面这样 12echo *.shecho "*.sh" 示例2 123#!/bin/basharg1=$1[ $&#123;arg1&#125; == "0" ] &amp;&amp; echo "0" || echo 1 直接执行bash test.sh，不加参数的情况下就会报错，因此需要使用双引号： 123#!/bin/basharg1=$1[ "$&#123;arg1&#125;" == "0" ] &amp;&amp; echo "0" || echo 1 在很多情况下，在将变量作为参数的时候，一定要注意双引号的使用，实际应用的时候由于这个细节导致的问题实在是太多了 使用main函数像 java，C 这样的编译型语言都会有一个函数入口，这种结构使得代码可读性很强，我们知道哪些直接执行，哪些是函数。但是脚本不一样，脚本属于解释性语言，从第一行直接执行到最后一行，如果在这当中命令与函数糅杂在一起，那就非常难读了。 用 python 的朋友都知道，一个合乎标准的 python 脚本大体上至少是这样的： 12345678#!/usr/bin/env python def func1(): pass def func2(): pass if __name__=='__main__': func1() func2() 他用一个很巧妙的方法实现了我们习惯的 main 函数，使得代码可读性更强 在 shell 中，我们也有类似的小技巧: 123456789101112#!/usr/bin/env bash func1()&#123; #do sth &#125; func2()&#123; #do sth &#125; main()&#123; func1 func2 &#125; main "$@" 我们可以采用这种写法，同样实现类似的 main 函数，使得脚本的结构化程度更好。 理清作用域shell 中默认的变量作用域都是全局的，比如下面的脚本： 1234567#!/usr/bin/env bash var=1func()&#123; var=2 &#125; func echo $var 他的输出结果就是 2 而不是 1，这样显然不符合我们的编码习惯，很容易造成一些问题。 因此，相比直接使用全局变量，我们最好使用 local readonly 这类的命令，其次我们可以使用 declare 来声明变量。这些方式都比使用全局方式定义要好。 下面是做了修整的示例 1234567#!/usr/bin/env bash var=1func()&#123; local var=2 &#125; func echo $var 注意事项 路径尽量保持绝对路径，绝多路径不容易出错，如果非要用相对路径，最好用./修饰 优先使用 bash 的变量替换代替 awk sed，这样更加简短，比如 123a=131341echo $&#123;a/3/h&#125;echo $&#123;a//3/h&#125; 简单的if尽量使用 &amp;&amp; ||，写成单行。比如 1[[x&gt; 2]] &amp;&amp; echo x 当 export 变量时，尽量加上子脚本的 namespace，保证变量不冲突 会使用 trap 捕获信号，并在接受到终止信号时执行一些收尾工作 使用 mktemp 生成临时文件或文件夹来避免和他人冲突 利用 / dev/null 结合输入输出重定向来过滤不友好的输出信息 利用命令的返回值判断命令的执行情况 使用文件前要判断文件是否存在，否则做好异常处理 不要处理 ls 后的数据 (比如ls -l | awk &#39;{ print $8}&#39;)，ls 的结果非常不确定，并且和平台有关 读取文件时不要使用 for loop 而要使用 while read]]></content>
      <categories>
        <category>shell基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell中脚本路径的获取]]></title>
    <url>%2F2015%2F07%2F20%2F2015-07-20-105410-shell%E4%B8%AD%E8%84%9A%E6%9C%AC%E8%B7%AF%E5%BE%84%E7%9A%84%E8%8E%B7%E5%8F%96%2F</url>
    <content type="text"><![CDATA[说明很多情况下，我们会先获取当前脚本的路径，然后一这个路径为基准，去找其他的路径。通常我们是直接用 pwd 以期获得脚本的路径。实际上这样是不严谨的，pwd 获得的是当前 shell 的执行路径，而不是当前脚本的执行路径。 示例12script_dir=$(cd $(dirname $0) &amp;&amp; pwd)script_dir=$(dirname $(readlink -f $0 ))]]></content>
      <categories>
        <category>shell基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell使用mktemp命令创建临时文件]]></title>
    <url>%2F2015%2F07%2F19%2F2015-07-19-183610-shell%E4%BD%BF%E7%94%A8mktemp%E5%91%BD%E4%BB%A4%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在生产环境中，很多情况下在脚本中会使用一些临时的普通文件，比如1.txt，test.txt。为了简单，可能A员工在维护时脚本中使用了一个1.txt，B员工在维护的时候也使用了1.txt，这时候就造成了文件使用上的冲突。为了尽可能的避免这类情况的发生，我们就可以使用mktemp命令创建属于自己的临时文件。 说明mktemp 创建一个临时文件或目录 用法1mktemp [OPTION]... [TEMPLATE] 其中TEMPLATE必须以一个或多个X结尾，例如 1mktemp test.XXX 选项 -q：静默模式，执行时若发生错误，不会显示任何信息 -d：创建一个临时目录 -u ：暂存文件会在mktemp结束前先行删除 示例脚本中用到的临时文件我们可以使用命令替换的方式，将临时文件名赋值给变量，在操作完成后删除这个变量即可 12345#!/bin/bashFILE=`mktemp /tmp/ipinfo.XXXX`ip addr show | awk -F '[ /]+' '$2~/eth/&#123;$3~/NO-CARRIER/?a=0:a=1&#125;$NF~/eth/&amp;&amp;a&#123;print $NF,$3&#125;' | sort -o $&#123;FILE&#125;ls $&#123;FILE&#125;cat $&#123;FILE&#125;]]></content>
      <categories>
        <category>shell基础</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell的进程替换]]></title>
    <url>%2F2015%2F07%2F18%2F2015-07-18-170710-shell%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[进程替换 进程替换与命令替换很相似，命令替换把一个命令的结果赋给一个变量，例如 dir_contents=`ls -al` 或 xref=$. 进程替换则是把一个进程的输出回馈给另一个进程 (换句话说，它把一个命令的结果发送给另一个命令)。 命令替换的形式：是由圆括号括起的命令 12&gt;(command)&lt;(command) 启动进程替换：它是用/dev/fd/&lt;n&gt; 文件把在圆括号内的进程的处理结果发送给另外一个进程，在&lt; 或or &gt; 与圆括号之间是没有空格的. 如果加了空格将会引起错误信息。Bash在两个文件描述符（file descriptors）之间创建了一个管道， --fIn 和 fOut--。true命令的标准输入被连接到fOut(dup2(fOut, 0))， 然后Bash把/dev/fd/fIn作为参数传给 echo。如果系统的 /dev/fd/&lt;n&gt; 文件不够时，Bash会使用临时文件。 示例 12cat &lt;(ls -l)# 等同于 ls -l | cat 123sort -k 9 &lt;(ls -l /bin) &lt;(ls -l /usr/bin) &lt;(ls -l /usr/X11R6/bin)# 列出系统中3个主要的'bin'目录的所有文件，并且按文件名排序.# 注意是三个明显不同的命令输出回馈给'sort'. 12diff &lt;(command1) &lt;(command2)# 给出两个命令输出的不同之处. 1234567891011121314tar cf &gt;(bzip2 -c &gt; file.tar.bz2) $directory_name# 调用"tar cf /dev/fd/?? $directory_name",和"bzip2 -c &gt; file.tar.bz2".## 因为/dev/fd/&lt;n&gt;的系统属性,# 所以两个命令之间的管道不必是命名的.## 这种效果可以模仿出来.bzip2 -c &lt; pipe &gt; file.tar.bz2&amp;tar cf pipe $directory_namerm pipe# 或者exec 3&gt;&amp;1tar cf /dev/fd/4 $directory_name 4&gt;&amp;1 &gt;&amp;3 3&gt;&amp;- | bzip2 -c &gt; file.tar.bz2 3&gt;&amp;-exec 3&gt;&amp;-]]></content>
      <categories>
        <category>shell基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell中使用read命令接收键盘输入]]></title>
    <url>%2F2015%2F07%2F17%2F2015-07-17-091310-shell%E4%B8%AD%E4%BD%BF%E7%94%A8read%E5%91%BD%E4%BB%A4%E6%8E%A5%E6%94%B6%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%2F</url>
    <content type="text"><![CDATA[read命令read 命令从标准输入中读取一行，并把输入行的每个字段的值指定给 shell 变量 用法123read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]# 或read [ -p ][ -r ][ -s ][ -u[ n ] ] [ VariableName?Prompt ][ VariableName ... ] 参数123456789-a 后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符。-d 后面跟一个标志符，其实只有其后的第一个字符有用，作为结束的标志。-p 后面跟提示信息，即在输入前打印提示信息。-e 在输入的时候可以时候命令补全功能。-n 后跟一个数字，定义输入文本的长度。-r 屏蔽，如果没有该选项，则作为一个转义字符，有的话就是个正常的字符。-s 安静模式，在输入字符时不再屏幕上显示，例如login时输入密码。-t 后面跟秒数，定义输入字符的等待时间。-u 后面跟fd，从文件描述符中读入，该文件描述符可以是exec新开启的。 示例1234567891011121314#!/bin/bash read -t 30 -p "Please input your name: " name # 提示“请输入姓名”并等待30秒，把用户的输入保存入变量name中 echo "Name is $name" read -s -t 30 -p "Please enter your age: " age # 年龄是隐私，所以我们用“-s”选项隐藏输入 echo -e "\n" echo "Age is $age" read -n 1 -t 30 -p "Please select your gender[M/F]: " gender # 使用“-n 1”选项只接收一个输入字符就会执行（都不用输入回车） echo -e "\n" echo "Sex is $gender"]]></content>
      <categories>
        <category>shell基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell的语法调试]]></title>
    <url>%2F2015%2F07%2F16%2F2015-07-16-212110-shell%E7%9A%84%E8%AF%AD%E6%B3%95%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[使用bash选项12345678# 检查脚本语法格式是否有错bash -n script.sh# 跟踪脚本中每个命令的执行bash -v script.sh# 脚本单步执行，将整个脚本每一步解释和执行过程显示出来bash -x script.sh 使用set命令1234set -x # 在执行时候显示参数和命令。set +x # 禁止调式。set -v # 当命令进入读取时候显示输入。set +v # 禁止打印输入 仅在 -x 和 +x 区域显示调试信息 123456#!/bin/bashfor i in &#123;1..5&#125; ; do set -x echo $i set +xdone 使用_DEBUG环境变量 若需要自定义格式显示调式信息可通过_DEBUG环境变量来建立： 1234567#!/bin/bashDEBUG () &#123;[ "$_DEBUG" = "on" ] &amp;&amp; $@ || :&#125;for i in &#123;1..5&#125; ; do DEBUG echo $idone 将调试功能设置为“on”来运行脚本： 1_DEBUG=on ./script.sh 将需要调式的行前加上DEBUG，运行脚本前没有加_DEBUG=on就不会显示任何信息，脚本中:告诉shell不进行任何操作。 使用shellbang把shebang 从 #!/bin/bash 修改成 #!/bin/bash -xv 即可 静态检查工具 shellcheck为了从制度上保证脚本的质量，我们最简单的想法大概就是搞一个静态检查工具，通过引入工具来弥补开发者可能存在的知识盲点。 概述shellcheck这个工具的对不同平台的支持力度都很大，他至少支持了Debian，Arch，Gentoo，EPEL，Fedora，OS X,，openSUSE 等等各种的平台的主流包管理工具。 安装Github：https://github.com/koalaman/shellcheck 12yum -y install epel-releaseyum install ShellCheck 本质shellcheck提供了一个非常非常强大的wiki。在这个 wiki 里，我们可以找到这个工具所有判断的依据，每一个检测到的问题都可以在 wiki 里找到对应的问题单号，他不仅告诉我们” 这样写不好”，而且告诉我们” 为什么这样写不好”，” 我们应当怎么写才好”，非常适合刨根问底党进一步研究。]]></content>
      <categories>
        <category>shell基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell中信号捕捉]]></title>
    <url>%2F2015%2F07%2F15%2F2015-07-15-192410-shell%E4%B8%AD%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%2F</url>
    <content type="text"><![CDATA[信号捕捉 信号是一种进程间通信机制，它给应用程序提供一种异步的软件中断，使应用程序有机会接受其他程序活终端发送的命令(即信号)。 应用程序收到信号后，有三种处理方式：忽略，默认，捕捉。进程收到一个信号后，会检查对该信号的处理机制。如果是SIG_IGN，就忽略该信号；如果是SIG_DFT，则会采用系统默认的处理动作，通常是终止进程或忽略该信号；如果给该信号指定了一个处理函数(捕捉)，则会中断当前进程正在执行的任务，转而去执行该信号的处理函数，返回后再继续执行被中断的任务。 常见信号 kill -l 和trap -l可列出系统的信号 stty -a 可列出中断信号与键盘的对应 信号及描述列表 信号 Num 描述 SIGHUP 1 在用户终端连接(正常或非正常)结束时发出, 通常是在终端的控制进程结束时, 通知同一session内的各个作业, 这时它们与控制终端不再关联。 登录Linux时，系统会分配给登录用户一个终端(Session)。在这个终端运行的所有程序，包括前台进程组和后台进程组，一般都属于这个Session。当用户退出Linux登录时，前台进程组和后台有对终端输出的进程将会收到SIGHUP信号。这个信号的默认操作为终止进程，因此前台进程组和后台有终端输出的进程就会中止。对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。 SIGINT 2 程序终止(interrupt)信号, 在用户键入INTR字符(通常是Ctrl C)时发出。 SIGQUIT 3 和SIGINT类似, 但由QUIT字符(通常是Ctrl /)来控制. 进程在因收到SIGQUIT退出时会产生core文件, 在此意义上类似于一个程序错误信号。 SIGFPE 8 在发生致命的算术运算错误时发出. 不仅包括浮点运算错误, 还包括溢出及除数为0等其它所有的算术的错误。 SIGKILL 9 用来立即结束程序的运行. 本信号不能被阻塞, 处理和忽略。 SIGALRM 14 时钟定时信号, 计算的是实际时间或时钟时间. alarm函数使用该信号。 SIGTERM 15 程序结束(terminate)信号, 与SIGKILL不同的是该信号可以被阻塞和处理. 通常用来要求程序自己正常退出. shell命令kill缺省产生这个信号。 捕捉信号 在终端一个shell程序的执行过程中，按下Ctrl + C键或Break键正常程序将立即终止，并返回命令提示符。可能并不总是可取的。比如有可能最终产生临时文件，不会被清理。 Ctrl + C —&gt; SIGINIT(2) Ctrl+ Z —&gt; SIGCONT(18) 捕捉信号并执行引号中的命令串或函数： 12trap 'commands或functions' signal-listtrap "commands或functions" signal-list 恢复信号的默认操作 12trap signal-listtrap : signal-list 忽略信号 1trap " " signal-list 注意事项 对信号SIGSEGV(11)不能捕捉，因为shell本身需要捕捉（该信号去进行内存的转储） 在脚本中可以捕捉信号,但无法捕捉KILL(9)和TERM(15) 在trap中可以定义对信号0的处理(实际上没有此信号)，shell程序在其终止(如执行exit语句)时发出该信号 在捕捉到signal-list中指定的信号并执行完相应的命令之后， 如果这些命令没有将shell程序终止的话，shell程序将继续执行收到信号时所执行的命令后面的命令，这样将很容易导致shell程序无法终止。 通常需要忽略的四个信号HUP(1), INT(2), QUIT(3), TSTP(24) 123trap "" 1 2 3 24 # 或 trap "" HUP INT QUIT TSTP 使其恢复默认值 123trap ：1 2 3 24 # 或trap HUP INT QUIT TSTP]]></content>
      <categories>
        <category>shell基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell的数组]]></title>
    <url>%2F2015%2F07%2F15%2F2015-07-14-245610-shell%E7%9A%84%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[什么是数组 存储多个元素的连续的内存空间。数组只有一个名字，索引号从0开始。 关联数组的索引号可以自定义，bash4及以后版本支持关联数组。 bash支持一维数组（不支持多维数组），并且没有限定数组的大小。 获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于0。 如何定义一个数组用括号表示数组，数组元素用“空格”符号分割开 示例 123456# 定义一个索引数组declare -a array_namearray_name=(value1 value2 ... valuen)# 定义一个关联数组declare -A array_nam array_name=([index_name1]=”val1” [index_name2]=”val2”) 元素赋值 单个元素赋值，直接通过 数组名[下标] 就可以对其进行引用赋值，如果下标不存在，自动添加新一个数组元素 123array_name[0]=value0array_name[1]=value1array_name[2]=value2 全部元素赋值 1NAME=(“VAL1”,”VAL2”,”VAL3”,…) 特定元素赋值 1NAME=([0]=”val1” [3]=”val3”,….) 使用命令替换赋值 1NAME=$(seq 10) 交互式赋值，直接在提示符中写，写后回车即可 1234read -a array_nameval1 val2 val3…..同read -a array_name &lt;&lt;&lt; 'val1 val2 val3…..' 关联数组赋值，直接给定下标名 123declare -A worldworld[us]="america"world[uk]="United kingdom" 追加元素并赋值 1array_name[$&#123;array_name[*]&#125;]= 元素值引用 引用时只给数组名，表示引用为下标为0的元素 123$&#123;array_name&#125;$&#123;array_name[index]&#125;valuen=$&#123;array_name[2]&#125; 使用@ 或 * 可以获取数组中的所有元素 12$&#123;array_name[*]&#125;$&#123;array_name[@]&#125; 数组长度引用 取得数组元素的个数 123length=$&#123;#array_name[@]&#125;# 或者length=$&#123;#array_name[*]&#125; 取得数组第一个元素的长度 1lengthn=$&#123;#array_name&#125; 取得数组单个元素的长度 1lengthn=$&#123;#array_name[n]&#125; 元素值提取12345a=(net.nf_conntrack_max=====131072 net.ipv4.ip_forward===1 c====5)$&#123;a[1]#*=&#125; # 删掉数组a中第2个元素中第一个=及其左边的字符串$&#123;a[1]##*=&#125; # 删掉数组a中第2个元素中最后一个=及其左边的字符串$&#123;a[1]%=*&#125; # 删掉数组a中第2个元素中最后一个=及其右边的字符串$&#123;a[1]%%=*&#125; # 删掉数组a中第2个元素中第一个=及其右边的字符串 获取元素下标1234567891011[root@CentOS6_8 ~]$ array=(a b c d e f g) [root@CentOS6_8 ~]$ echo $&#123;array[0]&#125; a# 数组的第一个元素[root@CentOS6_8 ~]$ echo $&#123;!array[@]&#125;0 1 2 3 4 5 6# 数组所有的下标for i in $&#123;!Array[@]&#125;;do echo $&#123;Array[i]&#125; ;done# 在数组里的所有元素 示例：设置内核参数 123456789101112131415161718192021222324252627#!/bin/basharr_kernel_arg=(net.ipv4.ip_forward=1 net.ipv4.route.max_size=131072 net.nf_conntrack_max=131072 net.netfilter.nf_conntrack_tcp_timeout_established=1800 net.netfilter.nf_conntrack_tcp_timeout_time_wait=30 net.netfilter.nf_conntrack_tcp_timeout_syn_sent=40 net.ipv4.conf.default.rp_filter=0 net.ipv4.conf.all.rp_filter=0 net.ipv4.conf.default.accept_source_route=0 net.ipv4.conf.all.arp_ignore=1 net.ipv4.conf.all.arp_announce=2)cfg_kernel=/etc/sysctl.conffor i in $&#123;!arr_kernel_arg[@]&#125;;do if /bin/egrep -q $&#123;arr_kernel_arg[$i]%%=*&#125; $cfg_kernel;then /bin/sed -ri "s/(^$&#123;arr_kernel_arg[$i]%%=*&#125; = ).*/\1$&#123;arr_kernel_arg[$i]##*=&#125;/" $cfg_kernel else if [ $i -eq 0 ] ;then line_n=`/bin/gawk '/forwarding/&#123;print NR&#125;' $cfg_kernel` else line_n=`/bin/gawk '/'"$&#123;arr_kernel_arg[$((i-1))]%%=*&#125;"'/&#123;print NR&#125;' $cfg_kernel` fi /bin/sed -ri "$&#123;line_n&#125;a$&#123;arr_kernel_arg[$i]%%=*&#125; = $&#123;arr_kernel_arg[$i]##*=&#125;" $cfg_kernel fidoneunset i line_n cfg_kernel arr_kernel_arg# 删除元素直接通过：unset 数组[下标] 可以清除相应的元素；不带下标，清除整个数据。 元素切片 格式 123$&#123;array_name[@]:offset:number&#125;offset # 要跳过元素的个数number # 要取出元素的个数，省略number时，表示取偏移量之后的所有元素 切片原先的数组后返回是字符串，中间用空格分开，因此如果切片后的结果加上()，将得到切片数组 示例 12345678910[root@CentOS6_8 ~]$ a=(1 2 3 4 5)[root@CentOS6_8 ~]$ echo $&#123;a[@]:0:3&#125;1 2 3[root@CentOS6_8 ~]$ echo $&#123;a[@]:1:4&#125;2 3 4 5[root@CentOS6_8 ~]$ c=($&#123;a[@]:1:4&#125;)[root@CentOS6_8 ~]$ echo $&#123;#c[@]&#125;4[root@CentOS6_8 ~]$ echo $&#123;c[*]&#125; 2 3 4 5 元素值替换 格式 123$&#123;array_name[@或*]/searchstr/replacestr&#125;searchstr # 要查找的字符串replacestr # 要替换成的字符串 该操作不会改变原先数组内容，如果需要修改，需要重新定义数据。 示例 1234567891011[root@CentOS6_8 ~]$ a=(1 2 3 4 5)[root@CentOS6_8 ~]$ echo $&#123;a[@]/3/100&#125;1 2 100 4 5[root@CentOS6_8 ~]$ echo $&#123;a[@]&#125;1 2 3 4 5[root@CentOS6_8 ~]$ a=($&#123;a[@]/3/100&#125;)[root@CentOS6_8 ~]$ echo $&#123;a[@]&#125;1 2 100 4 5[root@CentOS6_8 ~]$ A=(100 101 102 103 104);B=".txt"[root@CentOS6_8 ~]$ echo $&#123;A[@]/%/$B&#125;100.txt 101.txt 102.txt 103.txt 104.txt]]></content>
      <categories>
        <category>shell基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell的函数]]></title>
    <url>%2F2015%2F07%2F14%2F2015-07-13-243310-shell%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数 函数可将一个复杂功能划分成若干模块，让程序结构更加清晰，代码重复利用率更高。 Shell必须先定义后使用而且不能独立运行，需要调用执行。 函数可出现在任何位置，在代码执行时，都会被自动替换为函数代码。其函数命名不应该为命令名。 函数的定义方式 方法一 1234function function_name &#123; list of commands [ return value ]&#125; 方法二 1234function_name () &#123; list of commands [ return value ]&#125; 函数的生命周期每次被调用时创建，返回时终止 函数的返回值 函数返回值，可以使用return语句；如果不加，则将最后一条命令运行结果作为返回值。 Shell 函数返回值只能是整数，一般用来表示函数执行成功与否，0表示成功，其他值表示失败。 如果 return 其他数据，比如一个字符串，往往会得到错误提示：“numeric argument required” 函数中参数的传递在函数体中当中，可以使用$1，$2，....$n、$@、$#、$*等引用传递给函数的位置变量；在调用函数时，在函数名后面以空白符分隔给定参数列表即可，例如: 1testfunc arg1 arg2 arg3 函数中变量及作用域局部变量12local VARIABLE=VALUE# 作用域是当前函数，在函数结束时被自动销毁 本地变量12 VARNAME=VALUE# 作用域当前shell进程 递归函数能够调用自身的函数成为递归函数。经典的fork炸弹 1.()&#123;.|.&amp;&#125;;. 12345678910. () # 定义一个名叫 . 的函数，无可选参数&#123;#函数体开始.|.&amp;# 递归调用函数本身，然后利用管道再次调函数本身并将其放到后台执行&#125;;# 函数体结束.# 调用函数]]></content>
      <categories>
        <category>shell基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell的状态返回值]]></title>
    <url>%2F2015%2F07%2F12%2F2015-07-12-095710-shell%E7%9A%84%E7%8A%B6%E6%80%81%E8%BF%94%E5%9B%9E%E5%80%BC%2F</url>
    <content type="text"><![CDATA[在shell中，每个命令都会返回一个状态返回值。成功的命令返回0，而不成功的命令返回非零值。非零值通常都被解释成一个错误码。 脚本中的函数和脚本本身也会返回状态返回值。在脚本或者是脚本函数中执行的最后的命令会决定退出状态码。 在脚本中，exit n 命令将会把 n 退出状态码传递给父 shell并结束整个脚本（n必须是十进制数, 范围是0 - 255) 以下是常见的状态码及意义 0 运行成功 2 权限拒绝 1~125 表示运行失败，脚本命令、系统命令错误或参数传递错误 126 找到命令了，但是无法执行 127 要运行的命令不存在 128 命令被系统强制结束]]></content>
      <categories>
        <category>shell基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell的循环结构和控制]]></title>
    <url>%2F2015%2F07%2F12%2F2015-07-11-240710-shell%E7%9A%84%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E5%92%8C%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[while(当型)循环结构 标准用法 123456while [[ condition ]] ; do # statements1 # statements2 # ...........done# 当 condition 条件满足时执行循环体，否则退出循环 特殊用法一 12345while : ; do # statements1 # statements2 &amp;&amp; breakdone# 死循环,当触发某条件时退出循环 特殊用法二 123456while read col1 col2 ; do # statements1 # statements2 # ...........done &lt; /path/to/filename# 将文件内容作为标准输入,遍历每一行进行循环体内的所有操作 特殊用法三 123456while read col1 col2 ; do # statements1 # statements2 # ...........done &lt; &lt;(command)# 将进程替换的内容作为标准输入,遍历每一行进行循环体内的所有操作 until(直到型)循环结构123456until [[ condition ]] ; do # statements1 # statements2 # ...........done# 直到 condition 条件满足时退出循环，否则继续执行循环体 for循环结构 foreach型循环结构 123456for variable in WordList ; do # statements1 # statements2 # ...........done# in WordList 可省略，省略时相当于 in "$@" C语言型的循环结构 12345for (( exp1 ; exp2 ; exp3 )) ; do # statements1 # statements2 # ...........done 示例一 12345#!/bin/bashfor ((i=1;i&lt;=100;i++));do ((sum=sum+i))doneecho $sum 示例二 12345for i in &#123;1..5&#125; ; do # statements1 # statements2 # …………..done 示例三 12345for i in $(seq 5) ; do # statements1 # statements2 # …………..done 示例四 12345for i in 1 2 3 4 5 ; do # statements1 # statements2 # …………..done 循环控制123break # 跳出当前整个循环continue # 跳过本次循环,忽略剩余代码,进入循环的下一次迭代shift [n] # 用来把脚本或函数的位置变量列表向左移动指定的位数(n)，如果shift没有参数，则将位置变量向左移动一位。一旦移位发生，被移出列表的位置变量将被永远删除。例: shift 3 踢掉前三个参数]]></content>
      <categories>
        <category>shell基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell的选择语句分支]]></title>
    <url>%2F2015%2F07%2F10%2F2015-07-10-091310-shell%E7%9A%84%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5%E5%88%86%E6%94%AF%2F</url>
    <content type="text"><![CDATA[语句分支面向过程的语句结构： 顺序结构：逐条运行 选择结构：两个或以上的,满足条件时只会执行其中一个满足条件的分支 循环结构：某循环体需要执行多次 If语句分支if单分支12345if [[ condition1 ]] ; then # statements1 # statements2 # ...........fi 12345if ([[ condition1 ]] ) then # statements1 # statements2 # ...........fi if双分支1234567if [[ condition1 ]] ; then # statements1 # statements2else # statements3 # ..........fi if多分支12345678if [[ condition1 ]] ; then # statements1 # statements2elif [[ condition2 ]] ; then # statements3elif [[ condition3 ]] ; then # statements4fi 1234567891011if [[ condition1 ]] ; then # statements1 # statements2elif [[ condition2 ]] ; then # statements3elif [[ condition3 ]] ; then # statements4else # statements5 # ..........fi select语句分支 select表达式是bash的一种扩展应用，擅长于交互式场合。用户可以从一组不同的值中进行选择 语法格式 12345select varname in "string1" "string2" ; do # statements1 # statements2 # .....done 实例 123456#!/bin/bashecho "What is your favourite OS?"select var in "Linux" "Gnu Hurd" "Free BSD" "Other" ; do break ;doneecho "You have selected $var" 运行结果如下： 1234567What is your favourite OS?1) Linux2) Gnu Hurd3) Free BSD4) Other#? 1You have selected Linux case语句分支 用法 123456789101112case word in pattern1) # statements1 ;; pattern2) # statements2 ;; # .......... patternN) # statementsN ;;esac case支持的globbing 1234* # 任意长度的任意字符 ? # 任意单个字符[] # 指定范围内的单个字符 a|b # a或者b]]></content>
      <categories>
        <category>shell基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell的运算符]]></title>
    <url>%2F2015%2F07%2F09%2F2015-07-09-232810-shell%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[算术运算符 运算符 说明 + 加法 `expr $a + $b` - 减法 `expr $a - $b` * 乘法 `expr $a * $b` / 除法 `expr $a / $b` % 取余 `expr $a % $b` = 赋值 a=$b 将变量b的值赋给 a == 相等。用于比较两个整数，相同则返回 true [ $a == $b ] 返回 false。 != 不等。用于比较两个整数，不同则返回 true [ $a != $b ] 返回 true。 算术运算 let 算术运算表达式 123let C=$A+$B ; let C+=1let C=C+8 # 等同于 ((C=C+8))，后者效率更高 $[算术运算表达式] 1C=$[$A+$B] $((算术运算表达式)) 123C=$(($A+$B))#或((C=A+B)) C=`expr $A + $B` 表达式中各操作符及运算符之间要有空格，且要使用命令替换1echo $(($A+$B)) 注意： (())比let、expr会更高效 关系运算符关系运算符只支持整数，不支持字符串，除非字符串的值是整数 运算符 说明 举例 -eq 测试两个整数是否相等，相等返回 true [ $a -eq $b ] -ne 测试两个整数是否相等，不相等返回 true [ $a -ne $b ] -gt 测试左边的整数是否大于右边的，如果是，则返回 true [ $a -gt $b ] -lt 测试左边的整数是否小于右边的，如果是，则返回 true [ $a -lt $b ] -ge 测试左边的整数是否大等于右边的，如果是，则返回 true [ $a -ge $b ] -le 测试左边的数是否小于等于右边的，如果是，则返回 true [ $a -le $b ] 逻辑运算符12[ -O FILE ] &amp;&amp; [ -r FILE] 等价于 [ -O FILE -a -r FILE ]![ expression ] 运算符 说明 举例 ! 非运算，表达式为 true 则返回 false，否则返回 true [ ! 0 -ne 0 ] 返回true -o 或运算，有一个表达式为 true 则返回 true [ $a -lt 20 -o $b -gt 100 ] -a 与运算，两个表达式都为 true 才返回 true 字符串运算符 运算符 说明 举例 &gt; 测试前面字符串的ASCII码比后面的大 [[ “abc” &gt; “ABC” ]] &lt; 测试前面字符串的ASCII码比后面的小 [[ “abc” &lt; “ABC” ]] = 检测两个字符串是否相等，也可使用== [ “$a” = “$b” ] != 检测两个字符串是否相等，不相等返回 true [ “$a” != “$b” ] =~ 左侧的字符串是否能被右侧的正则表达式模式匹配 “$char” =~ pattern -z 检测字符串长度是否为0，为0返回 true [ -z “$a” ] 或 test -z “$a” -n 检测字符串长度是否为0，不为0返回 true [ -n “$a” ] 或 test -n “$a” str 检测字符串是否不为空，不为空返回 true [ “$a” ] 或 test “$a” 1234567a="abc123"[ "$a" == abc* ] # false (字面比较)[ "$a" == "abc*" ] # false (字面比较)[[ "$a" == abc* ]] # true (globbing比较)[[ "$a" == "abc*" ]] # false (字面比较)[[ "$a" =~ [abc]+[123]+ ]] # true (regex比较)[[ "$a" =~ "abc*" ]] # false (字面比较) 从bash 3.2版开始，正则表达式和globbing表达式都不能用引号包裹。若表达式里有空格，则可以把它存储到一个变量里： 12a="a b+"[[ "a bbb" =~ $a ]] # true (regex比较) 文件测试运算符 运算符 说明 举例 -a file 测试文件（包括目录）是否存在；同-e；-a处于弃用状态 [ -a $file ] -b file 测试文件是否是块设备文件 [ -b $file ] -c file 测试文件是否是字符设备文件； [ -b $file ] -d file 测试文件是否是目录； [ -d $file ] -e file 测试文件（包括目录）是否存在； [ -e $file ] -f file 测试文件是否是普通文件（既不是目录，也不是设备文件）； [ -f $file ] -g file 测试文件是否设置了 SGID 位； [ -g $file ] -G file 文件的group-id是否与你的相同 [ -G $file ] -h file 测试文件是否是符号链接文件；同-L； [ -h /bin/awk ] -k file 测试文件是否设置了粘着位(Sticky Bit)； [ -k $file ] -L file 测试文件是否是符号链接文件；同-h； [ -h /bin/awk ] -N file 测试文件从文件上一次被读取到现在为止，是否被修改过 [ -N $file ] -O file 测试文件的owner是否为当前用户 [ -O $file] -p file 测试文件是否是管道文件； [ -p $file ] -r file 测试文件是否可读； [ -r $file ] -s file 测试文件是否存在且不为空（文件大小是否大于0）。 [ -s $file ] -u file 测试文件是否设置了 SUID 位； [ -u $file ] -w file 测试文件是否可写； [ -w $file ] -x file 测试文件是否可执行； [ -x $file ] f1 -nt f2 测试文件f1是否比文件f2新 f1 -ot f2 测试文件f1是否比文件f2旧 f1 -ef f2 测试文件f1和文件f2是否是相同文件的硬链接]]></content>
      <categories>
        <category>shell基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell的条件测试语句]]></title>
    <url>%2F2015%2F07%2F08%2F2015-07-08-220810-shell%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[语法 格式1 test expression 格式2 [ expression ] 格式3 [[ expression ]] 说明 [是一条命令， 与test等价。在其中的表达式应是它的命令行参数，所以字符串串比较操作符 &gt; 与 &lt; 必须转义，否则就变成IO重定向向操作符了 [[]]是是扩展的 test 命令，用[[ ... ]]测试结构比用[ ... ]更能防止脚本里的许多逻辑错误。 &amp;&amp;，||， &lt;， 和 &gt; 操作符能够正常存在于[[ ]]中，但不能在 []中出现 在[[ ]]中可以使用通配符进行模式匹配，使用=~时支持shell的正则表达式 要对整数进行关系运算也可以使用Shell的算术运算符 (()) 进行测试]]></content>
      <categories>
        <category>shell基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell命令间的逻辑关系]]></title>
    <url>%2F2015%2F07%2F07%2F2015-07-07-210810-shell%E5%91%BD%E4%BB%A4%E9%97%B4%E7%9A%84%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[无逻辑关系1COMMAND1;COMMAND2;COMMAND3... 逻辑关系 顺序执行 用 ;间隔的各命令按顺序依次执行 逻辑与： &amp;&amp; 第一个条件为假时，第二条件不用再判断，最终结果已确定； 第一个条件为真时，第二条件必须得判断 逻辑或：|| 第一个条件为真时，第二条件不用再判断，最终结果已确定； 第一个条件为假时，第二条件必须得判断 优先级： ; 优先级最低 ||和&amp;&amp;具有相同的优先级 同优先级，按从左到右的结合原则执行命令行 使用( )可以组合命令行中的命令，改变执行顺序 示例 123456789! id user6 &amp;&amp; useradd user6id user6 || useradd user6# 如果用户user6不存在，就添加用户user6id user1 &amp;&amp; echo "user1 exists." || useradd user1# 如果用户存在，就显示用户已存在；否则，就添加此用户! id user1 &amp;&amp; useradd user1 || echo "user1 exists."# 如果用户不存在，就添加；否则，显示其已经存在! id user1 &amp;&amp; useradd user1 &amp;&amp; echo "user1" | passwd --stdin user1 || echo "user1 exists."#如果用户不存在，添加并且给密码；否则，显示其已经存在]]></content>
      <categories>
        <category>shell基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell登录提示符与登录提示信息]]></title>
    <url>%2F2015%2F07%2F06%2F2015-07-06-223310-shell%E7%99%BB%E5%BD%95%E6%8F%90%E7%A4%BA%E7%AC%A6%E4%B8%8E%E7%99%BB%E5%BD%95%E6%8F%90%E7%A4%BA%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[Shell登录提示符常用参数及含义在/etc/bashrc文件中会设定PS1变量，这个变量设置的就是登录之后的提示符信息 12[root@localhost ~]$ echo $PS1[\u@\h \W]\$ \d ：代表日期，格式为weekday month date，例如：”Mon Aug 1” \H ：完整的主机名称 \h ：仅取主机名中的第一个名字 \t ：显示时间为24小时格式，如：HH：MM：SS \T ：显示时间为12小时格式 \A ：显示时间为24小时格式：HH：MM \u ：当前用户的账号名称 \v ：BASH的版本信息 \w ：完整的工作目录名称 \W ：利用basename取得工作目录名称，只显示最后一个目录名 \# ：下达的第几个命令 \$ ：提示字符，如果是root用户，提示符为 # ，普通用户则为 $ 所以linux默认的命令行提示信息的格式PS1=&#39;[\u@\h \W]\$ &#39;的意思就是： 1[当前用户的账号名@主机名的第一个名字 工作目录的最后一层目录名]# 颜色参数 在PS1中设置字符颜色的格式为：\[\e[F;Bm\]........\[\e[0m\]，其中\[\e[作为颜色设定的开始，F为字体颜色，编号为30-37，B为背景颜色，编号为40-47，\[\e[0m\]作为颜色设定的结束。 颜色对照表： F B 颜色 30 40 黑色 31 41 红色 32 42 绿色 33 43 黄色 34 44 蓝色 35 45 紫红色 36 46 青蓝色色 37 47 白色 个性化配置命令提示符linux终端命令行默认全部为白色，会经常导致命令与输出内容难以分辨。于是我们通过自定义PS1环境变量来实现这个需求。 示例1：终端提示符添加颜色 1PS1='\[\e[1;36;40m\][\u@\H \W]\$\[\e[0m\] ' 示例2：多行提示符 1PS1='\D&#123;%c&#125; \w\n[\u@\H]\$ ' 如果想要永久生效，我们可以将这行命令写到/etc/profile.d/myPS1.sh，并添加权限即可 登录提示信息登录前提示信息每次登录系统时都会有提示信息，需要注意的是这个登录提示信息是针对本地终端tty{1-6}的，而并非类SSH登录。 本地终端提示信息默认在文件/etc/issue中，如: 123[root@localhost ~]# cat /etc/issueCentOS release 5.8 (Final)Kernel \r on an \m 转义符说明 123456789\d：显示当前系统日期\s：显示操作系统名称\l：显示登录的终端号，这个比较常用\m：显示硬件体系结构，如x86\n：显示主机名\o：显示域名\r：显示内核版本号\t：显示当前系统时间\u：显示当前登录用户的序列号 远程终端提示信息默认在文件/etc/issue.net中，如: 123[root@localhost ~]# cat /etc/issue.netCentOS release 5.8 (Final)Kernel \r on an \m 在SSH服务中默认并没有开启显示信息，要想在SSH登录时显示这些内容，可以在/etc/ssh/sshd_config文件中，把Banner none改为Banner /etc/issue.net，然后重启sshd服务重新登录就会看到显示信息。但是Kernel \r on an \m这行字符原样显示并没有进行转义，原因是远程信息提示不支持转义符的使用，一般就是用来写一些警告信息。 登陆后提示信息 生产服务器最好做到什么信息都不要提示，以免带来安全问题。如果一定要写，建议写在/etc/motd文件中，并且最好写一些警告信息 登陆成功后如果需要给出提示信息，可以在文件/etc/motd中定义，默认这个文件是空的，需要写上面直接定义即可。 以下是几个供娱乐使用的提示信息模板 12345678910111213141516171819202122 _oo8oo_ o8888888o 88" . "88 (| -_- |) 0\ = /0 ___/'==='\___ .' \\| |// '. / \\||| : |||// \ / _||||| -:- |||||_ \ | | \\\ - /// | | | \_| ''\---/'' |_/ | \ .-\__ '-' __/-. / ___'. .' /--.--\ '. .'___ ."" '&lt; '.___\_&lt;|&gt;_/___.' &gt;' "". | | : `- \`.:`\ _ /`:.`/ -` : | | \ \ `-. \_ __\ /__ _/ .-` / / =====`-.____`.___ \_____/ ___.`____.-`===== `=---=` ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ God bless Never crash 12345678910111213141516171819202122//////////////////////////////////////////////////////////////////// // _ooOoo_ // // o8888888o // // 88" . "88 // // (| ^_^ |) // // O\ = /O // // ____/`---'\____ // // .' \\| |// `. // // / \\||| : |||// \ // // / _||||| -:- |||||- \ // // | | \\\ - /// | | // // | \_| ''\---/'' | | // // \ .-\__ `-` ___/-. / // // ___`. .' /--.--\ `. . ___ // // ."" '&lt; `.___\_&lt;|&gt;_/___.' &gt;'"". // // | | : `- \`.;`\ _ /`;.`/ - ` : | | // // \ \ `-. \_ __\ /__ _/ .-` / / // // ========`-.____`-.___\_____/___.-`____.-'======== // // `=---=' // // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ // // 佛祖保佑 永无BUG 永不修改 // //////////////////////////////////////////////////////////////////// 12345678910111213141516171819//// .::::.// .::::::::.// :::::::::::// ..:::::::::::'// '::::::::::::'// .::::::::::// '::::::::::::::..// ..::::::::::::.// ``::::::::::::::::// ::::``:::::::::' .:::.// ::::' ':::::' .::::::::.// .::::' :::: .:::::::'::::.// .:::' ::::: .:::::::::' ':::::.// .::' :::::.:::::::::' ':::::.// .::' ::::::::::::::' ``::::.// ...::: ::::::::::::' ``::.// ```` ':. ':::::::::' ::::..// '.:::::' ':'````.. 12345678910111213141516** * ┌───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐ * │Esc│ │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│ ┌┐ ┌┐ ┌┐ * └───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘ └┘ └┘ └┘ * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐ * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│&amp; 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │ * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤ * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │&#123; [│&#125; ]│ | \ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │ │ * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │ * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│" '│ Enter │ │ 4 │ 5 │ 6 │ │ * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤ ┌───┐ ├───┼───┼───┼───┤ * │ Shift │ Z │ X │ C │ V │ B │ N │ M │&lt; ,│&gt; .│? /│ Shift │ │ ↑ │ │ 1 │ 2 │ 3 │ │ * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││ * │ Ctrl│ │Alt │ Space │ Alt│ │ │Ctrl│ │ ← │ ↓ │ → │ │ 0 │ . │←─┘│ * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘ *]]></content>
      <categories>
        <category>shell基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell的模式与环境变量的配置文件]]></title>
    <url>%2F2015%2F07%2F06%2F2015-07-06-210310-shell%E7%9A%84%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Bash Shell四种模式介绍登录式Shell（login shell）取得bash时需要完整的登入流程，就称为login shell。 正常通常某终端登录当系统启动时或开启一个新的终端登录系统时，系统通过调用/bin/login程序处理登录并在 一个shell中显示命令行提示符，这个shell就是login shell；该shell程序可以是bash也可以是sh或csh，具体使用哪种shell可以在/etc/passwd中设置（/bin/login程序读取该文件决定使用哪种Shell）。 完全切换到另一个用户环境 su - USERNAME su -l USERNAME 非登录式Shell（non-login shell） 图形终端下打开命令窗口以X window登入Linux后，再以X的图形化界面启动命令终端，此时的命令终端并不需要再次输入用户名和密码，所以此时bash的环境就称为non-login shell 自动执行的shell脚本 半切换只切换不使用用户环境 su USERNAME Interactive shell and non-interactive shellinteractive意为交互式。 interactive shell会有一个输入提示符，并且它的标准输入、输出和错误输出都会显示在控制台上。所以一般来说只要是需要用户交互的，即一个命令一个命令的输入的shell都是interactive shell。 non-interactive shell，无需用户交互。通常来说如bash script.sh此类执行脚本的命令就会启动一个non-interactive shell，它不需要与用户进行交互，执行完后它便会退出创建的shell。 典型的启动方式及其shell模式1）登陆机器后的第一个Shell：属于login + interactive 2）新启动一个Shell进程，如运行bash：属于non-login + interactive 3）执行脚本，如bash script.sh：属于non-login + non-interactive 4）运行头部有如#!/usr/bin/env bash的可执行文件，如./executable：属于non-login + non-interactive 5）通过ssh登陆到远程主机：属于login + interactive 6）远程执行脚本，如ssh user@remote script.sh：属于non-login + non-interactive 7）远程执行脚本，同时请求控制台，如ssh user@remote -t &#39;echo $PWD&#39;：属于non-login + interactive 8）在图形化界面中打开终端：属于non-login + interactive bash配置文件 全局配置：对所有用户生效 /etc/profile /etc/profile.d/*.sh /etc/bashrc 个人配置：对当前用户生效，每个用户家目录都有以下两个文件 ~/.bash_profile ~/.bashrc 文件读取顺序 登录式shell登陆 ==&gt; 执行/etc/profile ==&gt; profile调用执行/etc/profile.d/*.sh ==&gt; profile执行~/.bash_profile ==&gt; 执行~/.bashrc ==&gt; 执行/etc/bashrc ==&gt; 命令提示符 非登录式shell~/.bashrc ==&gt; /etc/basrc ==&gt; /etc/profile.d/*.sh bash配置文件作用 profile类的文件：设定环境变量，运行命令或脚本 bashrc类的文件：设定本地变量，定义命令别名 根据登录式Shell的启动顺序详细介绍这些这些文件的作用 /etc/profile 它是系统整体的配置文件，该配置文件里包含很多重要的变量信息，每个用户登陆取得bash后一定会读取这个配置文件。如果你想要设定环境变量对所有用户起作用，就要在这个地方设置。大概内容如下: (1) USER变量设置。 (2) LOGNAME变量设置。 (3) MAIL变量设置。 (4) PATH变量设置。 (5) HOSTNAME变量设置。 (6) HISTSIZE变量设置1000。 (7) 然后使用export把以上所有变量声明成环境变量。 (8) 管理员和普通用户的umask设置。 (9) 调用/etc/profile.d/*.sh文件。 /etc/profile.d/*.sh 在这个目录下一般用户可以自定义一些脚本，系统默认也有一些脚本，如/etc/profile.d/lang.sh这个脚本，其中最重要的就是这个脚本调用了/etc/sysconfig/i18n这个文件，而这个文件中定义定义的就是系统的默认语言，如 123[root@localhost ~]# cat /etc/sysconfig/i18nLANG="en_US.UTF-8"SYSFONT="latarcyrheb-sun16" ~/.bash_profile 这个文件文件会先检查~/.bashrc是否存在，然后会执行export PATH这个变量。 ~/.bashrc 这个文件中都是用来定义别名使用的，如果你要定义别名就可以放在这个文件中。 /etc/bashrc 这个文件定义了PS1变量，可以用来设定登录提示符等信息；设定本地变量，添加定义命令别名。并且特别针对非登录的Shell重新设定了一些变量，如PATH，PS1等。 注意: 按照文件的启动顺序，基本上定义的所有变量都会生效，但是后面启动的文件中定义的变量会覆盖前面文件中定义的相同名称的变量。所以要想更好地设定一些变量和别名，就需要知道这些文件的作用域以及非登录式Shell和登录式Shell各自应用哪些文件。 其他变量配置文件 ~/.bash_logout 用户登出时使用的配置文件，默认这个文件是空的，如果你想在退出系统时做什么操作就可以在这个文件中定义，如果说退出登录时可以执行命令“history -c”清空历史命令。 ~/.bash_history 这个文件是用来记录用户操作的历史命令的，默认HISTSIZE=1000定义在/etc/profile文件中，你可以把这个变量值改的大一点都行。但是注意这个文件中定义的历史命令跟你用history命令查看的可能不尽相同。因为文件中的都是磁盘上，而history查看的在内存中。 ~/.viminfo 用环境变量来定义vim使用时的一些状态，比如是否显示行数、高亮等。 ~/.vimrc vim的用户配置，全局配置文件为/etc/vimrc ~/.mysql_history 安装MySQL之后就会生成这个文件，跟.bash_history作用基本相同，不同的是.mysql_history是用来记录SQL语句的。 shell中将配置生效可以使环境变量生效，也可用于编写脚本加载脚本定义的配置文件 1source /PATH/TO/PROFILE 或 . /PATH/TO/PROFILE]]></content>
      <categories>
        <category>shell基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell中对变量的操作]]></title>
    <url>%2F2015%2F07%2F04%2F2015-07-04-141510-shell%E4%B8%AD%E5%AF%B9%E5%8F%98%E9%87%8F%E7%9A%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[声明变量 用法 123456$ declare [OPTIONS] VARIABLES-i # 整型-a # 数值-x # 环境变量-r # 只读变量，不能撤销，不能修改，相当于readonly-f # 声明函数 示例 1declare -i A=20 变量赋值 变量赋值规则 等号两边不能有空格 value值包括空格必须用引号，variable=&quot;hello world&quot; 变量名只能包括字母数字和下画杠，并且变量名不能以数字开头 示例 12345var_name =VALUE # 这里的变量为本地变量declare -i var_name=VALUE # 定义为整型declare -x var_name=VALUE # 定义为环境变量declare -r var_name=VALUE 或 readonly var_name=VALUE（只读变量只有进程结果后才会撤销，若定义在环境配置文件中则需要手动清除） 变量撤销1unset var_name # 不需要加$，可撤销环境变量 变量引用1$&#123;var_name&#125; 或 $var_name 变量间接引用12345678910message=HelloHello=Goodbye[root@CentOS ~]$ echo "$message"Hello[root@CentOS ~]$ echo "$&#123;!message&#125;"Goodbye# 或[root@CentOS ~]$ eval message=\$$message[root@CentOS ~]$ echo "$&#123;!message&#125;"Goodbye 变量的查看123456set # 显示(设置)所有shell变量（包括环境变量及本地变量）env # 显示(设置)当前shell的环境变量printenv # 同envexport # 显示(设置)导出成当前shell环境变量的变量。declare -x # 同export declare -r # 显示只读变量 1234567891011[root@CentOS ~]$ Name=Alex # shell本地变量设定[root@CentOS ~]$ echo $Name Alex[root@CentOS ~]$ env | grep Name # 当前shell的环境变量不存在[root@CentOS ~]$ set | grep Name # 本地变量存在Name=Alex[root@CentOS ~]$ export | grep Name # 导出为当前shell的环境变量也不存在[root@CentOS ~]$ export Name # 使用export导出为当前shell的环境变量[root@CentOS ~]$ env | grep $Name Name=Alex[root@CentOS ~]$ 从变量提取字符串 对于变量a 1234$&#123;a#*hehe&#125; # 删掉掉第一个hehe及其左边的字符串$&#123;a##*hehe&#125; # 删掉最后一个hehe及其左边的字符串$&#123;a%hehe*&#125; # 删掉掉最后一个hehe及其右边的字符串$&#123;a%%hehe*&#125; # 删掉掉第一个hehe及其右边的字符串 符号说明 123* 只是一个通配符有时可以不要# 删掉左边% 删掉右边，（键盘$左边是#，右边是%） 单一符号最小匹配，两个符号最大匹配，匹配到的内容删掉 基于字符串切片 ${var:offset:length} offset：要跳过字节的个数；length：取出字节的长度，如果省略则取偏移量后所有元素 ${var: -length} 12345678910[root@CentOS6 ~]$ mypath="/etc/sysconfig/network-scripts/"[root@CentOS6 ~]$ echo $&#123;mypath:5&#125; # 提取最左边的 5 个字节后的内容sysconfig/network-scripts/ [root@CentOS6 ~]$ echo $&#123;mypath:10&#125; # 提取第 10 个字节右边的内容nfig/network-scripts/[root@CentOS6 ~]$ echo $&#123;mypath:4:10&#125; # 提取第 4 个字节右边的10个字节的内容[root@CentOS6 ~]$ echo $&#123;mypath: -10&#125; # 取出字符串最后10个字节，-前面需要有空格k-scripts/[root@CentOS6 ~]$ echo $&#123;#mypath&#125; # 取出字符长度31 大小写切换12$&#123;a^^&#125; # 把 $a 中所有小写字母替换为大写$&#123;a,,&#125; # 把 $a 中所有大写字母替换为小写 变量展开123456789$&#123;a=hehe&#125; # 若 $a 未设定，则用 hehe 作传回值，同时将 $a 赋值为 hehe (空及非空时不作处理)$&#123;a:=hehe&#125; # 若 $a 未设定或为空，则使用hehe作传回值，同时将 $a 赋值为hehe (非空时不作处理)$&#123;a-hehe&#125; # 若 $a 未设定，则使用 hehe 作传回值(空及非空时不作处理)$&#123;a:-hehe&#125; # 若 $a 未设定或为空，则使用hehe 作传回值(非空时不作处理)$&#123;a+hehe&#125; # 若 $a 设为空或非空，则使用hehe作传回值(未设定时不作处理)$&#123;a:+hehe&#125; # 若 $a 为非空，则使用 hehe 作传回值(未设定及空时不作处理)$&#123;a?hehe&#125; # 若 $a 未设定，则将 hehe 输出至STDERR(空及非空时不作处理)$&#123;a:?hehe&#125; # 若 $a 未设定或为空，则将 hehe 输出至 STDERR(非空时不作处理)$&#123;#a&#125; # 计算变量a的值的长度 以上的理解在于，要分清楚 unset 与 null 及 non-null 这三种赋值状态。:与 null 有关。 若不带 : 则 null 不受影响； 若带 : 则连 null 也受影响。 字符串的替换(globbing)1234$&#123;a/hehe/haha&#125; # 将第一个 hehe 提换为 haha$&#123;a//hehe/haha&#125; # 将全部 hehe 提换为 haha $&#123;string/#substring/replace&#125; # 若 $strting 最前面匹配substring，就用replace来替换substring$&#123;string/%substring/replace&#125; # 若 $strting 最后面匹配substring，就用replace来替换substring 字符串的删除(globbing)1234$&#123;a/hehe&#125; # 查找 $a 中首次匹配到的字符串hehe,并删除之$&#123;a//hehe&#125; # 查找 $a 中所有匹配到的字符串hehe,并删除之$&#123;a/#hehe&#125; # 查找 $a 中首部匹配到的字符串hehe,并删除之$&#123;a/%hehe&#125; # 查找 $a 中尾部到的字符串hehe,并删除之]]></content>
      <categories>
        <category>shell基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell的变量和分类]]></title>
    <url>%2F2015%2F07%2F03%2F2015-07-03-190522-shell%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[什么是变量变量：就是一个容器用来存储数据也是一段内存空间（内存是编制的存储单元）；通过变量赋值在变量中存储数据，然后可以通过变量名访问到的存储信息的内存空间地址。变量是脚本语言的核心，shell脚本又是无类型的，所以要使用变量就需要引用。 数据类型用来事先定义数据的存储格式和存储长度，参与的运算。 数据类型的重要性：有一种系统攻击叫缓冲区溢出，如声明一个数据类型为整型并申请1字节空间。当在这个变量中存储256时，这个整型数据时就会产生溢出，因为1字节存储单元的存储范围是0-255。而256就存储不了也就会产生溢出占用其他进程空间，解决缓冲溢出最简单的方法就是当用户存储一个数据时先检查数据是否可以存储下。 对于解释型语言来说，它的数据类型都是弱类型就是不管变量中的数据有没有类型都可以因为解释器能理解；由解释器在另外一个层次给予避免。 对于编译型语言来说，一旦数据类型出了问题只能靠程序自身来解决，它没有额外的一层保护机制，编译器也可以在编译时检查明显错误，但是对于后期用户输入进来的数据就无法检查了，所以但凡编译型语言都是强类型编译必须事先严格定义变量中的数据类型。 常用的数据类型有字符型，数值型，时间日期型，布尔型等等。 Bash对变量的机制 所有变量都看作为字符型 不支持浮点型数据，需借助外部机制 变量无需事先声明，即变量赋值和变量声明同时进行 变量引用机制 把变量名出现的位置，直接替换为其所指向的内存空间中的数据 变量的命名规范 不能以数字开头，只能包含数字、字母、下划线，且变量名中不能出现空格 不能使用下划线以外的标点符号 不能使用程序语言的保留字（if else while 等），保留关键字可以尝试help if这种方式查看 变量名要做到见名知义 Tips： 命名规则针对的是自定义变量 变量分类本地变量本地变量作用域只对当前shell进程生效，对子shell、其他shell进程无效。Bash默认变量都是本地变量。 12345678# 定义本地变量set VAR_NAME=value# set一般都可以省略，如下VAR_NAME=VALUE# 引用变量,其中()一般可省略，直接echo $VAR_NAME;echo $(VAR_NAME) 局部变量局部变量作用域对当前代码段有效，在一个脚本的函数中的变量跟函数外的变量名同名，就可以把函数内的变量定义为局部变量，这样就不会跟其他变量冲突。 12# 定义局部变量local VAR_NAME=value 环境变量环境变量用来定义每一个用户的操作环境，变量作用域只对当前用户shell进程及其子shell生效，并且机器重启变量失效。如我们常用的PATH变量就是一个环境变量，不管机器有没有重启，PATH变量重来没有失效过，这是因为针对环境变量有特定的环境变量配置文件，每一次用户登录就会加载此配置文件，同理在此文件中的变量就会生效。 定义环境变量123456789# 定义环境变量，定义不存在的变量为环境变量;export VAR_NAME=value# 或如下方式declare -x VAR_NAME=VALUE# 或如下方式VARNAME=VALUE ; export VARNAME# 定义环境变量,定义已存在的变量为环境变量；$ export VAR_NAME 查看当前系统环境变量12345set # 显示(设置)所有shell变量（包括环境变量及本地变量）env # 显示(设置)当前shell的环境变量printenv # 同envexport # 显示(设置)导出成当前shell环境变量的变量。declare -x # 同export 常见的系统环境变量 变量名称 含义 SHELL 当前用户用的是哪种Shell BASH bash的路径 BASH_VERSION bash的版本号 LANG 字符集，是和语言相关的环境变量，使用多种语言的用户可以修改此环境变量 HOSTNAME 主机的名称，许多应用程序如果要用到主机名的话，通常是从这个环境变量中来取得的 HOSTTYPE 主机架构类型，用来识别系统硬件 MACHTYPE 平台类型，系统平台依赖的编译平台 OSTYPE 系统类型 LOGNAME 当前用户的登录名 USER 当前的用户 UID 当前的用户的ID号 EUID 有效用户的ID号 HOME 当前用户的家目录 PWD 当前目录 OLDPWD 上次使用的目录 PATH 包含一系列由冒号分隔开的目录，系统从这些目录里寻找可执行文件。若输入的可执行文件不在这些目录中，系统就无法执行它（除非输入绝对路径） LDPATH 包含一系列用冒号隔开的目录，动态链接器将在这些目录里查找库文件 MANPATH 包含一系列用冒号隔开的目录，命令man会在这些目录里搜索man页面，在/etc/man.config或/etc/man_db.conf中定义 INFODIR 包含一系列用冒号隔开的目录，命令info将在这些目录里搜索info页面 PAGER 包含浏览文件内容的程序的路径（例如less或者more） EDITOR 包含修改文件内容的程序（文件编辑器）的路径（比如nano或者vi） KDEDIRS 包含一系列用冒号隔开的目录，里面放的是KDE相关的资料 MAIL 当前用户的邮件存放目录 HISTSIZE 保存历史命令记录的条数 PS1 命令提示符，对于root用户是#，对于普通用户是$ PS2 是附属提示符，默认是“&gt;”。可以通过修改此环境变量来修改当前的命令符 PS3 第三提示符，用于select命令中 PS4 第四提示符，当使用-X选项调用脚本时，显示的提示符，默认为+号 示例 123456[user1@practice ~]$ export PS2='........'[user1@practice ~]$ if true;then........echo "$&#123;USER&#125;";........fiuser1[user1@practice ~]$ 位置变量$1，$2，…$9，${10}，${11}…${n}传递给脚本或函数的位置参数，只读 12345$0 # 用于引用执行脚本的名称;$1 # 用于引用执行脚本后跟的第一个位置参数;$2 # 用于引用执行脚本后跟的第二个位置参数;$N # 用于引用执行脚本后跟的第N个位置参数;shift 1 # 轮换，用于替换一个或多个位置变量; 1234args=$# # 位置参数的个数lastarg=$&#123;!args&#125; # 或lastarg=$&#123;!#&#125; # 取得位置参数中的最后一个参数# 注意 lastarg=$&#123;!$#&#125; 将报错 特殊变量shell对一些参数做特殊处理，只能被引用不能被赋值 123456789$0 # 当前脚本的文件名$$ # 获取当前shell的进程号$! # 执行上一个指令的进程号$# # 所有位置变量的个数$* # 所有位置变量，作为一个整体字符串$@ # 所有位置变量，每个变量作为独立字符串$- # 当前Shell的命令行选项$_ # 上一个命令或脚本的最后一个参数$? # 上一个命令或脚本的执行状态返回值]]></content>
      <categories>
        <category>shell基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash特性]]></title>
    <url>%2F2015%2F07%2F02%2F2015-07-02-174310-bash%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[命令历史 history history n 列出最近执行过的n条命令 -c 清除所有历史命令、 -w 将缓冲区命令写入历史命令文件~/.bash_history ! !n 执行历史命令中第n条命令 !-n 执行历史命令中倒数第n条命令 !! 执行上一条命令 !string 执行命令历史中最近一个以指定字符串(string)开头的命令 !$ 引用上一条命令的最后一个参数 ↑ 或 Ctrl + p 引用上一条命令 ↓ 或 Ctrl + n 引用下一条命令 Esc + . 引用上一条命令的最后一个参数 重复执行 Esc + . 则会倒序切换历史命令的最后一个参数 !cmd:3 引用上一条命令的第三个参数 Ctrl + r 按下 Ctrl + r ，然后输入关键字搜索历史命令，按 Enter 执行命令 命令行补全 搜索PATH环境变量所指定的每个路径下以我们给出的字符串开头的可执行文件 如果符合的文件多于一个，按两次 Tab，可以给出以给出字符开头的可执行文件的列表；否则将直接补全命令； 路径补全搜索我们给出的起始路径下的每个文件名，并试图补全 命令别名 定义别名 1alias CMDALIAS='COMMAND [options] [arguments]' 撤销别名 1unalias CMDALIAS 不使用别名，而使用原命令本身 1\COMMAND 在shell中定义的别名仅在当前shell生命周期中有效，作用域仅为当前shell进程； 配置 ~/.bashrc 下次登录及以后登录后永久生效 命令替换 命令替换，即把某个子命令替换为其执行结果的过程 某些命令中若出现命令替换符，kernel会首先执行子命令，然后在执行外部命令 1$(command) 或 `command` 命令行编辑 Ctrl + a 光标跳转到命令行行首 Ctrl + e 光标跳转到命令行行尾 Ctrl + l 清屏，等同于 clear 命令 Ctrl + u 剪切光标至命令行行首的内容 Ctrl + k 剪切光标至命令行行尾的内容 Ctrl + w 剪切光标之前一个单词 Ctrl + y 复制剪切的内容 Ctrl + b 向左移动光标，等同于 ← Ctrl + f 向右移动光标，等同于 → Ctrl + j 相当于回车键，回车执行命令 Ctrl + x + x 光标在命令行中最后两次出现的位置间互相切换 Esc + b 移动到当前单词的词首处，等同于xterm终端下的Ctrl+← Esc + f 移动到当前单词的词尾处，等同于xterm终端下的Ctrl+→ Esc + t 交换光标前的最后两个单词 Esc + u 将当前单词转换为大写 Esc + l 将当前单词转换为小写 Esc + c 将当前字母转换为大写 命令行展开命令行中花括号内的内容类似因式分解展开 12echo aa&#123;1,2,3&#125;X&#123;a,b&#125; aa1Xa aa1Xb aa2Xa aa2Xb aa3Xa aa3Xb 1cp /etc/sysctl.conf&#123;,.bak&#125; 通配（globbing）获取帮助 man 7 glob 字符 含义 * 任意长度的任意字符 ？ 任意单个字符 ~ 当前用户的家目录 ~user1 用户user1的家目录 ~- 上一个工作目录 ~+ 当前工作目录 [] 列表中的任意单个字符 [^] 列表中的所有字符以外的字符 [0-9] 任意单个数字 [a-z] 小写字母 [A-Z] 大写字母 [0-9a-Z] 大小写字母及数字 [:lower:] 任意小写字母 [:upper:] 任意大写字母 [:alpha:] 任意大小写字母 [:alnum:] 任意数字或字母 [:space:] 空格 [:punct:] 标点符号 [:digit:] 任意单个数字，同 [0-9] 管道管道操作符是：”|”，仅能处理经由前面一个指令传出的正确输出信息，即 standard output 的信息，对于 stdandard error 信息没有直接处理能力。而后传递给下一个命令，作为下一个命令的标准的输入 standard input command1的正确输出作为command2的输入，然后comand2的正确输出作为comand3的输入 ，comand3的输出直接显示在屏幕。 注意：1、管道只处理前一个命令的正确输出，不处理错误输出。2、管道右边命令，必须能够接收标准输入流命令才行。 管道和重定向的区别 左边的命令应该有标准输出 | 右边的命令应该接受标准输入 左边的命令应该有标准输出 &gt; 右边只能是文件 左边的命令需要接受标准输入 &lt; 右边需要能产生标准输出进程或文件 管道两边必须是shell命令- 管道触发两个子进程执行”|”两边的程序；而重定向是在一个进程内执行 I/O重定向标准输入(stdin)输入至程序的数据（通常是文件）。 程序要求以读(read)操作来传输数据。并非所有程序都要求输入。如dir或ls程序运行时不用任何输入。 除非重导向，输入是预期由键盘获取的。 标准输入的文件描述符为 0 （零） 标准输出(stdout)程序写输出数据的流。 程序要求数据传输使用写的运算。并非所有程序都要求输出。如mv或ren程序在成功完成时是沉默的。 除非重导向，输出为终端。 标准输出的文件描述符为 1 。 标准错误输出(stderr)标准错误输出是另一输出流，用于输出错误消息或诊断。它独立于标准输出，且可以分别被重导。 常见的输出目的地则为启始这个程序的终端，即使其标准输出被重导亦如此。例如：一个管道中的程序的输出被重导到下一个程序，但错误消息仍然直接流当前终端机。 把标准输出和标准错误输出导到相同的目的地，如文字终端，是可以（且正常）的。消息会以如同程序写入的顺序来出现，除非使用了缓冲。（例如，一个常见状况是，当标准错误流未使用缓冲，但标准输出流使用了缓冲；在这种情况下，如果标准输出的缓冲器还没满的话，较迟写到标准错误的文字可能会较早出现在终端。 标准错误输出的文件描述子为 2 文件描述符(file descriptor)可以理解为linux跟踪打开文件，而分配的一个数字，这个数字有点类似c语言操作文件时候的句柄，通过句柄就可以实现文件的读写操作。 用户可以自定义文件描述符范围是：3-num，这个最大数字跟用户的 ulimit -n 定义数字有关系，不能超过最大值。 系统启动后，默认打开3个文件描述符，分别是：标准输入standard input 0，标准输出standard output 1，标准错误输出：standard error output 2。 打开文件后新增文件绑定描述符可以依次增加。 一条shell命令执行，都会继承父进程的文件描述符。因此所有运行的shell命令，都会有默认3个文件描述符。 命令执行前，先会准备好所有输入输出，默认分别绑定（stdin，stdout，stderr)，如果这个时候出现错误，命令将终止，不会执行。 对于任何一条linux 命令执行，它会是这样一个过程： 重定向基本知识 I/O重定向通常与 FD 有关，shell的FD通常为10个，即 0～9； 常用的3个FD：0（stdin）、1（stdout）、2（stderr）； 用 &lt; 来改变读进的数据信道(stdin)，使之从指定的档案读进； 用 &gt; 来改变送出的数据信道(stdout, stderr)，使之输出到指定的档案； 0 是 &lt; 的默认值，因此 &lt; 与 0&lt;是一样的；同理，&gt; 与 1&gt; 是一样的； 在IO重定向中，stdout 与 stderr 的管道会先准备好，才会从 stdin 读进资料； 管道”|“ (pipe line)：上一个命令的 stdout 接到下一个命令的 stdin； tee 命令是在不影响原本 I/O 的情况下，将 stdout 复制一份到档案去； bash（ksh）执行命令的过程：分析命令－变量求值－命令替代（``和$( )）－重定向－通配符展开－确定路径－执行命令； ( ) 将 command group 置于 sub-shell 去执行，也称 nested sub-shell，它有一点非常重要的特性是：继承父shell的标准输入、标准输出、标准错误和任何其他打开的文件描述符。 exec 命令：常用来替代当前 shell 并重新启动一个 shell，换句话说，并没有启动子 shell。使用这一命令时任何现有环境都将会被清除。exec 在对文件描述符进行操作的时候，也只有在这时，exec 不会覆盖你当前的 shell 环境。 I/O编辑 cmd &gt; file把 stdout 重定向到 file 文件中 cmd 1&gt; file 把 stdout 重定向到 file 文件中 cmd 2&gt; file 把 stderr 重定向到 file 文件中 cmd &gt;&gt; file 把 stdout 重定向到 file 文件中(追加) cmd 2&gt;&gt; file 把 stderr 重定向到 file 文件中(追加) cmd &gt; file 2&gt;&amp;1 把 stdout 和 stderr 一起重定向到 file 文件中 cmd &gt;&gt; file 2&gt;&amp;1 把 stdout 和 stderr 一起重定向到 file 文件中(追加) cmd &lt; file &gt;file2 cmd 命令以 file 文件作为 stdin，以 file2 文件作为 stdout cat &lt;&gt; file 以读写的方式打开 file cmd &lt; file cmd 命令以 file 文件作为 stdin cmd &lt;&lt; delimiter Here document，从 stdin 中读入，直至遇到 delimiter 分界符 cmd &lt;&lt;- Here-document，从 stdin 中读入，并且抑制 stdin 开头的制表符（\t） cmd &lt;&lt;&lt; “string|$(cmd)” Here-word，从字符中读入 进阶I/O >&amp;n 使用系统调用 dup2复制文件描述符 n 并把结果用作标准输出 &lt;&amp;n 标准输入复制自文件描述符 n &lt;&amp;- 关闭标准输入（键盘） >&amp;- 关闭标准输出 n&lt;&amp;- 表示将 n 号输入关闭 n&gt;&amp;- 表示将 n 号输出关闭 exec 1&gt;outfilename 打开文件 outfilename作为 stdout exec 2&gt;errfilename 打开文件 errfilename作为 stderr exec 0&lt;&amp;- 关闭 FD0 exec 1&gt;&amp;- 关闭 FD1 exec 5&gt;&amp;- 关闭 FD5 支持变量使用变量本质上存储数据的一个或多个计算机内存地址 支持编程shell 编程]]></content>
      <categories>
        <category>shell基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell简介]]></title>
    <url>%2F2015%2F07%2F01%2F2015-07-01-102110-shell%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[摘要计算机硬件是由 运算器、控制器、存储器、输入/输出设备等设备组成的，而能够让机箱内各种硬件设备各司其职东西就叫——kernel（内核）。内核负责驱动硬件、管理活动和分配/管理硬件资源，系统内核不能直接让用户操作。因为用户不能直接控制硬件也不能直接操作内核，于是便需要基于“系统调用接口”开发出的程序/服务来满足用户日常工作。 shell“Shell“——也可称为“壳”，充当人与内核（硬件）的翻译官，用户将一些命令“告诉”Shell，它就会调用相应的程序服务执行工作，现在许多热门Linux系统主流默认字符Shell是Bash（Bourne-Again SHell）。因此shell 的最简单的定义就是—命令解释器(Command Interpreter) 将使用者的命令翻译给核心处理，同时将核心处理结果翻译给使用者 每次完成系统登入(login)，就会取得一个互动模式的 shell ，也称为 login shell 或 primary shell。 若从进程(process)角度看，我们在 shell 所下达的命令，均是 shell 所产生的子进程，这种现象可称为 fork 。 如果是执行脚本(shell script)的话，脚本中的命令则是由另外一个非互动模式的子 shell (sub shell)来执行的。也就是 primary shell 产生 sub shell 的进程，sub shell 再产生 script 中所有命令的进程。 kernel 与 shell 是不同的两套软件，而且都是可以被替换的 不同的操作系统使用不同的 kernel 在同一个 kernel 之上也可使用不同的 shell 在 linux 的预设系统中，通常都可以找到好几种不同的 shell ，且通常会被列于/etc/shells当中。不同的 shell 有着不同的功能，且也彼此各异、或说”大同小异”。 常见的 shell 分类主要分为两大主流 sh burne shell (sh) burne again shell (bash)大部分的 Linux 系统的预设 shell 都是 bash ，其原因大致如下两点： 自由软件 功能强大 csh c shell (csh) tc shell (tcsh) korn shell (ksh) shell和其他语言的差别 严格意义上讲，shell不属于编程语言，shell脚本是由命令的堆砌而成 shell的优势在于处理操作系统底层的业务，一键安装、报警脚本，常规的业务应用，并且开发简单高效 其他语言类似php、python是严格意义上的编程语言，优势在于开发运维工具，web界面的管理工具等]]></content>
      <categories>
        <category>shell基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell编程基础知识]]></title>
    <url>%2F2015%2F06%2F30%2F2015-06-30-111410-shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[ShellLinux系统中的shell是一个特殊的应用程序，它介于操作系统内核与用户之间、充当一个“解释器”的角色负责接收用户输入的操作指令并进行解释将需要执行的操作传递给内核执行并输出执行结果。 编译器与解释器 基本编程语言分为三类:机器语言、汇编语言、高级语言。 高级语言按照类型分，又分为静态语言和动态语言。 不管静态语言还是动态语言根据编程方式又分为面向过程编程和面向对象编程。 静态语言 编译型语言； 程序执行前需要使用编译器事先转换成可执行格式； 属于强类型变量，就是指变量在使用前必须提前声明甚至还需要初始化（初始化值为0或1） 编译型语言：C、C++、JAVA、C#等等。 动态语言 解释型语言； 程序利用解释器边解释边执行，不需要提前编译； 属于弱类型变量，就是指变量用时声明甚至不需要定义类型（Shell中默认都是字符串） 解释型语言：asp、asp.net、shell、php、python、perl等 面向过程就是把编程立足点主要用于问题解决过程本身；也就是以指令为中心，由指令处理数据，如C、shell。 面相对象就是把我们要实现的项目抽象为一个个对象来完成，以数据为中心，所有代码都围绕数据展开，如java、python（Python既是面向过程又是面向对象）。 Shell脚本基本格式123#!/bin/bash# This is a shell-scriptecho "Hello world!" 第1行很重要，它给shell一个很重要的线索，告诉它用什么程序来解释这个脚本，在这个列子中用的是/bin/bash。其他脚本语言例如perl、awk、python等都是采用这种机制。 第2行是注释，在#符号后面的东西，bash都视而不见给忽略掉。 第3行就是shell脚本要执行要解释的指令了。 第一行的#很重要，第二行的#号是注释。都是#号开头，区别在于位置和“!”号，第一行的#号后面接着一个!号，这个就是脚本解释程序的声明指令，由调用这个脚本的shell来检测。它仅在脚本程序的第一行有效。 执行shell脚本的方式 用法 123$ bash [OPTIONS] firsh.sh-n：测试脚本是否有语法错误-x：显示脚本执行的详细过程 示例 123# 直接执行脚本文件或在当前路径下执行，脚本需要有执行权限;$ /etc/rc.d/init.d/network$ ./firsh.sh]]></content>
      <categories>
        <category>shell基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vi与vim入门指北]]></title>
    <url>%2F2015%2F06%2F25%2F2015-06-25-223610-vi%E4%B8%8Evim%E5%85%A5%E9%97%A8%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[第一部分 基础与高级的vi第一章 vi文本编辑器vi编辑器通常被简称为vi，而vi又是visual editor的简称 。它在Linux上的地位就像Edit程序在DOS上一样。它可以执行输出、删除、查找、替换、块操作等众多文本操作，而且用户可以根据自己的需要对其进行定制，这是其他编辑程序所没有的。 vi 编辑器并不是一个排版程序，它不像Word或WPS那样可以对字体、格式、段落等其他属性进行编排，它只是一个文本编辑程序。没有菜单，只有命令，且命令繁多。vi有3种基本工作模式：命令行模式、文本输入模式和末行模式。 打开与关闭文件可以使用vi编辑任何文本。vi将要编辑的文件复制到缓冲区(内存中另外设置的暂存本地磁盘内容的部分)，显示缓冲区(虽然一次只能看到一个屏幕大小的部分)，并且让你增加、删除与修改文本。存储编辑的结果时，vi则把缓冲区的内容写回到磁盘中，替换同名的旧文件。需要注意的是，你永远是在缓冲区里的文本副本上操作，除非存储缓冲区，否则编辑结果不会影响原始的文件。存储编辑的结果也称为“写入缓冲区”或是更常见的“写入文件”。 打开文件vi是调用vi编辑器、编辑新旧文件所用的Unix命令。vi命令的语法是： 1vi [filename] 上述命令行中出现了中括号，表示括号中的filename是个可选项，可有可无，方括号本身不用输入。 如果省略filename，vi会打开一个未命名的缓冲区。我们可在将缓冲区的内容写入文件时进行命名。 尽量保持一个良好的习惯，现在命令行中给出文件名 在目录中打开新文件时，应该在vi命令中加上新的文件名。例如要在当前目录打开一个名为practice的文件，应该输入： 1vi practice 因为这是个新文件，缓冲区是空的且屏幕的显示如下： 1234~~~"practice" [New File] 最左边的波浪符（~）表示文件中没有文本，连空白行都没有；底下的提示符（也称为状态行）显示了文件的名称与当前的状态 你也可以编辑任何目录中的现有文本文件，只要指定文件名即可。假设有个文件位于/home/john/letter。如果你已经在/home/john目录中，可以使用相对路径名称：vi letter即可把letter文件的内容显示到屏幕上；如果你位于其他目录下，则需要使用完整的路径名称：vi /home/john/letter 打开文件时发生的问题 调用vi时，出现[open mode]消息。你的终端类型可能未正确识别。立刻输入:q离开这个编辑会话（editing session）。检查$TERM环境变量，它应该设置为你的终端名称，也可以查询你的系统管理器，已提供正确的终端类型设置。 见到下列任何一种消息：可能是终端类型没有定义，或是terminfo或termcap项中有错误。输入:q离开。检查$TERM环境变量，或要求系统管理为你的环境选择一个终端类型。 123456Visual needs addressable cursor or upline capabilityBad termcap entryTermcap entry too longterminal: Unknown terminal typeBlock device requiredNot a typewriter 当你认为文件已存在时，却出现[New file]消息确认文件的大小写是否正确（Unix严格区分文件名的大小写）。如果正确，很可能位于错误的目录。输入:q离开。检查是否位于正确的目录（Unix提示符下使用pwd命令）。如果位于正确的目录中，则检查目录中的文件列表（使用ls），以确定是否有个名称只差一点点的文件。 调用vi，却得到:提示符（表示你在ex行编辑模式中）你可能在vi重绘屏幕前将其中断了。在ex提示符（:）下输入vi以进入vi。 出现以下消息之一“Read Only”表示你只能查看文件，而不能保存任何更改。你可能在查看模式（view mode，使用view或vi -R）中调用了vi，或者你对文件没有写入权限。 123[Read only]File is read onlyPermission denied 出现以下消息之一你要调用来编辑的文件不是常规的文件。输入:q!强制退出，再检查你要编辑的文件，可以使用file命令 1234567Bad file numberBlock special fileCharacter special fileDirectoryExecutableNon-ascii filefile non-ASCII 当你遇到上述困难而输入:q后，却出现以下消息表示你更改了文件却未写入文件，而自己还不知道，输入:q!强制退出。你所做的改变将不会保存到文件中 1No write since last change (:quit! overrides). 打开文件时，提示以下信息 该文件可能正在被其他人编辑 找到编辑人员请他退出当前的vim操作 或使用『O』使用只读模式查看文件内容 该文件可能在编辑过程中出现异常中断或退出 如果你之前的 vim 编辑操作尚未保存，此时应该按下『R』，亦即使用 (R)ecover， 此时 vim 会载入 .swp文件 的內容，让你自己来决定是否需要存储。不过那个swap文件并不会在vim编辑操作退出后自动删除，所以你离开vim后需要自行手动删除，否则每次打开这个文件都会出现这样得警告 如果你确定这个.swap文档存储没有用的，那么你可以直接按下『Q』退出vi，手动删掉这个.swap文件，重新使用vi编辑即可 123456789101112131415161718192021E325: ATTENTIONFound a swap file by the name "/tmp/.a.swp" owned by: root dated: Wed May 3 14:11:29 2017 file name: /tmp/a modified: no user name: root host name: CentOS-6.8 process ID: 104610 (still running)While opening file "/tmp/a" dated: Wed Apr 26 18:47:13 2017(1) Another program may be editing the same file. If this is the case, be careful not to end up with two different instances of the same file when making changes. Quit, or continue with caution.(2) An edit session for this file crashed. If this is the case, use ":recover" or "vim -r /tmp/a" to recover the changes (see ":help recovery"). If you did this already, delete the swap file "/tmp/.a.swp" to avoid this message.Swap file "/tmp/.a.swp" already exists![O]pen Read-Only, (E)dit anyway, (R)ecover, (Q)uit, (A)bort: 操作模式 模式有两种：命令模式（command mode）和插入模式（insert mode）。一开始是命令模式，此时所有的的按键都是命令；而在插入模式中，你输入的东西都将称为文件的内容。 有时你可能意外地进入插入模式；或是反过来，意外地离开插入模式。无论何种情况，输入的 内容可能影响文件，但不是你想要的结果 按下Esc键或Ctrl+[则会强制vi进入命令模式。如果你已经处于命令模式，vi会在你按下Esc时发出”哔“声（因此命令模式有时被称为”哔哔模式“） 一旦安全地进入了命令模式，即可手动修复意料之外的改变并继续编辑文本 保存与退出文件 你可以随时退出正在编辑的文件，保存编辑结果，并回到Unix命令行模式下。vi用于离开并保存编辑的命令是ZZ，请注意ZZ两个字母均为大写 假设你创建了一个名为practice的文件用于练习vi，并输入了6行文本。想保存这个文件时，首先按下Esc以检查是否处于命令模式中，而后输入ZZ 你也可以用ex命令保存编辑结果。输入:w是保存（写入）文件但不退出vi；若无编辑动作，可输入:q退出；输入:wq或:x，则是保存编辑结果并离开vi :wq与ZZ相等，不论文件内容是否发生改变，退出时更新文件的(Modify、Change)时间属性；而:x则只在文件内容发生过改变，退出文件时才更新（Modify、Change）时间属性，否则不更新；二者均会更新（Access）时间属性。可使用stat命令进行验证 退出而不保存编辑结果 有两个ex命令可以帮你轻松地将文件恢复到原来的样子 想要撤除所有的编辑结果，恢复到上一次保存文件时的状态，使用命令:e!然后回车 取消所有的编辑结果，然后直接退出vi，使用命令:q! 这两个命令，所有上一次存档后仍在缓冲区的编辑动作都会消失。vi一般不会让你放弃编辑结果，在:e与:q命令后的感叹号可以使vi不理会这个禁令，即使缓冲区有所改变，仍然会执行这两个命令 保存文件时发生的问题 尝试写入文件，却出现以下消息输入:w!以覆盖现有的文件，或者输入:w newfile将编辑的结果写入一个新文件。 1234File existsFile file exists - use w![Existing file]File is read only 你想写入文件，却没有写入权限，并得到”Permission denied“消息输入:w newfile将编辑的结果写入一个新文件。如果你拥有目录的写入权限，则可使用mv将原来的文件用新文件替换。如果你没有目录的写入权限，则输入:w pathname/file，将缓冲区写入某个你拥有写入权限的目录（如你的主目录或是/tmp） 尝试写入文件，却得到文件系统已满的消息 输入:!rm junkfile来删除一些不需要的大文件，腾出一些空间（在!后开始ex命令便可以使用Unix命令） 或者输入:!df -h看看其他文件系统有没有空间。如果有的话，则在其他文件系统中选择一个目录，用:w pathname/file写入你的文件 系统进入开放模式并且显示文件系统已满 vi用于临时文件的磁盘已满。输入:!ls /tmp查看有无可以移除的文件，以腾出一些空间。如果有的话，先创建一个临时的Unix shell，以便移除文件或发出其他Unix命令。 你可以输入:sh或:bash，创建一个shell；按下Ctrl+D或输入exit，结束shell并退回vi 在现在Unix系统上，当使用作业控制的shell时，你只需输入Ctrl+Z来暂停vi，即可回到Unix命令行模式，再输入fg即可回到vi。腾出空间后使用:w!写入文件 第二章 简单的文本编辑vi命令 vi有两种模式：命令模式与插入模式。你刚进入vi时，是处于命令模式，编辑器正在等你输入命令。命令可以让你移动到文件的任何地方进行编辑，或者进入插入模式以增加新文本。命令也可以用来结束编辑（保存或忽略编辑结果），回到Unix提示符。 你可以将两种模式想象成两套不同的键盘。在插入模式中，键盘就像是打字机，而在命令模式中，每一个键都有新的意义或用于开始某些指令。 有好几种方法可以用于告诉vi你要进入插入模式，最常见的一种就是按下i。i不会显示在屏幕上，但是按下它以后，所有你输入的东西都会显示在屏幕上并且会进入缓冲区。光标会置于当前插入的点。如果要告诉vi你想停止插入文本，则按下Esc，光标将往回移动一个字符（因此会位于你输入的最后一个字符上）并回到vi的命令模式。 当你打开新文件时，vi会进入命令模式，并将第一个按键（i)当作插入命令|其后所有的按键都被视为文本，直到按下为止。如果需要在插入模式中修改错误，只要按退格键后将错误去掉即可。依照终端类型的不同，退格键可能会消除原来输入的文字， 也可能只是后退而已。无论如何，退格键经过的内容都将被删除。请注意，你不能用退格键到达进入插入模式的那一点之前。按ENTER则换行。 有时你会不知道是位于插入模式还是命令模式。当vi所做的事不合乎你的预期时，先按 Esc 一两次，査看你位于何种模式。如果听到“哗”声，表示位于命令模式。 移动光标你在做编辑工作时，可能只有一小段时间是在插入模式下增加新文本，大部分的时间都是在编辑现有的文本。vi移动光标的命令包括： 上、下、左、右键一次一个字符（character)。 前进或后退一个文本块（text block)——一次一个单词、句子或段落。 在文件中一次一屏（screen)地前进后退。 下图中下划线指示了光标现在的位置，圆圈表示各种vi命令会将光标移动到的地方 单一的移动 h、j、k、l，这4个位于键盘中心的键可以移动光标 h 向左一个字符 j 向下一个字符 k 向上一个字符 l 向右一个字符 也可以使用 ← ↑ ↓ → 做上下移动，或用ENTER与 BACKSPACE键，但是这种方法比较少用。一开始，你也许会觉得用字母代替方向键来移动光标很奇怪，然而过一会，你便会发现这是vi最令人喜爱的一点——不需要让你的手指离开键盘的中心，就可以到处移动光标。 在移动光标前，先单击Esc以确定处于命令模式。使用h、j、k、l移动光标。当你往一个方向移动到极限时，会听到蜂鸣声，而光标会停止移动。例如，当你位于一行的开头或是结尾时，就不能用h或l移动到上一行或是下一行，必须使用j或k 。 同样地，你不能将光标移到超过波浪符（〜）的地方，就是没有文本的行；也不能移到第一行文本之前。 数值参数你可以在移动命令的前面加上数字。命令4l把光标向右移4个字符，就像 按了4次l一样（llll)。这种可将命令重复多次的功能会给你更多的选择，并增强命令的功能。接下来，在接触 更多命令时，也应该牢记这一点。 在一行中移动保存了practice文件后，vi会显示一个消息，告诉你这个文件中有多少行。这里的行不一定与屏幕上可见的行（通常限制在80个字符）一样长，而是表示在换行符（newline) 间的任何文本(换行符会在你处于插入模式并按下ENTER键时被插入文件)。如果你输 入200个字符后才按下ENTER键，vi就把所有200个字符当成同一行（即使这200个字符 在屏幕上看起来是好几行）。 vi可以设置与右边界的距离，以便自动插入换行符。这个选项是wrapmaigin (简写为wm),你可以将它设为10个字符，这个命令不会影响已经输入的行。 1:set wm=10 如果你没有设置vi的wrapmargin (环绕）选项，则必须手动使用换行符来换行，让一行 的长度保持在可以接受的范围。 有两个用于在一行中移动的命令是： 0移到一行的开头$移到一行的结尾 下面的范例中，显示了行编号（使用number选项可在vi中显示行号，在命令模式中输 入：set nu即可设置这个选项。详细内容将于第七章中介绍）。其中逻辑上的行数（3）和屏幕上见到的行数（6）是不一样的。如果光标位于delete 的d上时，你输入了$，则光标会移到Mem后面的句点上，如果输入0，光标会回到第二行开头move的m上面。 按照文本块来移动 你可以依照文本块来移动光标：单词、句子或是段落都可以。w命令使光标移动一个单 词，符号与标点也算是一个单词。以下呈现w的光标移动： 你也可以不算符号与标点，只将光标移动到下一个单词，此时要用W命令（可以想象成“大的”或“大写的”Word)。使用W做光标移动的结果如下： 若想后退一个单词，应该使用b命令。大写的B则是倒退一个单词，但不把标点、符号视为单词。 前面提过，移动命令可接受数值参数，因此不管是W或b命令，都可以用数值将其重复多次。2W把光标往前移动2个单词；5B会往回退5个单词，但不算标点、符号。 若想移动到特定一行时，你可以使用G命令。只按G将移动到文件的结尾，1G则可到达文件的顶端，42G可移动到第42行。 简单的编辑当你在文件中输入文字时，很少一次就能尽善尽美，可能会有错字或者想修订词句|有时你的程序也会有错误。在输入文本之后，你应该可以对它们更改、删除、移动或复 制。图2-3显示了我们可能想做的文件编辑工作，并且用校对符号标示出来。 在vi中，只要几个简单的键，就可以做出这些动作：i表示插入，a表示添加，c表示更改，d表示删除。移动与复制文本，则需要用到两个命令。移动时先用d做删除，再用p 进行放置；复制时先用y做“拖曳”的动作，再用p进行放置。这些编辑动作将在后续章 节中一一解说。图2-4把图2-3中标示的校对动作显示为相应的vi命令。 插入新文本你已经见过用来在新文件中输入文本的插入命令。但你也会在编辑现有的文本时使用插入命令，以加入漏掉的字符、单词或句子。假设practice文件有下列句子：光标的位置如上图所示。要在这个句子的开头插入“With a screen editor”，则需要如下的输入： 附加文本a你可以在文件中任何地方用附加命令a来附加文本。a与i的用法几乎都相同，除了前者是在光标后面插入文本，而后者是在光标之前插入文本。你可能注意到，当按下i 进入插入模式后，光标不会移动，除非插入一些文本。然而，当你按下a进入插入模式 时，光标会往右移一个字符，你输入的文本将在原来的光标位置的后面出现。 更改文本c需替换文件中的文字时，可以用更改命令c。为了告诉c有多少文本需要更改，可以把 C与光标移动命令一起使用。此时，将把光标移动命令视为命令c会影响的文本对象。例 如，c可以用来更改光标所在位置的文本： 12345678cw从光标到这个单词的结尾c2b从光标往前两个单词c$从光标到本行结尾c0从光标到此行的开头 在下达更改命令后，你可以将标示出的文本用任何数量的新文本替换，像全部空白、一个单词或是几百行文本都可以。c与i、a—样，在按下Esc键前，都会停留在插入模式。 当这些更改只影响当前这一行时，vi将在被更改文本的结尾显示$,因此你可以看到这一 行的哪些部分将被影响（参阅以下的cw范例）。 单词要更改一个单词，可用c （更改）命令结合表示单词（word）的w命令。你可以将一个单词换成（cw）更长或更短的单词（或任何长度的文本）。cw可被想成“删除标示出的单词，再插入新的单词，直到按下Esc为止。 假设文件practice中有如下文本行： 1With an editor you can scroll the page, 如果想将an改为a screen，你只需要更改一个单词 cw也可以用于更改单词的一部分。例如，要将spelling改成spelled，可以将光标移到 i 上，输入cw，再输入ed，接着用Esc结束。 整行cc如果要更改当前这一整行的内容，有一个特殊的更改命令：cc。cc会将一整行换成任何输入的文本，直到按下Esc为止。原本的光标位罝并不重要，cc会直接换掉整行文本。 123456789101112131415Vi命令的一般形式就当前提到的更改命令而言，你可能发现了如下模式： &#123;command) text objectcommand部分是更改命令c，text object (文本对象）则是光标移动命令。但c不是唯一需要文本对象的命令。d (删除）命令、y (拖曳）命令都适用这种形式。另外要记住的是，光标移动命令可使用数值参数，因此可将数值加在c、d、y等命令的文本对象上。例如d2w与2dw都是刪除两个单词的命令。记住这一点后，你会发现大部分的vi命令遵循如下模式： &#123;command)(number)text object或者相等的模式： (number)(command)text object它们的工作方式是这样的：number与command为可选项。如果没有这两部分，只是单纯的光标移动命令；如果加上number，则出现移动多次的效果；结合commaw (c、d、y等等）与text object，则会得到编辑命令。 前者用在任何影响范围不到一整行文本的更改，而后者则用在影响一行文本以上的更改。 C可更改光标所在位置到此行结尾间的文本。它的功用和c加上特殊行末指示符$的效果一样（c$)。 cc与C命令实际上是其他命令的简写，因此不符合Vi命令的一般形式。在讨论删除与拖曳命令时，会提到更多简写 字符r另外一种更改的方法是r命令。r把一个字符替换成另一个，结束后，不需要按ESC回 到命令模式。假设下面这一行文本有一个拼错的地方：1Pith a screen editor you can scroll the page, 只有一个字符P需要更改。在这里你不想使用cw，因为你不想重打整个单词。可用r命令来更改光标所在处的字符 12rW使用r命令加上要更改的字符W 替换文本s假设你只想更改几个字符，而不是一整个单词，使用替换命令（s）即可实现。其本身会替换一个字符，而在前面加上数值后，即可替换许多个字符。像更改命令（c）一 样，被替换的最后一个字符会用$标示出，以便査看有多少文本会被替换 S命令，就像其他的大写命令，可以更改一整行文本。它与C命令略有不同——C命令会更改从光标所在位置直到该行结尾间的文本，S命令则不管光标位于哪里，都会整行删除。然后vi把光标移到此行开头并进入插入模式。在S命令前面加上数值可以替换许多行。 s与S都会让你进入插入模式，而当你结束新文本的输入时，按ESC。 R命令和对应的小写命令一样，用来替换文本。不同之处在于，按下R会进入覆盖模 式，你输入的字符将逐一覆盖屏幕上的字符，直到按下ESC为止。R命令最多只能覆盖 一整行：当桉下Enter时，vi会打开新行并进入插入模式。 更改大小写~更改字母的大小写是一种特殊的替换。波浪号（~）命令可将小写字母改成大写的， 或者将大写字母改成小写的。将光标移到你要更改的字母上并输入~，这个字母的大小写就会改变，而光标移到下一个字符。 在旧版的vi中，你不能为~指定数值参数或文本对象，而新的版本已经接受数值参数了。 如果你要一次改变一行以上的文本的大小写，则必须使用Unix命令（如tr)来过滤文本。 删除文本d文件中文本的删除可使用d命令。就像更改命令，删除命令也需要文本对象（用于表示要处理的文本对象)。你可以删除单词（dw)、删除一行（dd与D)，或使用稍后学到的其他移动命令。 删除文本时，先将光标移到删除开始的地方，再输入删除命令（d）及文本对象，例如 用w表示单词。 单词dw假设某文件中有下列文本 光标的位置如上所示，你想要删除第一行中的一个are。 按键顺序结果 dw会删除光标所在位置的单词，请注意单词后的空白也会被删除。 dw也可以用来删除单词的一部分。在下例中：你想删除单词allowed后面的ed， dw总是会将此行中下一个单词前的空白删除，但是我们在上一个例子中并不希望如此。 若要留下单词间的空白，应该使用de，它只会删除到单词本身的结尾，dE删除的范围则是到包括标点在内的单词结尾。 你也可以向前删除（db）或者删除到一行的结尾或开头（d$或d0） 整行dd命令删除光标所在行的一整行内容，它并不会只删除部分行。像cc一样，dd是个形式特殊的命令。利用前面范例中的文本，并将光标放在第一行，如下所示：你可以删除开头两行 D命令会删除从光标所在位置到本行结束间的文本（D是d$的简写）。例如，光标位于如下所示的位置：你可以从光标开始删除文本到本行结束: 字符x通常我们只想删除一个或两个字符。就像有替换单一字符的特殊更改命令r，当然也有特殊的删除命令x，它只会删除光标所在位置的字符。在下面这一行中： zYou can move text by deleting text and then 你可以按下x以删除z。大写的X则删除光标前的字符。在这些命令前面加上数值可以删除多个字符。例如，5x会删除从光标所在之处开始往右的5个字符。 删除文本时发生的问题你误删了文本，想要补救。 有好几种方法可以恢复被删除的文本。如果你刚刚删除一些东西，但马上就发觉 了，只要输入u就可以撤销上一个命令（如dd)。但这只适用于尚未下达其他命令的时候，因为u只会撤销最近一个命令。另一方面，U会恢复一整行成原来面貌，就是做任何改变之前的样子。连续多次输入u则会一步一步向以前撤销 你也可以使用p命令，恢复最近几次的删除动作，因为vi会将最近9次的删除动作保 存在9个编号的删除缓冲区中。举个例子，如果你知道要恢复的缓冲区是第三个， 则可以输入：“3p把第三个缓冲区“放到”光标所在的下一行上。 伹这只对删除的一整行才有用。被删除的单词或是一行的一部分都不会被保存到缓 冲区中。如果你要恢复一个单词或一整行的一部分，而且u命令没有用，请单独使用p命令。它会恢复所有你刚刚删除的内容。后续章节会谈到更多关于命令u与p的 内容。 请注意，Vim支持“无限”恢复（infinite undo)，挽救失误因此简单多了。 移动文本在vi中，采用“删除后再置放文本”的方法使文本移动，就像使用“剪切与粘贴”一 样。每次移动一个文本块时，文本块会先被删除，再存储在特殊的缓冲区中：接着移动到另一个位罝，并被放置（put）命令（p）放在新的位置。虽然移动对一整行文本比单词有用， 伹还是可以移动任何的文本块。 p放置命令（p)会将缓冲区的文本放在光标后，大写的P命令则把文本放置在光标前。 如果你移动了一行以上的文本，p命令把移动的文本放在光标后的新一行（或很多行）；如果你移动的文本不到一行，p命令把移动的文本放在光标之后的同一行。 假设practice文件中有下列文本: You can move text by deleting it and then,like a “cut and paste,”placing the deleted text elsewhere in the file.each time you delete a text block. 你想将第二行的like a “cut and paste” 放到第三行之后，使用删除就可以做到: 注意：一旦删除文本后，你必须在发出下一个更改或删除命令前恢复文本。如果你做了另一个会 影响缓冲区的编辑动作，删除的文本就会消失。你可以一直重复放置的动作，只要不做新 的编辑动作即可。 对调两个字母你可以用xp (删除一个字符，再放到光标后面）来对调两个字母。例如，在mvoe这个词 中，m的位置应该相反才对。要更正这个错误，将光标放在v上并按下x，接着按p。可用transpose的（对调）这个单词帮助记忆xp这个命令：x表示trans，而p表示pose 复制文本 将一段文本复制下来再于別的地方使用，常常可以节省编辑（与按键）的时间。使用 两个命令——y （拖曳）与p （放置），就可以复制任何数量的文本，并放置到另一个地方。拖曳命令会将选中的文本放到特殊的缓冲区中，一直保留到下一个拖曳命令（或删除命令）发生为止。你可以用放置命令将这些文本放到文件的任何地方。 就像更改与删除命令一样，拖曳命令可与任何光标移动命令合并使用（如yw、y$、 4yy)。拖曳命令最常用在一行（或更多行）文本上，因为拖曳并放置一个单词通常比直接插入单词还要花时间。 快捷键yy用于拖曳一整行的文本，就像dd与cc一样。但是，另一个快捷键Y因为某些原因，它的操作方法并不像D与C，不会拖曳从光标所在位置到一行结尾的文本，而是拖曳 一整行，即Y与yy的行为完全一样。 假设practice文件中有以下文本: With a screen editor you canscroll the page.move the cursor.delete lines. 你想要造出三个完整的句子，都以With a screen editor you can 作为幵头。此时不需要在文件中到处移动或重复地输入相同文段，而可以使用拖曳与放置命令。 拖曳与删除命令共享同一个缓冲区。每一个新的删除或拖曳动作都会覆盖缓冲区的内容。在后续内容将看到，放置命令最多可用9个拖曳或删除缓冲区中的内容。你也可以直接将拖曳与删除的内容放到26个已命名的缓冲区，以便处理多个文本块。 重复或撤销上一个命令每一个编辑命令均存储到一个临时的缓冲区，直到发出下一个命令为止。例如在某个单词后插入the。用于插入的命令与插入的文本都会暂时被存储起来。 重复想要重复相同的编辑命令时，可以使用重复命令——句号（.），以节省时间。将光标移到欲重复前一编辑命令的地方，再输入一个句号。 旧版本的vi在重复命令上有问题。例如，在设置了 wrapmargin 的情况下，这些版本可能在重复长文本的插入时发生困难。如果你使用的是这种版本的vi，迟早会发现这个问题的害处。此时你也没有办法补救，不过事先得到警告总是好的（新版似乎没有这个问 题）。有两个方法可以预防在长文本插入时可能发生的问题。你可以在重复插入命令之 前先写入文件（：w），以便在出问题时取回原来的文件，或把wrapmargin设置取消（：set wm=0） 撤销前面提过，如果出了错误操作，可以撤销上一个命令。只要按下u即可，光标不需要在原来下命令时所在的位置。 大写字母U会撤销所有对同一行的编辑动作，只要光标还在这一行即可。一旦你移到别的行，就不能使用U了。 注意，你可以用u撤销上次“撤销”的动作。u也可以撤销U；而U会撤销所有在同一行中的更改，包括u在内。 注意：小秘诀：因为u可撤销自己，这样就产生一个在文件中移动的巧妙方式。如果你想回到上一 次暂停编辑的地方（称为A点），只要撤销即可。当你再撤销这次撤销动作时，仍会待在A 点，而不会跳到撤销文本的最末端。 Vim让我们用“重做” （redo） —次撤销操作。结合无限次撤销，你将可在文件更改的历史记录中倒退或前进。 更多插入文本的方法你可以用以下命令在光标之前输入文本： i 在光标前插入文本 a 在光标后插入文本 A 在一行的结尾处附加文本 I 在一行的开头处插入文本 O 在光标所在位置的下一行打开新行 o 在光标所在位置的上一行打开新行 s 删除光标所在位置的字符后再替换文本 S 删除一整行后再替换文本 R 用新的字符覆盖现有的字符 上述所有命令都会让你进入插入模式。在插入文本后，记得按ESC回到命令模式 A (附加）与i (插入）可以节省进入插入模式前将光标移到一行开头或结尾所花的时间 (A命令比$a省下一次按键。虽然一个按键可能不算什么、但是在你越来越熟悉编辑工作与不耐烦时，你会想省略更多按键）。 o与〇 (打开）可以节省按下回车键的动作。你可以在一行的任何位置使用这些命令。 s与S (代换）可以让你删除一个字符或一整行，并用任何数量的文本代换。s等效于c加上两冽SPACE键，而S与cc等效。s最方便的用处之一是将一个字符换成多个字符。 R在你想更改文本但不知道确实数董时很有用。例如，你不用猜是用3cw或4CW,只要输入 R后再输入要替换的文本即可。 插入命令的数值参数 除了o与O，以上的插入命令（包括i与a)都接受数值参数。通过数值前缀你可以用i、I、a、A等命令插入一整行的下划线或其他字符。例如，输入50i*Esc会插入50个星 号；输入25a*-Esc则会插入50个字符（25对星号与连字符的组合），这样就不必重复 输入许多字符了 使用数值参数后，r会将许多字符替换成重复的单一字符。例如，在C或C++代码中，如 果要将 || 换成 &amp;&amp;，只要将光标放在第一个丨字符上，再输入2r&amp;。 你也可以在S前加入数值参数以替换许多行。不过，使用c加上光标移动命令更为快速， 并且更有灵活性。 有个适合使用数值参数加上s命令的例子：当你要更改单词中的几个字符时，输入r是不 适合的，输入cw又会变更太多文本，而数值参数加上s的作用通常与R—样。 当然还有其他的命令可以自然地组合起来。例如，ea可以用来将新的文本加到一个单词的后面。训练自己记得这些常用的命令组合，变成反射动作，对你将大有帮助。 用J合并两行在编辑文件时，有时在最后会剩下一些短行，造成阅读困难。当你需要将两行合并成 一行时，可将光标移到第一行的任何地方，然后按J来合并两行。 在J前使用数值参数可以将多个连续的行合并起来。使用命令3J可合并三行。 问题集你输入命令时，文字出乎意料地在屏幕上到处乱跑，一切的运作都不如预期。确定你输入了j,而不是输入了〕。 你可能按了CAPSLOCK键却没有注意到。vi对大小写很敏感，也就是说，大写命 令（I、A、])与小写命令u、a、j)是不一样的，因此按下后输入的所有命令都会被当成大写命令。请按CAPSLOCK键回到小写状态，再按Esc确定你处干命令模式，然后可输入u以恢复上一行的改变，或者输入u以撤销上一个命 令。你可能需要做一些额外的工作，才能恢复刚才弄乱的部分。 基本vi命令的复习第三章 快速移动位置根据屏幕来移动当你在看书时，你会以页码确定在书中的“位置”，例如，你停下来的那一页或是索引 中的某个页码。在编辑文件时，可没有那么方便：有些文件只有几行，一眼就可以看完：但是许多文件却有几百（甚至几千）行！ 你可以将文件想象成有文字的长卷轴，而屏幕是一个窗子，（通常）可以显示其中24行 的文字。 在插入模式中，如果输入了一整屏的文字并输入到屏幕最底行的结尾，这时按下ENTER， 则最上面一行就看不见了，同时会有一行空白行出现在屏幕的最下面，用来输入新的文 字。这称为滚动（scrolling)。 在命令模式中，你可以往前或往后滚动，以便观察文件中的任何文字。而且，光标移动命令可加上数值参数，以便快速地在文件各处移动。 以下是在文件中往前或往后滚动整屏或半屏的Vi命令:Ctrl+f 往前（下）滚动一整屏(Scroll forward one screen)Ctrl+b 往后（上）滚动一整屏(Scroll backward one screen)Ctrl+d 往前（下）滚动半屏(Scroll forward half screen (down).)Ctrl+u 往后（上）移动半屏(Scroll backward half screen (up).) 还有两个命令分别可将屏幕往上滚动一行（Ctrl+e)或往下滚动一行(Ctrl+y）。然而，这两个命令不会将光标移到一行的开头。在执行命令后，光标会出现在上（下）一行中的同一个地方。 滚动一整屏用z重新调整屏幕位置如果要往上或往下滚动屏幕，但是又想让光标维持在原来的文本行，就可以用z命令z ENTER将光标移到屏幕顶端并滚动屏幕z.将光标移到屏幕中心并滚动屏幕z-将光标移到屏幕底端并滚动屏幕 使用z命令加上数值参数可重复多次移动，但其实没有意义（毕竟你只需要将光标移到 屏幕的顶端一次即可。重复相同的z命令并不会再做任何移动）。然而z可以接受行号作为数值参数，指定行将成为新的当前位置。例如，zENTER是将当前行移到屏幕顶端, 但是200zENTER则会把第200行移到屏幕顶端。 重画屏幕Ctrl+L 有时当你正在编辑时，计箅机会显示一些消息在屏幕上，这些消息不是编辑缓冲区的一部分，但却会影响你的工作。当系统消息出现在屏幕上时，你需要重画屏幕。 由于当你滚动屏幕时，就会重画一部分（或全部）的屏幕，因此你只需要上下滚动一 次，就可以消除那些多余的消息。当然你也可以输入Ctrl+L ，只重画而不滚动。 在屏幕中移动你可以保持当前屏幕，或保留文件当前的视图，而在屏幕范围中移动光标：H移到屏幕顶端的行。（Move to home—the top line on screen）M移到屏幕中央的行。（Move to middle line on screen）L移到屏幕底端的行。（Move to last line on screen.）nH移到屏幕顶端往下的第n行。（Move to n lines below top line）nL移到屏幕底端往上的第n行。（Move to n lines above last line） H可以将光标从屏幕的任何地方移到第一行，也就是该页第一个字符的位置（home) , M会将光标移到中间那一行；而L会移到最后一行。要将光标移到第一行下面一行，则使用 2H 根据行移动Enter 在当前屏幕中，也有以行为标准进行移动的命令。你已经知道j与k命令了，还可 以用々卩下命令： ENTER移到下一行的第一个字符。+移动到下一行的第一个字符-移动到上一行的第一个字符 上面三个命令会将光标往下或往上移一行，并置于该行第一个字符上，空格或tab （制表符）会被忽略。 在当前行移动不要忘了 h与l可将光标往左与往右移动，而0与$会将光标移到一行的开头与结尾。你也可以用如下命令： ^移到当前行的第一个非空格处。n|移到当前行的第n列。 就像上面的行移动命令一样，^会移到当前行的第一个字符处，忽略任何空格与制表符。相对地，0则会把光标移到当前行的第一个位置处，即使是空格也—样。 根据文本块来移动另一个在Vi文件中移动的方式，则是以文本块为单位——单词、句子、段落或小节。你已经知道如何以一个单词为单位往前或往后移动（w、W、b、B)。另外，你也可以用 下面的命令实现光标移动： e移到单词的结尾。E移到单词的结尾（忽略标点符号）。(移到当前句子的开头。)移到下一个句子的开头。{移到当前这一段的开头。}移到下一段的开头。[[移到当前这一节的开头。]]移到下一节的开头。 vi会寻找？、.、！这些标点符号，以辨认句子的结束。当这些标点符号后面有至少两个空格或是作为一行的最后一个非空格字符时，vi则将其定位为一个句子的结束。如果你在句号后面只留了一个空格或该句以引号结束，则vi不能辨认这个句子。 根据搜索模式的结果来移动/在大文件中移动时，最快速的方法之一乃是搜索一串文本，更正确地说，是搜索特定模式（pattern）的字符。有时搜索操作可以用来找寻拼错的单词或是代码中某个变量出现的所有地方。 搜索命令是特殊字符/(斜线）。当你输入斜线时，其会出现在屏幕底端，接着再输入要搜索的特定模式，格为：/potterrn 模式可以是一个完整的单词，或是一连串字符（称为“字符串”）。例如捜索单词red，搜索结果会找出整个单词red；但是也会找出occurred。如果你在模式前或模式后加上一个空格，则这个空格会被当成单词的一部分。模式输入完后，按ENTER结束命令 (与所有出现在底端的命令一样）。vi像所有其他的Unix编辑器一样，也有一套特别的模式匹配语言，可以让你寻找变动的文本模式：例如，任何以大写字母开头的单词，或是作为一行开头的单词The。 我们会在第六章提到更强大的模式匹配语法。而现在，只要把模式当成一个单词或词组就可以了。 vi会从光标所在位置开始往前搜索，如果需要则绕回文件的开头。光标会移到要捜索的模式第一次出现的地方。如果没有找到，状态行会出现“Pattern not found”的消息 要往回搜索，则不是输入/，而是输入?：? pattern在这两种搜索命令中，如果需要的话，都会绕回文件的开头或结尾。 重复搜索上一次所搜索的模式会留在你的编辑会话中。搜索过后，若要再次搜索上一个模式， 不用重复原来的按键顺序，你可以用一些命令来重复搜索：n往同一个方向重复捜索。N往相反的方向重复搜索。/ENTER往前重复搜索。?ENTER往后重复搜索。 因为上一个模式仍然可用，你可以搜索一个模式后做些其他工作，接着再用n、N、/或? 来搜索同一个模式，而不用重新输入。搜索的方向会显示在屏幕底端（/是往前，？是往后）。（nvi不会ffi示n与N命令的搜索方向。Vim会把要搜索的文本也放在命令行里，让 我们能用上下键滚动査看搜索命令的历史记录。） 有时你只想搜索在光标位置之前的单词，并不想让搜索绕回文件的开头。vi有一个选项 wrapscan，可以控制搜索是否要绕回开头。你可以取消这个功能：:set nowrapscan若设置了nowrapscan，而往前的搜索失败时，状态行会显示如下消息：Address search hit BOTTOM without matching pattern若设置了nowrapscan，而往后的搜索失败时，状态行显示的消息将以“TOP”取代 “BOTTOM”。 通过搜索修改文本/与?搜索运算符可与更改文本的命令结合，例如与c和d结合。延续前例做过的改变： d?move从光标位置开始向前删除到出现move的地方。 请注意，此处的删除是以字符为基础，而不是删除整行。 这一节只介绍了搜索模式最基本的命令。第六章会提到更多关于模式匹配的内容以及模式匹配在对文件做整体改变时的用途。 在当前行种搜索搜索命令也可用于一行内的捜索。fx命令会将光标移到下一个出现x字符的地方（其中x代表任何字符）。tx命令则将光标移到下一个出现的x字符的前一个字符，可以用分号继续搜索出现的x字符。 下面列出了行内搜索命令，这些命令都不会把光标移到下一行。 fx搜索（将光标移到）本行中下一个出现x的地方，x代表任何字符。Find (move cursor to) next occurrence of x in the line, where x stands for anycharacter.Fx搜索（将光标移到）本行中上一个出现x的地方Find (move cursor to) previous occurrence of x in the line.tx搜索（将光标移到）本行中下一个出现x的地方的前一个字符,Find (move cursor to) character before next occurrence of x in the line.Tx搜索（将光标移到）本行中上一个出现x的地方的后一个字符,Find (move cursor to) character after previous occurrence of x in the line.;重复上一个搜索命令，方向相同。Repeat previous find command in same direction.,重复上一个搜索命令，方向相反。Repeat previous find command in opposite direction 在这些命令前加上数值n，则会搜索字符第n次出现的地方。假设你在编辑practice文件的这一行：123456**w**ith a screen editor you can scroll the按键顺序fo With a screen edit**o**r you can scroll the搜索本行中第一个出现的o; With a screen editor y**o**u can scroll the用;命令移到下一个出现0的地方（搜索下一个o）。 dfx会删除到下一个x字符为止的所有文本，包括x字符在内。这个命令在删除或拖曳一行的一部分时很有用。如果在文本中夹有符号或标点而难以计算单词数量时，你可能需要用dfx代替dw。t命令与f命令很像，不同之处在于它把光标放在要搜索的字符之前。例如，命令ct可用于更改一个句子的内容，而留下最后的句号。 根据行号来移动文件中的每一行都会依序编号，可借由指定行编号来移动到文件各处。 行号在辨认一大块文本的开始与结束时很有用。行号对程序员也很有用，因为编译器的错误消息会引用到行号。ex命令也会用到行号，我们将在下一章学习。 如果要依照行号来移动位置，必须有指定行号的方式。使用：set nu选项（第七章会再提到），可以在屏幕上显示行号。在vi中，你也可以在屏幕底端显示现在光标位置的行号。 CTRL+g命令会在屏幕底端显示信息，包括当前的行号、文件的总行数以及当前位置占全文的百分比。以practice文件为例，可能显示：1&quot;practice&quot; line 3 of 6 --50%-- 这个信息不管是在显示行号以用于命令，还是在你忘记位置时指示方向都很有用。 G（转至）命令你可以用行号在文件中移动光标。G (转至）命令接受行号为数值参数，并直接移到指定行。例如，44G会将光标移到第44行的开头。没有指定行号的G则会移到文件的最后。 输入两个反引号（``）会回到原来的位置（即上一次使用G命令时所在的位置），除非你在中间做了编辑操作。如果你做了编辑操作，然后用G以外的命令移动了光标，则 `` 会将光标移回到你上一次做编辑操作时的地方。如果你使用了搜索命令（/或？）， `` 则会带你回到上一次使用搜索命令的地方。一对引号（’’）与两个反引号的功用一样，不同之处在于，它把光标移到前次位置所在行的开头，而不是确实的位置上。 第四章 越过基础的藩篱更多的命令组合 从光标位置到…… 更改 删除 复制 屏幕顶端 cH dH yH 屏幕底端 cL dL yL 下一行 c+ d+ y+ 本行的第五列(第五个字符) c5 d5 y5 往下第二个句子 2c) 2d) 2y) 上一段 c{ d{ y{ pattern模式 c/pattern d/pattern y/pattern 下一个模式 cn dn yn 文件结尾 cG dG yG 第13行 c13G d13G y13G 请注意表中列出的组合都符合一般形式：(number) {command) (text object)其中number是可有可无的数值参数，而command是c、d或y，text object则是一个移动命令。 打开vi的选项到当前为止，你都是用以下的命令打开vi:1vi file 前进到特定的位置当你开始编辑现有文件时，可以先读入文件，再移动到某个模式（pattern）第一次出现的位置或移动到某一行。你也可以在命令行指定第一次移动的方式，例如依搜索结果或行号移动： 123456vi +n file# 打开file并定位到第n行vi + file# 打开file并定位到最后一行vi +/pattern file# 打开file并定位到第一个出现pattern的行 如果你的模式中包含空格，则需用单引号或双引号括起整个模式(注：这是shell的限制，不是vi的限制。) 1+/"you make" 或者用反斜线将空格转义:1+/you\ make 另外，如果你要使用第六章中描述的一般模式匹配语法，可能必须用单引号或反斜线将 一个或多个特殊字符保护起来，以防止shell将其解释成其他意思。 +/pattern在你编辑到一半却必须离开时很有用。你可以将当前位置用某个模式标记起 来，如ZZZ或HERE。当你回来时，只要记得/ZZZ或/HERE就可以了。 注意：当你在vi中编辑时，一般都已打开wrapscan选项。如果你把环境自定义为wrapscan禁用时 (请参考第47页的“重复搜索”小节），可能不能使用这时如果你用这种方法打开文件，vi会将光标罝于文件最后一行，并显示“Address search hit BOTTOM without matching pattern.” （已经寻找至文件末尾，找不到匹配的模式。）。 只读模式有时候你想査看文件，但是又不想在无意间更动文件（例如读入一个很长的文件，用于练习vi的移动命令，或只是想在脚本文件中上下滚动）。此时可以用只读模式打开文件，这时仍可使用所有的vi移动命令，但是不能更改文件内容。 要用只读模式显示文件，应输入以下命令：1vi -R file 或是：1view file (view命令也像vi命令，可以使用任何跳到文件中特定地方的命令行选项（注3)。） 如果你决定要改变文件内容，可以在write命令（：w）后面加上感叹号，以覆盖掉只读 模式：1:w! 或是：1:wq! 恢复缓冲区在你编辑文件时，系统有时可能发生错误，通常，在你上一次存档后所做的更动都会消失。然而，有一个选项-r可以恢复系统死机时的编辑缓冲区。 如果使用传统Unix系统与原始的vi,会于系统重新启动后第一次登录时收到一个邮件消 息，表示缓冲区已经保存起来。而且，如果你输入命令：1ex -r 或是：1vi -r 将得到系统保存下来的所有文件列表。 用-r选项加上文件名可以恢复编辑缓冲区。例如，要恢复系统死机时practice文件的编辑缓冲区，可输入：1vi -r practice 此时最好立刻恢复原来的文件，以免你在无意中又对文件做了编辑，结果你必须在保存的缓冲区内容与新做编辑的文件间解决新旧版本的问题。 使用:pre命令，你可以强制系统即使没有死机也保存缓冲区。如果你编辑了某个文件， 后来发现因为没有写入权限而不能保存时，这就很有用了（你可以将这些内容写入另一 个文件或是另一个你可以写入的目录中。参阅第一章中的“保存文件时发生的问题”一 节） 善加利用缓冲区你已经知道，编辑时的最后一次删除（d或x）或拖曳（y）的内容会保存到缓冲区中（内存中的一块）。你可以访问这些缓冲区并使用放置命令（p或P）将这些保存的文本放回文件中。 vi会将最后9次的删除操作保存在编号的缓冲区中，你可以访问其中任何一个，以恢复任何一次（或所有）的删除操作（然而小规模的删除，如一行中的一部分，并不会保存到编号的缓冲区中。这些删除只能在刚做操作后立刻用p或P命令恢复）。 vi也可以让你将拖曳（复制）的文本放在依字母标识的缓冲区中。拖曳的文本可以被保存到26个缓冲区（a-z）中，并且可在编辑会话的任何时候，使用放置命令来恢复这些文本。 恢复删除一次删除大块文本很方便也很好用，但如果不小心删除了53行重要的数据该怎么办呢？ 有一个办法可以恢复你的前9次删除，因为它们都保存在编号的缓冲区中。最后一次删除的内容存在缓冲区1，倒数第二次的则存在缓冲区2……要恢复删除操作，先输入”（双引号），接着指定缓冲区编号，再使用放置命令。以恢复倒数第二次的删除（位于缓冲区2)为例：1“2p 缓冲区2包含的删除的内容将出现在光标之后。 如果不确定哪一个缓冲区包含了要恢复的文本，你也不用一直重复输入&quot;np。如果在恢复（p）—次后利用重复命令.做恢复，缓冲区的编号便会自动增加，再加上用u撤销 恢复，即可用下例搜索编号的缓冲区：”1pu.u.u依此类推 上例可逐一把每个缓冲区的内容放置到文件中。每一次输入u时，恢复的文本会被移除。输入点号（.）时，则把下一个缓冲区的内容恢复到文件中。不断输入u与.，直到找到所需的文本为止。 将文本拖曳到命名缓冲区中稍早我们学习到，在做任何编辑前，必须先放置（P或P）未命名缓冲区的内容，不然缓冲区的内容就会被覆盖掉。你可以用y与d搭配26个专门给复制与移动文本使用的命名缓 冲区（a〜z)。如果你使用命令缓冲区存放被拖曳的文本，便可以在任何时间取回其中的内容。 要将文本拖曳到命名缓冲区，需在拖曳命令前加上双引号（”）以及缓冲区名称（以字符表示）。例如：12"dyy 将当前行拖曳到缓冲区d中"a7yy 将后续7行拖曳到缓冲区a中 拖曳的内容放至命名缓冲区，移动光标到新的位置后，使用p或P可将文本取回：12"dP 将缓冲区^的内容放置在光标前"dp 将缓冲区a的内容放置在光标后 要将缓冲区文本的一部分取出来，在当前是做不到的，只能选择全部取回或完全不取回。 在下一章中，你会学到如何编辑多个文件。当你知道如何不离开vi也可在文件间切换时，便可以使用命名缓冲区在文件间传送部分文本了。使用其他vi同类品的多窗口编辑功能时，非命名缓冲区也可用于在文件间传送数据。你也可以将删除的文本保存到命名缓冲区中，方法是一样的：1“a5dd 将删除的S行保存到缓冲区备中 如果你用大写字母指定缓冲区名称，则拖曳或删除的文本会被附加到当前缓冲区中。因此可以选择性地做移动与复制。例如： “zd)删除从光标处开始到所在句子的结尾处的内容，并将内容保存到缓冲区Z中。2)往前移两个句子。“Zy)将下一个句子添加到缓冲区z中。你可以继续在某个命名缓冲区中添加更多的文 本，但请注意：如果你一时忘记，在拖曳或删除文本到缓冲区时没有用大写字母指 定缓冲区名称，则会把缓冲区的内容覆盖掉，前面已有的文本都会消失。 对一处做标记在一个vi会话中，你可以在某处做一个看不见的“书签”，然后在别处编辑，完成后再回到“书签”位置。可在命令模式中输入：mx将当前位置标记成x （x可以是任何字符）。‘x（单引号）将光标移到标记x所在行的第一个字符。 `x(反引号）将光标移到x标记的字符。``(两个反引号）在移动位置之后，回到上一个标记或上下文的确切位置。‘’(两个单引号）回到上一个标记或上下文所在行的开头。注意：标记只有在当前vi会话中有用，并不会存储在文件中。 其他高级编辑技巧你可以用vi执行其他高级编辑操作，但是要先学一些ex编辑器的用法，这在下一章会提到。 第五章 ex编辑器概述这是一本vi的工具书，为什么我们要用一整章来介绍另一个编辑器ex呢？其实ex并不算是另一个编辑器。vi其实是更通用、更底层的ex行编辑器的“可视模式”，有些ex命令在vi中很有用，可以节省许多编辑的时间。这些命令甚至大部分可在不离开vi的情况下使用。 你已经知道如何将文件想象成一连串有编号的行。ex可以给你机动性更髙、能力更强的编辑命令。利用ex，你可以轻松在文件间移动，并用各种方法传送文本。你可以快速地编辑超过一整屏幕的文本块。使用全局替换，你可以对整个文件中的某个模式做替换操作。 ex命令我们早已不再用打印终端来编辑文件了，但是有些ex行编辑器的命令仍然可以在复杂的可视化编辑器上使用，因为它们是创建在ex之上。虽然用vi来做大部分的编辑都比较简单，但是ex以行为导向，在对文件做大规模的改变时就成了优点。注意：在本章中所用到的命令，大部分都以文件名为参数。虽然在文件名中加入空格字符是合法 的，但是我们非常不推荐这种行为：e)(会严重混淆，而你在尝试让ex接受这种文件名时， 会碰上很多麻烦。在分隔文件名中的成分时，最好使用下划线、横线或句号，这样会比较 方便使用。 在你开始背ex命令（或者根本就跳过）之前，我们先掲开一些行编辑器的神秘面纱，看看ex如何工作，这样可以稍微了解很难懂的命令语法。 先打开一个你熟悉的文件，用于尝试ex命令。就像你可以用vi编辑器打开文件一样，你也可以用ex行编辑器来打幵文件。打开ex时，会见到一些消息，它列出了文件的总行数以及命令提示符（：）。例如:123ex practice"practice" 6 lines, 320 characters: 你不会看到文件中的任何一行，除非下达显示一行或多行的ex命令。 ex命令中包含了行地址（可以只是一个行号）以及命令，以换行符结束(按ENTER即可）。一个最基本的命令是p，代表打印（到屏幕上）。因此，假设你在提示符下输入1p，会见到文件的第一行：123:1pWith a screen editor you can: 事实上，你可以省略p，因为行号本身与显示出此行的命令是相同的。要显示出多行文 本，可以指定一个范围的行号（例如，1,3——两个数值之间用逗号分隔，中间有没有空格都无妨）。例如：1234:1,3With a screen editor you canscroll the page, move the cursor,delete lines, insert characters， and more, 没有行号的命令会被当作只对当前这一行起作用。以替换命令（s）为例，其将一个单词替换成另一个，可以这样输入：1234:1With a screen editor you can :s/screen/line/With a line editor you can 请注意，更动的行会在命令执行后重新显示出。你也可以换个方法做相同的事:12:ls/screen/line/With a line editor you can 即使你是从vi中调用ex命令，而不是直接使用ex,花一点时间了解ex也是很值得的。你 会感觉到为什么需要告诉编辑器该操作哪一行（或多行）以及该执行哪一个命令。 在你对practice文件试过一些ex命令后，应该用vi打开同一个文件，这样就可以在比较熟悉的可视模式中査看文件。:vi命令可以让你从ex进入vi。 想在vi中使用ex命令，你必须输入特定字符：（冒号）。输入命令后，按ENTER来执行。因为在ex编辑器中你只要在冒号提示符后输入行号，就可以跳到那一行。所以，想在vi中移到某文件的第6行，请输入：:6然后按下ENTER 问题集• 在vi中编辑文件时，有时会意外进入ex编辑器。在vi的命令模式中输入Q时会调用ex。若是意外进入ex编辑器时，输入命令vi即可回到vi编辑器。 用ex编辑许多负责常见编辑操作的ex命令在vi中都有更简单的相应命令。删除一个单词或一行时，当然使用dw或dd，而不用ex的delete命令。然而，当你要更改许多行时，会发现ex 命令更有用。你可以用一个命令更改一大块文本。 常用的ex命令与其缩写整理如下。但请记住，在vi中输入ex命令时，命令前必须加上冒号。你可以用完整的命令名称或缩写，以好记为原则。 Full name Abbreviation Meaning delete d 删除行 move m 移动行 copy co 复制行 t 复制行（与co同义) 如果你觉得用空格来分隔ex命令的多个部分会比较容易读，确实可以这么做。例如在行地址（line address）、模式与命令间使用空格分隔。然而，你不能在模式中使用空格区隔，也不能以空格作为替换命令的结尾。 行地址每一个ex编辑命令都需要知道要编辑的行号。而对ex的move与copy命令来说，还必须提供文本移动或复制的目的地。 指定行地址的方法有下面几种：• 指定明确的行号• 用符号来指定相对于当前位置的行号• 标识某些行的搜索模式作为地址我们来看一些例子。 定义行范围你可以用行号来淸楚地定义某一行或某段行的范围。明确指定行号的地址称为绝对行地址。例如：123456:3,18d删除第3行到第18行。:160,224m23将第160行到第224行移到第23行之后（类似vi中的delete与put)。:23,29co100将第23行到第29行复制到第100行之后（类似vi中的yank与put)。 为了简化使用行号的编辑操作，你可以将所有的行号显示在屏幕左边。可使用下面的命令：12:set number 或简写为：:set nu 这时会显示行号，文件practice将显示如下：12341 With a screen editor2 you can scroll the page,3 move the cursor, delete lines,4 insert characters and more 当你写入文件时，行号并不会写入文件，打印时也不会打印出来。行号只有在结束vi 话或者禁用set选项时才会消失，禁用set选项的命令如下：123:set nonumber或是:set nonu 要暂时显示某些行的编号时，可以使用#符号，例如：12:1,10#显示第1行到第10行的行号。 如第三章所述，你可以使用Ctrl+G命令显示当前行的编号。因此，欲确认一段文本开头与结尾的行号时，可以通过将光标移动到文本块的开头，键入Ctrl+G，再将光标移 动到块结尾并键入Ctrl+G而得知。另一个分辨行号的方法是ex的=命令：123456:=列出文件的总行数。:.=列出当前所在行的行号。:/pattern/=列出ptmern第一次出现时的行号。 行寻址符号你也可以用符号表示行地址。点号（•）表示当前这一行；$表示文件的最后一行。％表示文件中的每一行，与1,$组合的意义相同。这些符号可与绝对行地址合并使用。例如：12345678:.,$d删除当前这一行到文件结尾间的文本。:20,.m$将第20行到当前这一行间的文本移到文件结尾。:%d删除文件中所有的行。:%t$将所有的行复制到文件结尾（做连续的复制）。 除了绝对行地址之外，你还可以指定相对于当前这一行的地址。+与-的操作类似于算数 操作。放在数值前面时，其表示加上或减去后面的数值。例如：123456:.,.+20d删除当前这一行到20行之后的行之间的文本。:226,$m.-2将第226行到文件结尾间的行移到当前这一行的两行之前。:.,+20#显示当前这一行及向下20行之间的行号。 事实上，在使用+或-时并不需要输入点号（.），因为当前行会被假定为开始的位置。 如果后面没有接着数值，+与-分别等于+1与-1 (注2)。同样地，++与–分别可将范围增加一行，以此类推。+与-也可以用在搜索模式中，这在下一节会提到。 注: 在相对地址中，你不可将+或-与它们后面的数值分开。例如，+10表示“后面10行”；但+ 10則表示“后面11行” （1 + 10行），这可能不是你要的结果。 数字0表示文件的开头（想象中的第0行）。0与1-相同，都可以让你将多行文本移动或复制到文件的开头，也就是第一行文本之前。例如：123:-,+t0:-,+t1-复制3行（光标上面一行到光标下面一行）并放置到文件的幵头。 搜索模式另一个可以指定行地址的方法是使用搜索模式。例如：12345678:/pattern/d删除下一个包含pattern的行。:/pattern/+d删除下一个包含的行的下一行（你也可以用+1替代+)。:/patternl1,/pattern2/d从第一个包含pattern1的行删除到第一个包含pattern的行。:.,/pattern/m23将当前这一行（•）到第一个包含pattern的行之间的文本移到第23行之后。 重新定义当前这一行的位置有时候在命令中使用相对行位置会产生意料之外的结果。举例来说，假设光标位于第1 行，而你想要显示出第100行与它下面的5行，如果输入：1:100,+5 p 会得到错误消息，表示“第一个地址超过了第二个地址”。这是因为第二个地址是相对 于当前光标位置的（第1行），因此命令实际上是表示：1:100,6 p 这时你需要让命令以为第100行是“当前行”，即使实际上光标是位于第1行。 ex提供了一个方法：当你用分号代替逗号时，第一个行地址会被当成光标当前的地址。 例如，这个命令：1:100:+5 p 即可显示出你所要的结果，此时的+5是相对于第100行计算的。分号对搜索模式的绝对地址很有用。例如，要显示出包含指定模式的下一行及后续10行，可以输入：1:/pattern/;+10 p 全局搜索你已经知道如何在vi中使用/(斜线）来搜索文件中的文本模式。ex还有个全局命令g, 可以让你搜索模式并显示所有包含这个模式的行。命令:g!的功能则与:g正好相反，它 (或是意义相同的:v)用于搜索所有不包含指定模式的行。你可以将全局命令用在文件中所有的行，或者用行地址将全局捜索限制在一定范围的行 中。12345678:g/pattern寻找（移到）文件中最后一次出pattern的地方。:g/pattern/p寻找并显示文件中所有包含的行。:g!/pattern/nu寻找并显示文件中所有不包含的行，也显示所有找到的行号。:60,124g/pattern/p寻找并显示第60行与第124行之间包含pattern的行。 如你所料，g也可以用于全局替换，我们会在第六章中介绍。 合并ex命令想输入新的ex命令，并不是每次都必须输入冒号。在ex中，竖线（丨）可以分隔命令，让 你在同一个ex提示符号下合并多个命令（就像在Unix shell提示符下，用分号分隔多个命 令一样）。当你使用|时，请记住你所指定的行地址。如果某个命令影响了文件中各行 的顺序，下一个命令将在新的行地址上运作。例如：:l,3d | s/thier/their/删除第1行到第3行（现在位于文件的开头），接着在当前行做替换（即原来的第4行）。 .：1,5 m 10 | g/pattern/nu将第1行到第5行移到第10行之后，接着显示所有包含的行（包括行号）。请注意空格的使用，这能让命令更容易理解。保存与离开文件你已经学过vi命令中的ZZ,它用于离开vi并写入（保存）文件。但是你常常想用ex命令 离开文件，因为这些命令会给你更多的控制权。我们前面曾经提过其中的一些，现在让 我们开始正式介绍：将缓冲区中的内容写入（保存）文件中，但不离开。你可以（也应该）在编辑会话 里常常使用:w，以保护你的文件免遭系统问题或严重编辑错误的损害。:q离开编辑器（并回到Unix提示符下）。:wq写入文件同时离开编辑器。这是无条件写入，即使文件没有被修改也一样。:x写入文件同时离开编辑器。只有文件被修改过时才会写入（注3)。vi会保护现有文件以及缓冲区中的编辑工作。例如想把缓冲区中的内容写入现有文件， vi会发出警告。同样地，如果你用vi来打开文件并进行编辑，然后想结束vi,但不保存 编辑结果，vi也会产生错误消息：注3: :wq与：x的差异在编辑源代码并使用make时很重要。make根据文件修改的次数而执行动作。ex编辑器概述| 69 No write since last change.(自上一次改变之后没有写入。）这些鳘告消息可以预防许多会造成损失的错误。但有时你会想要强制执行命令，此时在 命令后面加上感叹号（！）可忽略繁告：:w!:ql:w!搭配vi -R或view,则可写入以只读模式打开的文件（假设你拥有文件的写入权 限）。是基本的编辑命令，可以离开编辑器而不影响原来的文件。即不管做了怎样的改 变，均舍弃缓冲区中的内容。更改缓冲区名称你可以用：w将整个缓冲区（你正在编辑的文件副本）以新的文件名保存。假设你有一个600行的practice文件。你打开文件后做了许多编辑操作，然后想要离开 编辑器，但又要同时保存原来的practice文件与编辑后结果，作为比较之用。若将编辑 缓冲区中的内容存为名为practice, new的文件，可以用以下命令：:w practice.new则原来的文件practice的内容不会改变（只要你之前没有用过:w)。这时就可以输入:q 离开编辑器。保存一部分的文件有时你会想将一部分编辑中的文件保存为新文件。例如，你可能已经输入了格式化代码 与文本，但想将这些给其他文件使用。合并使用ex的行寻址命令与写入命令w可以保存一部分文件。以正在编辑practice文件并 想将其中的一部分保存成名为的文件为例，可以输入：：23〇,$w ne^file将第230行到文件结尾保存成名为newfile的文件。:.,600w newfile将光标所在的行到第600行保存成名为newfile的文件。70 I第五章 附加内容到己保存的文件你可以用Unix的重定向与附加运算符（&gt;&gt;)加上w命令，将缓冲区中的一部分或所有内 容附加到现有文件之后。例如输入：:l,10w neufile 再输入：：34〇,$w »newfile ^则会包含第1一10行以及第340行到缓冲区结尾间的两段内容。将一个文件复制到另一个文件有时会想把已经输入完毕的文本与数据复制到当前正在编辑的文件里。在vi中你可以用 ex命令来读入另一个文件中的内容：:read filename或简写为：:r filename这个命令把的内容插入到光标所在位罝的下一行。如果你要指定插入位置为其 他行；只需在read或r命令前输入行号（或是行地址）即可。假设你在编辑practice文件并想读入一个位于其他目录下的文件，例如/home/tim中的 data文件。则先将光标移到欲插入位置的上一行，再输入：:r /home/tim/data/h ome/t im/d at a的内容会被读入到pra ct i c中，并从光标所在位置的下一行幵始显示出。要读入同一个文件，但从185行之后插入，则需要输入：:l85r /home/tim/data 还有其他方法可以读入文件：$r /home/tim/data将读入的文件放在当前文件的结尾。ex编辑器概述I 71 :0r /home/tim/data将读入的文件放在当前文件的开头。:/pattern/r /home/tim/data将读入的文件放在第一个出现的行之后。编辑多个文件ex命令可以让你在多个文件之间切换，其好处是速度较快。如果你与其他用户共享系 统，若每次编辑文件时都要先离开再进入vi，势必很花时间。留在同一个’编辑会话并 在文件之间切换，不但速度较快，还可以保存你所定义的简写与命令序列（参阅第七 章），并且可以保留拖曳缓冲区中的内容，以便在多个文件间复制文本。用vi同时打开多个文件当你第一次打开Vi时，可以给出多个文件名，接着用ex命令在文件间切换。例如：$ vi filel file2即可先编辑filei,然后使用ex命令:w写入（存储）filei，此时会调用下一个文件 (file2)。假设你要编辑两个文件，practice与note。按键顺序vi practice note结果0ith a screen editor you can scrollthe page, move the cursor, delete lines,insert characters, and more, while seeing打开practice与note这两个文件。第一个文件practice会出现在屏幕上，可以进行编辑。「practice” 6 lines&gt; 328 characters用ex的w命令来保存编辑过的practice文件。按【ENTERL[leaFMr^Henshaw:Thank you for the prompt …用ex的n命令调用下一个文件note,再按函斤开始编緝。“note” 23 lines, 1343 characters将第二个文件note保存，并离开这个编辑会话。72 |第五章 使用参数列表ex并不是只能用：n移动到下一个文件。：ai:gs参数（简写为:ar)可列出命令行上的文件 列表，当前编辑中的文件名称以方括号括起。按键顺序 结果vi practice note:args3ith a screen editor you can scrollthe page, move the cursor, delete lines,insert characters, and more, while seeing打开practice与note两个文件。其中第一个文件practice会显示在屏幕上。[practice] notevi将参数列表显示在状态行中。以方括号括起当前编辑中的文件的名称。:rewind (:rew)命令会将当前文件复位成命令行上的第一个文件。elvis与Vim提供了 对应的命令:last，用于移动其成命令行上的最后一个。调用新文件你不需要在编辑会话刚开始时就调用多个文件，而可以在任何时候用：e命令切换到另一 个文件。如果你要在vi中编辑另一个文件，首先必须保存当前文件（:w),再下命令：:e filename假设你正在编辑文件practice,又想编辑文件letter，则要首先回到practice:按键顺序 结果:w “practice” 6 lines, 238 characters用w来保存practice，再按lENT品。practice被保存，但仍会显示在屏 幕上。现在你可以切换到另一个文件了，因为你的编辑结果已经保存。:e letter Hletter” 23 lines, 1344 characters用e命令调用letter文件，再按下丨EN涵，开始编辑。vi会同时“记住”两个文件名，作为当前的与候补的文件名，它们可以用符号％ (代表当 前的文件名）与#(代表侯补的文件名）来表示。#对:6特别有用，因为它可以在两个文 件间方便地切换。在上一个例子中，你可以输入命令:e #回到第一个文件practice。你 也可以用：r #将practice文件的内容读到当前的文件中。ex编辑器概述I 73 在当前的文件尚未存储前，Vi不会让你用：e或:n来切换文件，除非你特别在命令之后加 上感叹号。例如在编辑过letter之后，你想放弃编辑结果并回到practice文件，可以输入:el #。下面的命令也很有用。它会放弃你的编辑结果，并恢复当前文件的上个已保存版本的内 容：相对于#符号，％主要用于写出当前缓冲区中的内容到另一个新文件中。例如，前面的 “更改缓冲区名称” 一节中，我们展示了如何保存practice文件的第二个版本：:w practice.new因为%表示当前的文件名，因此命令也可以写成：:w %.new在vi中切换文件j由于切换文件是个常用功能，因此你不需要进入ex命令模式。使用vi的 A A获（答制键Ctrl加上A符号）即可切换文件。这个命令的功能与:e #—样。就像:e命令一样，如果当前缓冲区的内容还没保存，vi不会让你切换到其他的文件。在文件之间做编辑当你为拖曳缓冲区命名（名称为一个字母）时，就有了把文本从一个文件移到另外一 个的简便方法。使用命令将新的文件载入vi的缓冲区时，并不会清除命名缓冲区中的 内容。因此，可先在一个文件中拖曳或删除文本（如果需要的话，可存入多个命名缓冲 区），再用：e调用新的文件，然后把命名缓冲区的内容放置到新文件中，这样就可以在 文件之间传送文本了。下面的例子说明了如何将文本从一个文件传送到另一个文件。 按键顺序 结果” f4yyWith a gcreen editor you can scrollthe page, move the cursor, delete lines,insert characters, and more, while seeingthe results of the edits as you make them将4行文本拖曳到缓冲区f中。74 I第五章 按键顺序:w:e letter 结果（续) 用进入letter文件。将光标移到要放置复制文本的地方。Dear Mr.Henshaw:I thought that you wouldbe interested to know that:iJith a screen editor you can scrollthe page, move the cursor, delete lines,insert characters, and more, while seeingthe results of the edits as you make themYours truly,从命名缓冲区f中取出文本并放置到光标处。另一种将文本从一个文件移到另一个文件的方法是用ex命令：ya (拖动）与：pu (放 置）。这些命令分别与vi的y、p命令的运作方式相同，但是需与ex的行寻址功能和命名 缓冲区一起使用。例如：:l60,224ya a将第160行到第224行之间的文本拖曳（复制）到缓冲区a中。接着你可以用：e进入要放 贾这些文本的文件，将光标移到要放置文本的行，再输人：:pu a将缓冲区a的内容放置到当前所在行的下一行。 第六章 全局替换第七章 高级编辑方法第八章 vi同类品的功能总览第二部分 Vim第九章 Vim 概述第十章 Vim对Vi的主要改进第十一章 Vim的多窗口功能第十二章 Vim 脚本第十三章 图形化Vim(gvim)第十四章 程序员专用的Vim强化功能第十五章 其他好用的Vim功能]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>vi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件包的管理]]></title>
    <url>%2F2015%2F06%2F16%2F2015-06-15-244110-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[RPM什么是rpmRPM是RedHat Package Manager（RedHat软件包管理工具）。它工作于R e d Hat Linux以及其它Linux系统，成为了Linux中公认的软件包管理标准。红帽子软件公司鼓励其他厂商来了解R PM并在自己的产品中使用它。R PM的发布基于GPL协议。随着R PM在各种发行版本的广泛使用，如今R PM的全称是R PM Pack ageManage r。 rpm包管理的用途1、可以安装、删除、升级和管理软件；当然也支持在线安装和升级软件；2、通过RPM包管理能知道软件包包含哪些文件，也能知道系统中的某个文件属于哪个软件包；3、可以在查询系统中的软件包是否安装以及其版本；4、作为开发者可以把自己的程序打包为RPM 包发布；5、软件包签名GPG和MD5的导入、验证和签名发布6、依赖性的检查，查看是否有软件包由于不兼容而扰乱了系统； RPM 包的命名方式以 httpd-2.2.15-39.el6.centos.x86_64.rpm 为例， httpd 表示软件名 2.2.15 表示主版本号，次版本号，发行版本号分别是2，2，15 39.el6.centos 表示 RPM 包的修订号和 OS 信息 x86_64 表示此软件包适用的平台，常见的有i386，i586，x86_64 等 RPM包管理命令的使用安装1rpm &#123;-i|--install&#125; [install-options] PACKAGE_FILE1.. 安装时可以使用 -h 以#的个数显示安装进度，一个#表示2%的进度，使用 -v 显示详细安装信息 --test 可以用于测试安装是否能够成功，而不实际安装 在安装过程中，可能遇到软件包的依赖问题，而需要先安装其他软件包，--nodeps 忽略依赖强制安装，但是这样安装的软件包通常也会因为依赖缺失而无法正常工作 如果需要重新安装并覆盖原有的文件，可以使用 --replacepkgs 选项 使用 --force 可以进行强制覆盖安装，它等同于--replacepkgs, --replacefiles, 和 --oldpackage 12rpm -ivh /media/cdrom/CentOS/elinks-0.11.1-5.1.el5.i386.rpmrpm -ivh http://centos.candishosting.com.cn/5/os/i386/CentOS/elinks-0.11.1-5.1.el5.i386.rpm 升级或安装 如果不知道一个软件包是否已经安装，并希望如果已经安装那么升级次软件包，使用 -U 选项。 1rpm &#123;-U|--upgrade&#125; [install-options] PACKAGE_FILE ... 如果仅仅希望升级软件包，使用 -F 选项 1rpm &#123;-F|--freshen&#125; [install-options] PACKAGE_FILE ... 升级软件包和安装软件包一样，可以使用 --test、--nodeps、--force 等选项。 1234567# 安装并升级 zsh 软件包[root@localhost rpm]# rpm -ivh zsh-4.3.10-7.el6.x86_64.rpmPreparing... ########################################### [100%]1:zsh ########################################### [100%][root@localhost rpm]# rpm -Uvh zsh-4.3.10-9.el6.x86_64.rpmPreparing... ########################################### [100%]1:zsh ########################################### [100%] 如果想要将软件包降级到旧版本，使用 –oldpackage 选项 123[root@localhost rpm]# rpm -Uvh --oldpackage zsh-4.3.10-7.el6.x86_64.rpmPreparing... ########################################### [100%]1:zsh ########################################### [100%] 在升级软件包时，原来软件包的配置文件可能已经被修改，升级时，新版本的文件不会将老版本的配置文件覆盖，而是将新版本的配置文件加上 .rpmnew 后缀后保存。 注意：内核也是软件包，但是不建议直接对内核进行升级。多版本内核可以并存，因此建议执行安装操作 卸载1rpm &#123;-e|--erase&#125; [--allmatches] [--nodeps] [--test] PACKAGE_NAME ... 通常使用 rpm -e PACKAGE_ANEM 即可简单卸载一个软件包 使用 --nodeps 忽略依赖关系--test 测试卸载。--allmatches 表示如果一个程序包同时安装多个版本，则次选项一次全部卸载之 如果卸载正常，不会输出任何信息。 注意：如果程序包的配置文件安装后曾被修改，卸载时，此文件通常不会被删除，而是被重命名为 .rpmsave 后缀后留存。 查询 查询使用 -q 选项，可以检查安装的所有包，还可以查看某包的详细信息。 1rpm &#123;-q|--query&#125; [select-options] [query-options] 1234567891011121314151617181920212223242526272829303132333435363738rpm -q zsh# 查询某包是否已经安装rpm -qa# 查询安装的所有包 rpm -qp nmap-5.51-4.el6.x86_64# 查询未安装包信息# 查询未安装包的信息指定的是 RPM 包的文件名而不是某个包的软件名。rpm -qi bash# 查询安装包包的简要说明信息rpm -ql zsh# 查询软件包安装的文件列表rpm -qf /etc/ssh/sshd_config# 查询某文件是哪个包安装生成的rpm -qc openssh-server# 查看软件包安装后生成的所有配置文件rpm -qd nmap# 查看软件包安装后生成的所有说明文件和帮助文件rpm -q --changelog nmap# 查看软件包制作时随版本变化的 changelog 信息rpm -q --requires nmap# 查看软件包所需的依赖rpm -q --scripts zsh# 查看软件包安装或卸载时执行的脚本# 脚本分四类# preinstall 安装前脚本# postinstall 安装后脚本# preuninstall 卸载前脚本# postuninstall 卸载后脚本 检验查询软件包安装之后的文件是否发生了改变 1rpm &#123;-V|--verify&#125; [select-options] [verify-options] 检验时使用了多个位表示文件的多个属性是否发生了变化： S 文件大小M 文件权限5 文件摘要信息（通常是 MD5 码）D 设备文件的主/次设备号L 软链接变化U 属主G 属组T 文件的 mtimeP caPabilities 程序包的合法性验证 在软件包制作时，为了防止软件包被人修改植入后门，制作者可以使用自己私钥对软件包进行数字签名，安装者就可以使用公钥验证软件包的合法性。同时还可以使用摘要算法提取软件包的摘要信息用于验证软件包的完整性。 通常，RHEL 系的安装光盘中包含有用于验证其软件包合法性的公钥文件。 导入公钥 1rpm --import /path/to/RPM-GPG-KEY-FILE 验证合法性 1rpm &#123;-K|--checksig&#125; PACKAGE_FILE RPM 管理器的数据库每次安装 rpm 包时，rpm 系统会将一些元信息存储在它的数据库中，使用 rpm -q 命令查询软件包的相关信息时将会查询这些数据库，数据库文件位于 /var/lib/rpm 目录中。如果 RPM 的数据库损坏，将会导致一些 RPM 数据丢失，一些功能将无法正常使用。 重建数据库如果 RPM 的数据库损坏，首先可以尝试重建它，如果无法重建，那么需要重新初始化数据库。 1rpm --rebuilddb 表示重建数据库 这个命令会从已安装的软件包提取信息重建数据库，它从 /var/lib/rpm/Packages 这个文件中提取信息，其他所有的数据库文件都可以由这个文件重建。如果 RPM 的数据库是完好的，这个命令不会重建，而是对数据库中未使用的条目进行空间回收。 1rpm --initdb 创建一个新的 RPM 数据 如果已经没有其他别的办法了，–initdb 会创建一个新的空的 RPM 数据库。由于新建的数据库是空的，不要万不得已不要使用这个命令。 yum为什么使用yumLinux系统维护中令管理员很头疼的就是软件包之间的依赖性了，往往是你要安装A软件，但是编译的时候告诉你X软件安装之前需要B软件，而当你安装Y软件的时候，又告诉你需要Z库了，好不容易安装好Z库，发现版本还有问题等。由于历史原因，R PM软件包管理系统对软件之间的依存关系没有内部定义，造成安装RPM软件时经常出现令人无法理解的软件依赖问题。其实开源社区早就对这个问题尝试进行解决了，不同的发行版推出了各自的工具，比如Yellow Dog的YUM（Yellowdog Updater, Modified），De bian的APT(Advance d Pack aging Tool)等。开发这些工具的目的都是为了要解决安装RPM时的依赖性问题，而不是额外再建立一套安装模式。 什么是yum yum（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。 基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。 YUM基于RPM包管理工具，能够从指定的源（服务器，本地目录等）自动下载目标RPM包并且安装，可以自动处理依赖性关系并进行下载、安装，无须繁琐地手动下载、安装每一个需要的依赖包。 yum的特点 自动解决包的倚赖性问题能更方便的添加/删除/更新R PM包 便于管理大量系统的更新问题 可以同时配置多个资源库(Re pository) 简洁的配置文件(/etc/yum .conf) 保持与RPM数据库的一致性 有一个比较详细的log，可以查看何时升级安装了什么软件包等 使用方便 yum客户端 配置文件：指定各可用的yum仓库 缓存元数据：yum会到各可用yum仓库获取元数据，并缓存至本地 分析元数据：根据具体的操作请求完成元数据分析，可能包括依赖关系、文件列表等信息 执行具体操作 客户端配置文件指定对服务器配置文件 ftp ftp://server/path/to/repo http http://server/path/to/repo nfs nfs://servr/nfs_path file file:///path/to/path 仓库配置 要使用yum管理应用程序，首先得配置其可用的yum仓库，保存在配置文件中。 配置文件格式：由两段组成。 /etc/yum.conf： [main]，主配置段 /etc/yum.repo.d/*.repo： [repo]，仓库配置段 配置repo 123456789[repositoryid]name=Some name for this repositorybaseurl=url://server1/path/to/repository/url://server2/path/to/repository/url://server3/path/to/repository/mirrorlist=url://path/to/mirrorlist/repository/enabled=0/1gpgcheck=0/1gpgkey=A URL pointing to the ASCII-armoured GPG key file for the repository 12345678910repositoryid # 指定一个仓库name # 指定易读的仓库名称baseurl # 指定本仓库的URL，可以是如下的几种类型# http # 指定远程HTTP协议的源 ftp # 指定远程FTP协议的源 file # 本地镜像或NFS挂装文件系统enabled # 指定是否使用本仓库，默认值为1，即可用gpgcheck # 指定是否检查软件包的GPG签名gpgkey # 公钥地址，可以是本地，也可以是服务器端路径cost # 定义此仓库开销，默认为1000 常用命令 安装 1234yum install # 全部安装yum install package1 # 安装指定的安装包package1，手动禁止检查来源及完整性：--nogpgcheckyum reinstall package1 # 重新安装指定的安装包package1yum groupinsall group1 # 安装程序组group1 更新和升级 123456yum check-update # 检查可升级的包yum update # 全部更新yum update package1 # 更新指定程序包package1，要升级到指定版本要带版本号如nmap-5.51yum upgrade package1 # 升级指定程序包package1yum groupupdate group1 # 升级程序组group1yum downgrade package1 # 降级指定程序包package1 查找和显示 1234567891011yum info package1 # 显示安装包信息package1yum list # [all|installed（已安装过的）|available(可用)];显示所有已经安装和可以安装的程序包yum list package1 # 显示指定程序包安装情况package1yum info # 显示包的详细信息yum grouplist # 列出所有的包组yum groupinfo group1 # 显示程序组group1信息yum search string # 根据关键字string查找安装包yum deplist package1 # 查看程序package1依赖情况yum whatprovides /etc/shadow # 查看/etc/shadow是由哪个包提供的yum provides /etc/shadow # 查看/etc/shadow是由哪个包提供的yum history # 查看yum的命令历史 删除和卸载 12yum remove|erase package1 # 移除|卸载程序包package1，依赖的包也会被卸载yum groupremove group1 # 删除程序组group1 清除缓存 1234yum clean packages # 清除缓存目录/var/cache/yum 下的软件包yum clean headers # 清除缓存目录/var/cache/yum 下的 headersyum clean oldheaders # 清除缓存目录/var/cache/yum 下旧的 headersyum clean;yum clean all # = yum clean packages; yum clean oldheaders) yum配置文件中可用的宏 $releasever：程序的版本 对Yum而言指的是redhat-relrase版本。 只替换为主版本号，如Redhat6.5 则替换为6 $arch:系统架构 $basharch:系统基本架构，如i686，i586等的基本架构为i386 $YUM0-9:在系统定义的环境变量，可以在yum中使用 CentOS的镜像站点镜像站点的第一级目录是发行版本号，如 3、4、5 等 搜狐开源镜像站：http://mirrors.sohu.com/ 网易开源镜像站：http://mirrors.163.com/ 北京理工大学： http://mirror.bit.edu.cn (IPv4 only) http://mirror.bit6.edu.cn (IPv6 only) 清华大学： http://mirrors.tuna.tsinghua.edu.cn/ (IPv4+IPv6) http://mirrors.6.tuna.tsinghua.edu.cn/ (IPv6 only) http://mirrors.4.tuna.tsinghua.edu.cn/ (IPv4 only) 天津大学：http://mirror.tju.edu.cn/ 中国科学技术大学： http://mirrors.ustc.edu.cn/ (IPv4+IPv6) http://mirrors4.ustc.edu.cn/ http://mirrors6.ustc.edu.cn/ 源码包linux源码包与RPM包的区别 安装之前 源码包是开源的，比RPM包安装更自由，但是它安装更慢，更容易报错 RPM包是经过编译的，不能看到源代码，但是它安装更快，报错更容易解决，只有依赖性问题 安装之后 RPM包不需要指定安装位置，它会安装到系统默认位置 源码包是人为手工设置 源码包编译安装基本步骤 注意：源码包编译安装前提是准备开发环境(编译环境) 若系统为Centos 5，开发包组为”Development Tools“和”DeveLopment Libraries“ 若系统为centos 6，常用的开发包为”Development tools“和”Server Platform Development” 拿到源代码，并解压 tar -xf package-version.tar.{gz|bz2|xz}注意：展开后的目录通常为package-version 切换至源码目录中 cd package-version 执行configure脚本 ./configure 编译 make 安装 make install 头文件输出给系统、创建库文件链接、二进制可执行文件环境变量、导出man文件 configure脚本的通用功能(需要定义的配置) 指定安装路径 --prefix=前缀，用于指定安装路径 --sysconfdir=/etc/package_name 指定启动/禁用的特性 --enable-feature --disable-fecture 指定所依赖功能、程序或文件 --with-function：启用某功能 --without-function： 禁用某功能 不同的程序，其configure不尽相同，应获取帮助信息 1./configure --help]]></content>
      <categories>
        <category>软件管理</category>
      </categories>
      <tags>
        <tag>软件包</tag>
        <tag>rpm</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件路径搜索命令整理]]></title>
    <url>%2F2015%2F03%2F28%2F2015-03-28-094910-%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E6%90%9C%E7%B4%A2%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[which概述用于查找并显示给定命令的绝对路径，环境变量PATH中保存了查找命令时需要遍历的目录。which指令会在环境变量$PATH设置的目录里查找符合条件的文件。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。 语法1Usage: which [options] [--] programname [...] 选项1234-n &lt;文件名长度&gt;：制定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名-p &lt;文件名长度&gt;：与-n参数相同，但此处的&lt;文件名长度&gt;包含了文件的路径-w：指定输出时栏位的宽度-V：显示版本信息 示例1234567891011[user1@practice ~]$ which lsalias ls='ls --color=tty' /bin/ls[user1@practice ~]$ which awk/bin/awk[user1@practice ~]$ which grepalias grep='grep --color' /usr/bin/grep[user1@practice ~]$ which test/usr/bin/test[user1@practice ~]$ dirname概述去除文件名中的非目录部分，仅显示与目录有关的内容。dirname命令读取指定路径名保留最后一个/及其前面的字符，删除其他部分，并写结果到标准输出。如果最后一个/后无字符，dirname 命令使用倒数第二个/，并忽略其后的所有字符。 语法12Usage: dirname NAME or: dirname OPTION 选项12--help：显示帮助--version：显示版本号 示例1234567891011[user1@practice ~]$ dirname ///[user1@practice ~]$ dirname /usr/local/bin//usr/local[user1@practice ~]$ dirname /usr/local/bin/usr/local[user1@practice ~]$ dirname /usr/bin/sort/usr/bin[user1@practice ~]$ dirname test.[user1@practice ~]$ basename概述用于打印目录或者文件的基本名称。 语法12Usage: basename NAME [SUFFIX] or: basename OPTION 选项12--help：显示帮助--version：显示版本号 示例12345678910111213[user1@practice ~]$ basename ///[user1@practice ~]$ basename /usr/local/bin/bin[user1@practice ~]$ basename /usr/local/binbin[user1@practice ~]$ basename /usr/bin/sortsort[user1@practice ~]$ basename testtest[user1@practice ~]$ basename /usr/bin/sort rtso[user1@practice ~]$ readlink概述输出符号链接值或者权威文件名，主要用来 找出符号链接所指向的位置 语法1readlink [OPTION]... FILE 选项123-f, --canonicalize：递归跟随给出文件名的所有符号链接以标准化，除最后一个外所有组件必须存在。简单地说，就是一直跟随符号链接，直到非符号链接的文件位置，限制是最后必须存在一个非符号链接的文件--help：显示帮助--version：显示版本号 示例123456789[user1@practice ~]$ readlink awk [user1@practice ~]$ readlink -f awk /home/user1/awk[user1@practice ~]$ readlink -f /usr/bin/awk /bin/gawk# awk其实是一个符号链接文件，指向的是/bin/gawk[user1@practice ~]$ readlink -f /bin/gawk/bin/gawk[user1@practice ~]$ type概述用来显示指定命令的类型，判断给出的指令是内部指令还是外部指令 命令类型 alias：别名。 keyword：关键字，Shell保留字 function：函数，Shell函数 builtin：内建命令，Shell内建命令 file：文件，磁盘文件，外部命令 unfound：没有找到 语法1type: usage: type [-afptP] name [name ...] 选项 -a：打印name的所有可能情况，例如 1234[user1@practice ~]$ type -a lsls is aliased to `ls --color=tty&apos;ls is /bin/ls[user1@practice ~]$ -f：不会去查找function -t：打印alias，keyword，function，built-in，file这5种类型 -p：如果type -t name输出file，那么会打印name所在路径 -P：不管type -t name是不是输出file，都会去搜索name所在路径，比如type -P ls，尽管type -t ls打印的是alias(因为alias的优先级高于file)，但是仍然会搜索出ls所在的路径/bin/ls 如果type不加任何选项，直接加1个或者多个name，那么会依次打印这些name的类型。只有所有name的类型都能成功打印，type才返回成功，否则，只要任何一个name类型无法打印，那么就返回失败 示例123456789101112[user1@practice ~]$ type -t echobuiltin[user1@practice ~]$ type -p echo[user1@practice ~]$ type -P echo/bin/echo[user1@practice ~]$ type -t awkfile[user1@practice ~]$ type -p awk/bin/awk[user1@practice ~]$ type -P awk/bin/awk[user1@practice ~]$]]></content>
      <categories>
        <category>Linux命令</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2015%2F03%2F10%2F2015-03-10-165610-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[netstatNetstat 是一款命令行工具，可用于列出系统上所有的网络套接字连接情况，包括 tcp, udp 以及 unix 套接字，另外它还能列出处于监听状态（即等待接入请求）的套接字。 123456789101112131415netstat -a# --all 列出所有连接netstat -at# --tcp 只列出 TCP 的连接netstat -au# --udp 只列出 UDP 的连接netstat -ant# --numeric 显示为IP地址，禁用对域名、主机名、端口名的反向解析netstat -tnl# --listening 只显示正在监听的连接# 不要使用 -a 选项，否则 netstat 会列出所有连接，而不仅仅是监听端口netstat -tnlp# --program 获取进程名、进程IDnetstat -ep# --extend 显示其他相关信息 date print or set the system date and time，打印或设置系统日期和时间 Rtc：real time clock，硬件时间 Ntp：Network time Protocol，网络时间协议 常用选项12345678910111213141516-d, --date=STRING 显示由 STRING 指定的时间, 而不是当前时间 -f, --file=DATEFILE 显示 DATEFILE 中每一行指定的时间, 如同将 DATEFILE 中的每行作为 --date 的参数一样 -r, --reference=FILE 显示 FILE 的最后修改时间 -R, --rfc-822 根据 RFC-822 指定格式输出日期 -s, --set=STRING 根据 STRING 设置时间 -u, --utc, --universal 显示或设置全球时间(格林威治时间) --help 显示本帮助文件并退出 --version 显示版本信息并退出 输出格式的控制格式 FORMAT 控制着输出格式. 仅当选项指定为全球时间时本格式才有效 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172 %% 文本的 % %a 当前区域的星期几的简写 (Sun~Sat) %A 当前区域的星期几的全称 (不同长度) (Sunday~Saturday) %b 当前区域的月份的简写 (Jan~Dec) %B 当前区域的月份的全称(变长) (January~December) %c 当前区域的日期和时间 (Sat Nov 04 12:02:33 EST 1989) %d (月份中的)几号(用两位表示) (01~31) %D 日期(按照 月/日期/年 格式显示) (mm/dd/yy) %e (月份中的)几号(去零表示) ( 1~31) %F 完整日期，同 %Y-%m-%d %h 同 %b %H 小时(按 24 小时制显示，用两位表示) (00~23) %I 小时(按 12 小时制显示，用两位表示) (01~12) %j (一年中的)第几天(用三位表示) (001~366) %k 小时(按 24 小时制显示，去零显示) ( 0~23) %l 小时(按 12 小时制显示，去零表示) ( 1~12) %m 月份(用两位表示) (01~12) %M 分钟数(用两位表示) (00~59) %N %N输出的是当前时间的纳秒部分 %n 换行 %p 当前时间是上午 AM 还是下午 PM %r 时间,按 12 小时制显示 (hh:mm:ss [A/P]M) %s 从 1970年1月1日0点0分0秒到现在历经的秒数 (GNU扩充) %S 秒数(用两位表示)(00~60) %t 水平方向的 tab 制表符 %T 时间,按 24 小时制显示(hh:mm:ss) %U (一年中的)第几个星期，以星期天作为一周的开始(用两位表示) (00~53) %V (一年中的)第几个星期，以星期一作为一周的开始(用两位表示) (01~52) %w 用数字表示星期几 (0~6); 0 代表星期天 %W (一年中的)第几个星期，以星期一作为一周的开始(用两位表示) (00~53) %x 按照 (mm/dd/yy) 格式显示当前日期 %X 按照 (%H:%M:%S) 格式显示当前时间 %y 年的后两位数字 (00~99) %Y 年(用 4 位表示) (1970~~~) %z 按照 RFC-822 中指定的数字时区显示(如, -0500) (为非标准扩充) %Z 时区(例如, EDT (美国东部时区)), 如果不能决定是哪个时区则为空 默认情况下,用 0 填充数据的空缺部分. GNU 的 date 命令能分辨在%和数字指示之间的以下修改. - (连接号) 不进行填充 _ (下划线) 用空格进行填充 常见用法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152date -s '20161105'# Sat Nov 5 00:00:00 HKT 2016 日期设置成20061010，这样会把具体时间设置成空00:00:00 date -s '16:20:00'# Sat Nov 5 16:20:00 HKT 2016 只设置时间，不更改日期 date -s '2016-11-05 16:14:29'date -s '20161105 16:14:29'# Sat Nov 5 16:14:29 HKT 2016 设置日期和时间 date -d "20161105" +%s # 1478275200 时间转时间戳 date -d '1970-01-01 UTC 1478275200 seconds'date -d @1478275200# Sat Nov 5 00:00:00 HKT 2016 时间戳转时间 date +%F\ %T# 2016-11-05 16:35:11 获取当前日期和时间 date +%Y%m%d%H%M%S# 20161105163652 获取将当前日期为字串 date +%Y%m%d# 20161105 获取当前日期格式为yyyymmdd date +%Y%m%d -d "1 day ago" date +%Y%m%d --date="+1 day" 获取前一天的日期格式为yyyymmdd date -d '3days ago -1 hour' +"%Y-%m-%d %H"date -d '-3 day -1 hour' +"%F %T" 3天前再向后1小时 date +%Y%m%d --date="-1 day" 显示后一天的日期date +%Y%m%d --date="-1 month" 显示上一月的日期date +%Y%m%d --date="+1 month" 显示下一月的日期date +%Y%m%d --date="-1 year" 显示前一年的日期date +%Y%m%d --date="+1 year" 显示下一年的日期 三级标题]]></content>
      <categories>
        <category>Linux命令</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux获取命令帮助]]></title>
    <url>%2F2015%2F03%2F09%2F2015-03-09-135110-Linux%E8%8E%B7%E5%8F%96%E5%91%BD%E4%BB%A4%E5%B8%AE%E5%8A%A9%2F</url>
    <content type="text"><![CDATA[获得命令的帮助 内建命令 12help command command -h 外部命令 12command --helpman command 命令手册：manual whatis 查看命令的章节 1whatis command 章节分类 Standard commands 标准命令（/bin，/usr/bin，/usr/local/bin） System calls 系统调用 Library functions 库函数 Special devices 特殊设备 File formats 文件格式（配置文件的语法格式） Games and toys 游戏和娱乐 Miscellaneous 杂项 Administrative Commands 管理员命令（/sbin，/usr/sbin，/usr/local/sbin） 其他（Linux特定的） 用来存放内核例行程序的文档 man 查看使用手册 符号标识 &lt;&gt; 必选项 [] 可选项 …. 可出现多次 | 多选一 {} 分组，无特殊意义 标题说明 NAME 命令名称及功能简要说明 SYNOPSIS：用法说明，包括可用的选项 DESCRIPTION：命令功能的详尽说明，可能包括每一个选项的意义 OPTIONS：说明每一个选项的意义 FILES：此命令相关的配置文件 BUGS：漏洞或缺陷 EXAMPLES：使用示例 SEE ALSO：另外参照 界面操作 ‘空格’键 向后翻一屏 b 向前翻一屏 Enter、j、↓ 向后翻一行 k、↑ 向前翻一行 /keyword 向后查询，再摁n查询下一个，N上一个 ?keyword 向前查询，n下一个，N上一个 q 退出man帮助 info文档：info 界面操作 ?：显示info的常用快捷键。 N：显示（相对于本节点的）下一节点的文档内容 P：显示（相对于本节点的）前一节点的文档内容 U：进入当前命令所在的主题。 M：敲M键后输入命令的名称就可以查看该命令的帮助文档 G：敲G键后输入主题名称，进入该主题 L：回到上一个访问的页面 SPACE：向前滚动一页 BACKUP或DEL：向后滚动一页 Q：退出info。]]></content>
      <categories>
        <category>Linux命令</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux目录及其含义]]></title>
    <url>%2F2015%2F03%2F05%2F2015-03-05-144210-Linux%E7%9B%AE%E5%BD%95%E5%8F%8A%E5%85%B6%E5%90%AB%E4%B9%89%2F</url>
    <content type="text"><![CDATA[. 当前目录，也可以用./表示； .. 上一级目录，也可以用../表示； ~ 用户自己的宿主目录； / Linux文件系统树形结构的最顶端，称为Linux文件系统的root，它是Linux文件系统的入口。所有的目录、文件、设备都在/之下，它是Linux文件系统最顶层的唯一的目录; 一般建议在根目录下面只有目录，不直接存放文件； 根目录是linux系统启动时系统第一个载入的分区，所以启动过程中用到的文件应该都放在这个分区中，其中/etc、/bin、/dev、/lib、/sbin这5个子目录都应该要与根目录连在一起，不可独立成为某个分区； /bin：存放所有用户都可以使用的linux基本操作命令；(目录中多是可执行的二进制文件) /dev：设备文件目录，虚拟文件系统，主要存放所有系统中device的相关信息.设备文件分为2种类型:字符设备文件和块设备文件/dev/console：系统控制台，也就是直接和系统连接的监视器； /dev/hd：IDE设备文件； /dev/sd：sata、usb、scsi等设备文件； /dev/fd：软驱设备文件； /dev/tty：虚拟控制台设备文件； /dev/pty：提供远程虚拟控制台设备文件； /dev/null：数据&quot;黑洞&quot;，所有写入该设备的信息都将消失，如当想要将屏幕上的输出信息隐藏起来时，只要将输出信息输入到/dev/null中即可； /home：默认存放用户的宿主目录(除了root用户)/home/~/.bashrc：提供bash环境中所需使用的别名； /home/~/.bash_profile：提供bash环境所需的变量；一般先执行.bashrc后，才会再执行.bash_profile； /home/~/.bash_history：用户历史命令文件，记录用户曾经输入过的所有命令；(默认为1000条，可以通过HISTSIZE变量更改) /home/~/.bash_logout：当用户注销的同时，系统会自动执行.bash_logout文件，如果管理员需要记录用户注销的一些额外记录、动作或其他信息，就可以利用这个机制去完成； /lost+found：当系统在运行时，有时会无法避免宕机、断电或不正常重启动，在这样的情况下，当系统重新启动时，发现某些文件写入未完成或其他问题产生，一般会使用fsck进行文件修复，而这些被修复或救回的文件，就会被放在这个目录下，只要是一个文件系统，系统就会自动在该文件系统所在的目录下建立”lost+found”目录 /misc：自动挂载服务目录，对应autofs服务；/proc：虚拟文件系统，此目录是kernel加载后，在内存里面建立的一个虚拟目录，有专属的文件系统，主要提供系统一些实时的信息，此目录下不能建立和删除文件；(某些文件可以修改)/proc主要作用可以整理为： --整理系统内部的信息； --存放主机硬件信息； --调整系统执行时的参数； --检查及修改网络和主机的参数； --检查及调整系统的内存和性能； /proc下常用的信息文件有： /proc/cpuinfo：cpu的硬件信息，如类型、厂家、型号和性能等 /proc/devices：记录所有在/dev目录中相关的设备文件分类方式 /proc/filesystems：当前运行内核所配置的文件系统 /proc/interrupts：可以查看每一个IRQ的编号对应到哪一个硬件设备 /proc/loadavg：系统&quot;平均负载&quot;，3个数据指出系统当前的工作负载 /proc/dma：当前正在使用的DMA通道 /proc/ioports：将目前系统上所有可看到的硬件对应到内存位置的分配表的详细信息呈现出来 /proc/kcore：系统上可以检测到的物理内存，主机内存多大，这个文件就有多大 /proc/kmsg：在系统尚未进入操作系统阶段，把加载kernel和initrd的信息先记录到该文件中，后续会将日志信息写入/var/log/message文件中 /proc/meminfo：记录系统的内存信息 /proc/modules：与lsmod命令查看到的模块信息完全一致 /proc/mtrr：负责内存配置的机制 /proc/iomem：主要用于储存配置后所有内存储存的明细信息 /proc/partitions：这个文件可以实时呈现系统目前看到的分区 /proc/数字目录：数字目录很多，它们代表所有目前正在系统中运行的所有程序 /proc/bus：有关该主机上现有总线的所有信息，如输入设备、PCI接口、PCMCIA扩展卡及USB接口信息 /proc/net目录：存放的都是一些网络相关的虚拟配置文件，都是ASCII文件，可以查看(与ifconfig、arp、netstat等有关) /proc/scsi：保存系统上所有的scsi设备信息(包括sata和usb设备的信息) /proc/sys目录：存放系统核心所使用的一些变量，根据不同性质的文件而存放在不同的子目录中，可以通过/etc/sysctl.conf文件设置和更改其默认值；变量时实时的变更，有很多设置很象是开关，设置后马上生效； /proc/tty：存放有关目前可用的正在使用的tty设备的信息 /proc/self：存放到查看/proc的程序的进程目录的符号连接，当2个进程查看proc时，这将会是不同的连接；主要便于程序得到它自己的进程目录； /proc/stat：系统的不同状态信息； /proc/uptime：系统启动的时间长度； /proc/version：系统核心版本； /sbin：系统管理相关的二进制文件存放在这个目录下，一些可执行文件普通用户只具备较小的权限；(多数管理命令默认只有管理员可以使用)/srv：默认为空，主要用于存放一些软件的配置文件，某些软件可能会把配置文件默认存放在这个目录下，多数都是/etc目录下，此目录没有被具体的定义； /tftpboot：远程启动tftpserver的根目录，这个目录只有安装了tftp-server软件后才会产生； /usr：安装除操作系统本身外的一些应用程序或组件，一般可以认为linux系统上安装的应用程序默认都安装在此目录中；/usr/bin：一般用户有机会使用到的程序，或者该软件默认就是要让所有用户使用才会放在该目录中； /usr/sbin：一些系统有可能会用到的系统命令，与/sbin比起来，都是一些较次要的文件； /usr/etc：自行安装或非系统主要的配置文件目录； /usr/games：只要是电脑游戏相关的软件，就都安装到这个目录； /usr/include：存放的文件都是一些系统中用户所会使用到的C语言header文件，保存的都是&quot;.h&quot;的文件； /usr/kerberos：kerberos是一种安全机制，让用户可以直接使用支持kerberos机制系统上的部分资源； /usr/lib：存放一些函数库、执行文件及连接文件，特别的是，存放在这里面的文件都是不希望直接被用户或shell脚本所使用的文件，在/usr/lib中有非常多的子目录，每一个软件都有其各自所需的函数库； /usr/libexec：这个目录下的文件及文件夹应该都可以放置在/usr/lib下； /usr/local：linux系统中安装的共享软件程序最好的方式是安装在/usr/local下，按照linux标准目录结构，新建立的软件都应该放在/usr/local下； /usr/local/bin：存放软件执行文件的目录； /usr/local/sbin：同样存放软件执行文件的目录，但此目录专门针对系统所使用的文件； /usr/local/lib：软件相关的函数库； /usr/local/share：当文件性质不好归属时就会放在此，man手册就放在这个目录下； /usr/local/src：所安装软件的源代码放置在此； /usr/share：此目录都是一些共享信息，最常被用到的就是/usr/share/man这个目录，/usr/share里的信息时跨平台的； /usr/share/doc：放置一些系统帮助文件的地方； /usr/share/man：manpage的文件存放目录，也是使用man查看手册页时查询的路径； /usr/src：主要储存内核源代码的文件； /usr/X11R6：存放一些X windows系统的相关文件； /boot：存放开机启动加载程序的核心文件；(如kernel和grup)config-2.6.18-164.el5：系统kernel的配置文件，内核编译完成后保存的就是这个配置文件； lost+found：说明/boot是一个独立的ext3文件系统； vmlinuz-2.6.18-164.el5：系统使用kernel，非常重要； grub：多系统启动管理程序grub的目录，里面存放的都是grub在启动时所需要的画面、配置及各阶段的配置文件；其中grub.conf是grub的配置文件； symvers-2.6.18-164.el5.gz initrd-2.6.18-164.el5.img：此文件是linux系统启动时的模块供应主要来源，initrd的目的就是在kernel加载系统识别cpu和内存等核心信息之后，让系统进一步知道还有那些硬件是启动所必须使用的； System.map-2.6.18-164.el5：是系统kernel中的变量对应表；(也可以理解为是索引文件) /etc：主机、系统或网络配置文件存放目录；简单的将/etc目录分为以下几类： --基本文件：所有直接放在/etc目录下的文件归类为基本文件； aliases：用于设置邮件别名； auto.*：代表的是一系列autofs服务所需要的配置文件，这个服务主要是让管理员可以事先定义出一些网络、本机或光驱等默认的路径； auto.master：负责规划目录的分配与使用，目前默认提供三种自动挂载模式； auto.misc：文件中的配置都以实体连接本机的磁盘驱动器为主； auto.net：并不是一个配置文件，而是一个脚本文件，在使用上其实不须做任何调整；； auto.smb：与auto.net一样，都是以个脚本文件； bashrc：用户登录功能配置，全局配置，对所有用户生效，主要配置别名； profile：与系统环境配置或初始化软件的相关配置，全局配置，对所有用户生效，主要配置变量； DIR_COLORS：用于配置ls命令的颜色，主要针对tty登录的用户； DIR_COLORS.xterm：用于配置ls命令的颜色，主要针对xterm登录的用户； fstab：系统启动时自动挂载文件系统的配置文件； inittab：启动时系统所需要的第一个配置文件；也即是init进程的配置文件； issue：用户本机登录时，看到的欢迎信息； issue.net：用户网络登录时，看到的欢迎信息； ld.so.conf：包含ld.so.conf.d/*.conf配置,主要是ld.so.conf.d/*.conf目录的作用； localtime：系统所使用的时区对应的配置文件,对应的时区文件都存在于/usr/share/zoneinfo/ motd：登录成功的用户显示的信息对应的配置文件； mtab：可以当做是检查当前文件系统挂载情况的配置文件；与mount命令结果一致； prelink.conf：定义哪些执行文件和函数库是需要预先连接的； securetty：主要是login程序在使用的，只要是列在该文件中的接口，就表示是可以使用的接口，相反，若从列表中删除，则无法使用该接口； shells：记录目前系统所拥有shell种类的路径，通过cssh命令使用； sudoers：sudo命令对应的配置文件，用于配置权限的分配方式； sysctl.conf：主要是帮助用户配置/proc/sys目录下所有文件的值，与sysctl命令对应； syslogd.conf：是syslogd服务的配置文件 host.conf：主机名解析配置文件，主要说明解析的方式及顺序； hosts：主机名解析配置文件，主要列出所有需要本地解析的主机名与IP地址的对应关系； hosts.allow和hosts.deny：linux网络安全机制TCP Wrapper对应的配置文件； nsswitch.conf：主要记录系统应如何查询主机名、密码、用户组、网络等，或是查询顺序的编排； resolv.conf：记录DNS服务器地址，用于DNS域名解析； services：定义了网络服务的默认端口号； xinetd.conf：xinetd的主配置文件，目的是为xinetd.d下的所有子服务建立一个标准的规范使其可以遵循； anacrontab：属于一种任务计划软件的配置文件，anacrontab软件和crond其实有点相辅相成，crond负责任务计划，而anacrontab则是负责以&quot;间隔多久&quot;为主要的目标； at.deny：该文件属于拒绝列表，只要被记录在其中的用户，就无法使用at所提供的任务计划服务； at.allow：与at.deny刚好相反； crontab：crontab的主配置文件，crond默认会执行的文件可以参考此配置文件； cron.deny：该文件属于拒绝列表，只要被记录在其中的用户，就无法使用crond所提供的任务计划服务； cron.allow：与cron.deny刚好相反； exports：是NFS服务的主配置文件，主要目的就是将本机的目录共享到网络上，供其他人使用； group与gshadow：用户组配置文件，group主要保存用户组信息，gshadow主要保存群组密码； login.defs：设置系统在建立账号时所参考的配置； passwd：主要保存系统用户账号的信息； shadow：linux系统通常包经过&quot;hash&quot;处理后的密码存储在这个文件中； protocols：通信协议对应端口号的一个对照表，包含协议名称、协议号码、注释等； wgetrc：wget程序对应的配置文件，其中有quota、mail header、重传文件的预设次数、firewall和proxy等相关设置； init.d：RHEL中所有服务的默认启动脚本都存放在这里；这个是链接文件，链接到/etc/rc.d/init.d； csh.cshrc和csh.login： 用户启动c shells执行的初始化配置文件； printcap：linux系统中打印机设备对应的配置文件； --服务器目录：如samba、http、vsftpd等服务器配置相关目录； cups：linux下的打印机服务器，目录下存放的是打印机服务的配置文件； dnsmasq.d：dnsmasq是一种DNS的&quot;轻薄机种&quot;，转为区域或小型网络所设计，拥有比一般DNS更为方便简易的配置； httpd：apache网页服务器的配置文件所在目录； mail：Mail Server组件的主要配置目录，如sendmail； ntp：网络时间服务器的配置目录，其主要配置文件为/etc/ntp.conf； openldap：目录明显是LDAP的配置目录，软件名称为OpenLDAP； postfix：postfix组件所提供的主要配置文件目录； samba：文件共享服务samba的主要配置文件目录； smrsh：这是sendmail为了限制用户可使用的命令设计的程序，将原本用户所使用的/bin/sh替换为/usr/sbin/smrsh； snmp：简单网络管理软件的配置文件目录，存在snmpd.conf主配置文件； squid：这是linux下的代理服务器squid的配置文件目录，主配置文件是squid.conf； ssh：SSH服务的主要配置目录，主配置文件是sshd_config； vsftpd：vsftpd服务器的主要配置目录，主配置文件是vsftpd.conf； xinetd.d：xinetd是一个管理多个服务的daemon，这个目录下列出的服务都是由xinetd进程管理的，其主配置文件是/etc/xinetd.conf； --系统目录：如sysconfig、xen或网络配置等与系统运行相关的目录； blkid：此目录所存放的其实是一个块设备ID的临时文件，主要是记录系统中所有区块设备的标签名称、硬件的唯一识别码、文件系统的格式等基本信息； bluetooth：linux下使用蓝牙设备所需的配置文件；启动蓝牙检测的主要服务仍是/etc/rc.d/init.d/bluetooth，该程序使用的是hcid.conf配置文件； cron.X：cron.X的目录都是给cron软件存放其需要任务计划的文件所使用的，按任务计划时间的长短及配置特性分为cron.d、cron.daily、cron.hourly、cron.monthly、cron.weekly五个主要目录； dbus-1：D-BUS的主要配置目录，D-BUS也是一种IPC交流的方式； default：这里是存放一些系统软件默认值的目录，存放某些软件执行时的基本参数； firmware：这个目录所存放的东西是非常底层的信息，是CPU所需的microcode的实体文件； foomatic：与打印机相关的配置目录，实现打印一对多的方式，在foomatic中，可以记录多条打印机数据，让用户只在使用前先行配置所有需要使用的打印机即可； hal：全名Hardware Abstraction Layer，是linux一种管理硬件的机制，它会帮所有的应用程序或用户搜集所有PCI及USB等硬件信息，因此，用户可以很简单并实时地通过HAL的方式取得硬件的相关数据； isdn：ISDN服务的主要配置目录，里面包含可拨号的用户、电话、联机方式等； ld.so.conf.d：这个目录是ldconfig所使用的，更准确的说，它是由/etc/ld.so.conf文件所决定的；ldconfig命令的目的在于将系统中的一些函数库预先存放到内存中，让系统使用时可以比以往通过硬盘的读取速度来的更快，这样可以大幅提高系统性能，尤其当要重复读取时更明显；ldconfig要将哪些函数库丢到内存中，则须看/etc/ld.so.conf文件中所记录的信息； logrotate.d：此目录对系统管理员来说，是十分重要的一个目录，因为目录中的文件，记录了如何定期备份系统所需要备份的系统或软件日志文件及备份方式，目录是由logrotate组件所提供的，而里面所有文件是由各软件各自产生的；其主要配置文件是/etc/logrotate.conf； logwatch：logrotate主要是实现如何备份日志文件，这个目录就是记载如何分析日志文件并告诉用户的软件logwatch的配置目录； lsb-release.d：LSB是一个由很多人所执行的项目，其目的是将所有的Linux发行版定义为一些共同的标准； lvm：这个目录是LVM的基本配置文件，但配置或操作一般都只需要通过LVM提供的命令，而不会用到这个目录，除非要使用到很高级的配置才会更改此文件； makedev.d：MAKEDEV软件对应的配置文件目录，MAKEDEV主要用来产生设备文件，也就是说，在/dev目录下的文件都由这个命令产生的，此目录下的文件主要是针对设备文件的定义或属性，目录中存在的设备文件可以由MAKEDEV来创建，否则需要使用mknod命令了； modprobe.d：是modprobe命令的住配置目录，一般系统启动默认要加载的模块放在/etc/modprobe.conf中； netplug和netplug.d：这两个目录和网络接口的联机与否由直接关系，因为主要是控制联机时的接口操作； opt：此目录原本是定义为存放所有额外安装软件的主机配置文件，但目前并没有被使用到，此目录为空； pcmcia：这是PCMCIA的配置文件目录，PCMCIA是笔记本电脑不可或缺的接口，需要即插即用的方式，此接口使用较少； pm：由pm-utils组件所提供的目录，pm-utils是一套电源管理的工具软件，其中/usr/lib/pm-utils也是主要目录之一； ppp：ppp相关的配置文件都放在这个目录中； profile.d：这个目录存放的是系统部分的软件配置，但会按不同的shell执行不同的文件，默认所使用的bash会直接执行该目录下所有扩展名为.sh的文件； rc.d：主要用来定义在每一个执行阶段必须要执行哪些系统服务或程序，在目录中主要分为三个重要的部分： --rc.sysinit：系统一开始启动时所遇到的第一个文件，此脚本文件记录服务启动之前所需准备的所有事情，包括启动时看到的欢迎画面； --rcX.d：在rc.sysinit文件之后所要执行的，X是系统启动时的initdefault值，值为几则会转到那个目录下，并执行其中的所有文件，在此目录中，文件一律都由两个英文字母开始K和S，K代表kill，S代表Start； --rc.local：系统初始化过程中最后一个执行的脚本文件，可以将需要开机启动的程序或脚本放置在这个脚本文件中，以实现自动运行的目的； readahead.d：是readahead程序的主要配置目录，为了加速操作系统的使用速度，readahead_early和readahead_later这两个进程在系统加载时，直接将日常所需要的一些文件，全部先放到硬盘的高速缓存中； redhat-lsb：都lsb-release.d目录都是由程序redhat-lsb所提供的； rwtab.d：这个目录是一个在启动时会去参考的目录，主要的文件在/etc/rwtab；这是一个系统初期的备份机制； sane.d：这是在系统下要使用扫描仪所需的配置目录，主要配置文件是sane.conf，sane为了方便用户在各式的扫描仪连接时都可以使用，因此，在这一目录中放置了很多种不同类型扫描仪的硬件信息，让系统在检测到扫描仪时可以直接使用； setuptool.d：这个目录是&quot;setup&quot;系统配置工具的主要配置目录； skel：用于初始化用户宿主目录的配置目录，当建立一个用户时，会把此目录下的所有文件复制一份到用户的宿主目录，作为用户的初始化配置； sysconfig：非常重要的系统配置文件的存放目录，里面放置了大量系统启动及运行相关的配置文件； sysconfig/network-scripts/ifcfg-eth0：网卡eth0对应的配置文件，设置内容包括设备名称、IP地址、广播地址、网关地址、网段、开机是否激活等参数 udev：udev程序本身是一套设备的管理机制，udev通过sysfs的文件系统，可以正确地掌握目前系统上存在的硬件设备，以及针对每一个硬件设备做出不同的判断与执行； yum和yum.repos.d：这两个都是yum的配置目录，是一套在linux下可以自动帮助用户安装、更新、移除等的管理组件，可用来替代rpm包管理方式，主配置文件是/etc/yum.conf；yum是更新方式及外挂程序的配置目录，yum.repos.d是存放定期更新组件内容的信息； --安全性目录：如selinux或pam.d等管理系统安全性的目录； audit：这个目录所代表的是一种和目录名称一致的audit安全机制，主要以服务的方式协助管理员持续监控各文件被存取的情况；目录下的audit.rules文件主要是定义一些必要的监控规则； pam.d：此目录是Linux-PAM的所有配置文件，配合/lib/security目录中所有觉得函数库，提供Linux下的应用程序认证的机制； pam_pkcs11：PAM机制中的一种登录模块，可以让用户通过smart card做登录的操作； pki：PKI是一种公开密钥的管理方式，通过这样的管理模式，可以让所有网络传输有更多保障； racoon：这个目录是由ipsec-tools组件所提供的，ipsec的主要目的是让系统实现VPN的网路技术，在racoon目录的主配置文件racoon.conf中，定义在ipsec操作中所需要的加密算法种类以及其他细节的配置； security：与pam.d目录相辅相成，pam.d中的所有PAM的规则都要用到/lib/security下的PAM函数库，而/etc/security目录中，就是针对这些函数库，提供以配置文件的方式进行细节配置，对希望调整系统安全性部分增加了非常大的方便性； selinux：selinux是一个很新的安全性方案，它是一种针对各种文件、目录、设备或daemon等在linux所需使用到的安全性机制，而且其安全性的数据时直接记录在文件系统中； wpa_supplicant：这个目录被归类到安全性目录中，是因为其属于无线中安全认证的部分，存在wpa_supplicant.conf配置文件，用户可以在这个目录中加入已知可登陆的AP； --X Windows目录：如X11或gdm管理X windows启动或使用上的配置目录； alternatives：linux下可辨识扩展名的&quot;文件类型&quot;选项，可以针对同一类型的文件，选出一个默认用户所要使用的程序去执行；/etc/alternatives目录下有所有目前已经定义的程序名称，都以软链接的方式存在，里面每一个文件其实都有定义好的默认执行程序，可以使用alternatives命令查看及修改配置； fonts：这个目录就是fontconfig软件的最主要配置目录，其中/etc/fonts/fonts.conf就是对应的配置文件，/etc/fonts目录下的配置都是以XML的方式配置的； gconf：这一目录是GConf2的组件所建立的，GConf的作用就是提供GNOME下的应用程序注册的机制，有些类似于windows下的regedit； gdm：全名为GNOME Display Manger，也就是协助X Windows启动的管理软件，在GDM中的主配置文件是custom.conf，在X windows下可以利用gdmsetup命令对这个文件进行配置； gnome-vfs-2.0：GNOME VFS机制，让GNOME的系统可以知道每一种文件格式要如何开启或浏览，而所有的配置都需要有相对应的函数库； gtk-2.0：由gtk+组件提供的目录，主要是提供X Windows窗口的颜色、按钮或图案，包含软件选项的画面、选项的按钮、滚动轴的样式等； kde：KDE Desktop Manager的主要配置目录；主配置文件是kdmrc； NetworkManager：此目录的目的是让用户不需要做任何操作和配置，只要用户曾经登陆过无线AP，系统就可以记录下来，以后再次登陆时就可以方便的登陆; pango：pango是一套协助GTK+将字体描绘出来的函数库，不论任何的字体或语言，都可以通过pango描绘出来； rhgb：系统在进入X Windows之前，有一个前置配置的图形接口，这个接口就是rhgb，其主要目的是让系统启动变得漂亮； scim：是Linux下目前很好用的输入法； sound：GNOME下有许多的应用软件，很多都会有其特殊的声音，这个目录中存放所有声音的命令路径； X11：X windows的核心配置目录；该目录下比较重要的文件有prefdm(判断X windows使用哪一个Display Manager)、主配置文件xorg.conf(定了X windows所需使用的键盘、鼠标、显卡等相关硬件设备，重点是关于显卡的配置)、xinit子目录(里面都是一些X windows资源相关的配置) xdg：X windows上的菜单画面，就是从这里出来的，所有在X windows中使用的菜单文字及分类，都可以在这个目录下做配置，其下的子目录menu，可以通过配置里面的文件自定义应用程序、系统管理、外观等菜单内容 --其他目录：针对单一特殊软件的配置或未能按以上分类方式则放在此目录中； a2ps.cfg和a2ps-site.cfg：用于将一份文件格式转换为postscript的格式，在某些打印机或要将文件输出成一份标准格式的文件时，它会被用到； alsa：主要任务在于提供linux声音及声音的功能，并试着让其性能达到最佳化； ghostscript：在linux下要读取Adobe格式文件(如pdf)，最方便的方式就是使用ghostscript命令，这个目录主要用于设置在显示时使用哪种字体作为默认字体； gre.d：GRE是Mozilla注册的一种机制，目录中的配置文件gre.conf会注明所使用的Mozilla软件的路径和版本； iproute2：iproute2是一套非常强大的网络管理软件，iproute2提供的功能有很多种，此目录中存放一些网络的基本配置值； java：这个目录是由jpackage-utils软件提供的，这个目录是这个软件的主要配置目录，除此之外还有maven、jvm、jvm-common都是由jpackage-utils软件产生的，jpackage是一个专门为了提供java程序与函数库所存在的软件； mgetty+sendfax：主要用于使用linux架构一台fax server，可以使用mgetty.config来配置需要有关传真接收和发送的操作； php.d：主要存放的各软件(如dbase、ldap、mysql等)与php相关的配置文件； reader.conf.d：存放smart card配置文件的目录，由程序pcsc-lite提供，这个程序的主配置文件是/etc/reader.conf； dumpdates：存放dump命令的执行日期，dump命令可以对ext2/ext3文件系统进行检查备份； /lib：需要共享的函数库与kernel模块，系统kernel启动所使用的函数库，或者当执行一些在/bin和/sbin中的命令时使用的函数库； /media：移动存储设备默认挂载点；(如光盘) /mnt：临时挂载用的设备挂载点；(如磁盘分区，网络共享) /opt：额外所安装的应用程序目录,有些软件包我们可以将它安装在该目录中；(一般为空，某些应用软件安装需要这个目录) /root：管理员root的宿主目录 /sys：虚拟文件系统，被建立在内存中，是在2.6版的kernel之后才被加入到正式的文件系统中，以分类的方式将系统的信息存放在这个目录中，以方便linux用户通过不同的分类找出系统相关的信息； /tmp：临时文件存放区域；(默认被设置了粘滞位) /var：动态文件或数据存放目录，默认日志文件都存放在这个目录下，一般建议把此目录单独划分一个分区；/var/account：是linux系统下的审核机制(psacct)对应的目录； /var/cache：该目录下的文件时所有程序所产生的缓存数据，也就是当应用程序启动时，会将数据留一份在这个目录中； /var/empty：默认是sshd程序用到的这个目录，当建立ssh连接，ssh服务器必须使用该目录下的sshd子目录； /var/ftp：ftp服务器软件一般默认会将匿名登陆的用户的宿主目录； /var/gdm：gdm所使用的目录，里面存放一些系统当前所占用的console记录及通过gdm执行的X windows记录，只有通过gdm窗口的日志才会存放在此； /var/lib：该目录下存放很多与应用程序名称同名的子目录，每个子目录下都是应用执行的状态信息； /var/lock：每个服务一开始都会在这个目录下产生一个该服务的空文件，主要是避免服务启动冲突； /var/log：常用目录，专门用来存放所有日志文件的目录，里面存放很多系统、软件、用户等相关的日志信息；里面有一些文件是比较常用的； lastlog：记录用户最后一次登录的信息，使用lastlog命令读取； message：记录系统的几乎所有信息，主要包括启动信息，syslogd服务记录的信息等； wtmp：记录所有用户登陆及注销的信息，使用last命令读取； secure：记录登录系统访问数据的文件，如ssh pop3 telnet ftp等都会记录在此文件中 /var/log/httpd/access_log：httpd访问日志 /var/log/httpd/error_log：httpd错误日志 btmp：记录失败的用户登录 utmp： 纪录当前登录的每个用户 xferlog：ftp会话日志 boot.log：记录开机或一些服务启动时所显示的启动和关闭信息 /var/log/maillog或/var/log/mail/*：记录邮件访问或往来的用户信息 cron： 记录crontab例行性服务的内容 dmesg：开机引导日志信息 sudolog：纪录使用sudo发出的命令 sulog： 纪录使用su命令的使用 /var/named：bind软件实现的DNS服务器的区域数据文件都存放在这个目录下； /var/nis和/var/yp：都是NIS服务机制所使用的目录，nis主要记录所有网络中每一个client的连接信息；yp是linux的nis服务的日志文件存放的目录； /var/run：此目录中的大部分文件都记载目前系统正在执行程序的PID值，每一个文件都是以个独立的PID记录；此目录下存放一个特殊文件utmp，此文件记录目前谁在使用系统，必须使用utmpdump命令才能看到其中的内容； /var/spool：里面主要都是一些临时存放，随时会被用户所调用的数据；打印机、邮件、代理服务器等假脱机目录存放在该目录下； /var/tmp：专门为了一些应用程序在安装或执行时，需要在重启后使用的某些文件时，能将该文件暂时存放在这个目录中，完成后再行删除； /var/www：apache网页服务器的宿主目录；]]></content>
      <categories>
        <category>Linux目录</category>
      </categories>
      <tags>
        <tag>Linux目录</tag>
        <tag>FHS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2015%2F03%2F01%2F2015-03-01-162610-Hello%20World%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
