<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-big-counter.min.css?v=1.0.2">



















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="产生背景：  开发人员将测试并运行正常的代码，交给运维人员部署后，部署失败，这就导致了开发人员和运维人员之间因为环境的不同出现很多矛盾，因此慢慢地出现了 DevOps 的概念。所谓的环境不同，指的是不同的操作系统、软件环境、组件版本、应用配置等。  在集群环境下，每台服务器都需要配置相同的环境，配置起来十分麻烦。  解决开发人员常说的 “我不管，在我的机器上是可以正常工作的” 的问题。   Doc">
<meta name="keywords" content="grub2,Docker,DevOps,CI&#x2F;CD">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker入坑指南">
<meta property="og:url" content="http://linuxgeeks.github.io/2019/12/02/152139-Docker入坑指南/index.html">
<meta property="og:site_name" content="Just Do It">
<meta property="og:description" content="产生背景：  开发人员将测试并运行正常的代码，交给运维人员部署后，部署失败，这就导致了开发人员和运维人员之间因为环境的不同出现很多矛盾，因此慢慢地出现了 DevOps 的概念。所谓的环境不同，指的是不同的操作系统、软件环境、组件版本、应用配置等。  在集群环境下，每台服务器都需要配置相同的环境，配置起来十分麻烦。  解决开发人员常说的 “我不管，在我的机器上是可以正常工作的” 的问题。   Doc">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://linuxgeeks.github.io/2019/12/02/152139-Docker入坑指南/01_docker_and_vm_01.png">
<meta property="og:image" content="http://linuxgeeks.github.io/2019/12/02/152139-Docker入坑指南/01_docker_and_vm_02.png">
<meta property="og:image" content="http://linuxgeeks.github.io/2019/12/02/152139-Docker入坑指南/02_docker_repository_01.png">
<meta property="og:image" content="http://linuxgeeks.github.io/2019/12/02/152139-Docker入坑指南/05_docker_image_01.png">
<meta property="og:image" content="http://linuxgeeks.github.io/2019/12/02/152139-Docker入坑指南/05_docker_image_02.png">
<meta property="og:image" content="http://linuxgeeks.github.io/2019/12/02/152139-Docker入坑指南/05_docker_image_03.png">
<meta property="og:updated_time" content="2020-01-17T06:57:47.188Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Docker入坑指南">
<meta name="twitter:description" content="产生背景：  开发人员将测试并运行正常的代码，交给运维人员部署后，部署失败，这就导致了开发人员和运维人员之间因为环境的不同出现很多矛盾，因此慢慢地出现了 DevOps 的概念。所谓的环境不同，指的是不同的操作系统、软件环境、组件版本、应用配置等。  在集群环境下，每台服务器都需要配置相同的环境，配置起来十分麻烦。  解决开发人员常说的 “我不管，在我的机器上是可以正常工作的” 的问题。   Doc">
<meta name="twitter:image" content="http://linuxgeeks.github.io/2019/12/02/152139-Docker入坑指南/01_docker_and_vm_01.png">



  <link rel="alternate" href="/atom.xml" title="Just Do It" type="application/atom+xml">



  
  
  <link rel="canonical" href="http://linuxgeeks.github.io/2019/12/02/152139-Docker入坑指南/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Docker入坑指南 | Just Do It</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Just Do It</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    
  
  

  

  <a href="https://github.com/linuxgeeks" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linuxgeeks.github.io/2019/12/02/152139-Docker入坑指南/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Silence">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just Do It">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Docker入坑指南

              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-02 15:21:39" itemprop="dateCreated datePublished" datetime="2019-12-02T15:21:39+08:00">2019-12-02</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-17 14:57:47" itemprop="dateModified" datetime="2020-01-17T14:57:47+08:00">2020-01-17</time>
              </span>
            
          

          

          
            
            
          

          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
                 阅读次数： 
                <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
              </span>
            </span>
          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>产生背景：</p>
<ul>
<li><p>开发人员将测试并运行正常的代码，交给运维人员部署后，部署失败，这就导致了开发人员和运维人员之间因为环境的不同出现很多矛盾，因此慢慢地出现了 DevOps 的概念。所谓的环境不同，指的是不同的操作系统、软件环境、组件版本、应用配置等。</p>
</li>
<li><p>在集群环境下，每台服务器都需要配置相同的环境，配置起来十分麻烦。</p>
</li>
<li><p>解决开发人员常说的 “我不管，在我的机器上是可以正常工作的” 的问题。</p>
</li>
</ul>
<h1 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h1><h2 id="什么是-Docker-？"><a href="#什么是-Docker-？" class="headerlink" title="什么是 Docker ？"></a>什么是 Docker ？</h2><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们开发的应用程序以及程序的依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
<p>Docker 使用 Google 公司推出的 Go 语言进行开发实现，基于 Linux 内核的 <strong>cgroup</strong>，<strong>namespace</strong>，以及 AUFS 类的 Union FS 等技术，<strong>对进程进行封装隔离</strong>，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主机和其它的隔离的进程，因此也称其为容器。</p>
<p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p>
<h2 id="容器和虚拟机"><a href="#容器和虚拟机" class="headerlink" title="容器和虚拟机"></a>容器和虚拟机</h2><p>下面的图片比较了 Docker 容器技术和传统虚拟机技术的不同之处：</p>
<p><img src="/2019/12/02/152139-Docker入坑指南/01_docker_and_vm_01.png" alt=""></p>
<p>虚拟机（VM）是虚拟出一套硬件（CPU、Memory 等）后，在其上运行一个完整操作系统，它是将一台服务器转变为多台服务器的物理硬件的抽象。系统管理程序允许多个VM在单台计算机上运行。每个VM包含操作系统，应用程序，必要的二进制文件和库的完整副本，这种方式占用大量资源（数十GB），并且VM也可能启动缓慢。</p>
<p><img src="/2019/12/02/152139-Docker入坑指南/01_docker_and_vm_02.png" alt=""></p>
<p>容器将代码和依赖项打包在一起，容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。</p>
<p>多个容器可以在同一台计算机上运行，并与其他容器共享宿主机的内核，每个容器在用户空间中作为隔离的进程运行。容器占用的空间少于VM（容器镜像的大小通常为几十MB），可以处理更多的应用程序，启动速度更快，并且需要的 VM 和操作系统数量更少。</p>
<h2 id="为什么要使用-Docker-？"><a href="#为什么要使用-Docker-？" class="headerlink" title="为什么要使用 Docker ？"></a>为什么要使用 Docker ？</h2><p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。</p>
<p><strong>更高效的利用系统资源</strong></p>
<p>容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的物理主机，能运行的容器远大于虚拟机的数量，但是容器不能拿来当作虚拟机给客户使用。</p>
<p><strong>更快速的启动时间</strong></p>
<p>传统的虚拟机技术启动应用服务往往需要数分钟(实际上 OpenStack 虚拟化技术也能达到秒级启动)，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p>
<p><strong>一致的运行环境</strong></p>
<p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题。</p>
<p><strong>持续交付和部署</strong></p>
<p>对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p>
<p><strong>更轻松的迁移</strong></p>
<p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p>
<p><strong>更轻松的维护和扩展</strong></p>
<p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p>
<h2 id="容器技术对比传统虚拟机总结"><a href="#容器技术对比传统虚拟机总结" class="headerlink" title="容器技术对比传统虚拟机总结"></a>容器技术对比传统虚拟机总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>硬盘</td>
<td>使用一般为 MB</td>
<td>一般为 GB</td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>弱于原生</td>
</tr>
<tr>
<td>系统</td>
<td>支持量单机支持上千个容器</td>
<td>一般几十个</td>
</tr>
</tbody>
</table>
<p>容器技术属于进程之间的隔离，虚拟机技术可以实现系统级别隔离。物理机没有快照的概念，虚拟机的快照功能极大的提高了容灾性、数据备份等功能。我们可以授权给容器来操作宿主机，而虚拟机是无法操作宿主机的。</p>
<p>总而言之，容器技术虽然比虚拟机技术有着更多的优点，但是容器和虚拟机一起使用，在部署和管理应用程序时提供了很大的灵活性。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>Docker <strong>Host</strong>：安装了 Docker 程序的主机，运行 Docker 守护进程</p>
<p>Docker <strong>Image</strong>：镜像，将软件环境打包好的模板，用来创建容器的，一个镜像可以创建多个容器。</p>
<p>Docker <strong>Container</strong>：容器，运行镜像后生成的实例称为容器，每运行一次镜像就会产生一个容器，容器可以启动、停止或删除。容器使用是沙箱机制，互相隔离，是独立是安全的。可以把容器看作是一个简易版的 Linux 环境，包括用户权限、文件系统和运行的应用等。</p>
<p>Docker <strong>Repository</strong>：仓库，用来保存镜像，仓库中包含许多镜像，每个镜像都有不同的标签 Tag，在 <a href="https://hub.docker.com/" target="_blank" rel="noopener">官方仓库</a> 中可以搜索出很多镜像。</p>
<h1 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h1><p>Docker 划分为 CE 和 EE。CE 即社区版（免费，支持周期三个月），EE 即企业版，强调安全，付费使用。在官方网站上有各种环境下的 <a href="https://docs.docker.com/install/" target="_blank" rel="noopener">安装指南</a>  。</p>
<p>由于各项新技术（Systemd、Cgroup 等）的出现，以及容器技术的优势和不断成熟，进一步促进了内核更新，为了对容器技术有着更好的支持。建议使用较新版本的 Linux 系统，这里以 Docker CE 在 CentOS7 上的安装为例。</p>
<p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 overlay2 存储层驱动）无法使用，并且部分功能可能不太稳定。</p>
<h2 id="系统环境的配置"><a href="#系统环境的配置" class="headerlink" title="系统环境的配置"></a>系统环境的配置</h2><h3 id="运行环境配置"><a href="#运行环境配置" class="headerlink" title="运行环境配置"></a>运行环境配置</h3><p>时区，selinux、系统运行级别等的配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set timezone</span></span><br><span class="line">timedatectl <span class="built_in">set</span>-timezone Asia/Shanghai</span><br><span class="line"></span><br><span class="line"><span class="comment"># Maintain the RTC in universal time. Use RTC in UTC by calling</span></span><br><span class="line">timedatectl <span class="built_in">set</span>-local-rtc 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sync system time to hwclock</span></span><br><span class="line">hwclock --systohc --localtime</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set runlevel</span></span><br><span class="line">systemctl <span class="built_in">set</span>-default multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># Turn off selinux</span></span><br><span class="line">setenforce 0</span><br><span class="line">sed -ri <span class="string">'s/(^SELINUX=).*/\1disabled/'</span> /etc/sysconfig/selinux /etc/selinux/config</span><br></pre></td></tr></table></figure>
<h3 id="系统服务配置"><a href="#系统服务配置" class="headerlink" title="系统服务配置"></a>系统服务配置</h3><p>firewalld 功能更强大，但是生成的防火墙规则和链比较繁琐，使用 iptables 命令完全够用，这里将其停止并禁止开机自启：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> --now firewalld.service</span><br></pre></td></tr></table></figure>
<p>NetworkManager 服务早期一直用来管理图形化界面 Linux 的网络，从 CentOS8 开始，它已经完全取代了 network 服务，并且使用 <code>nmcli</code> 命令来管理非图形化界面 Linux 的网络。因此不建议对 NetworkManager 做操作，如果对 NetworkManager 比较了解，你也可以选择在 CentOS7 上将其关停：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> --now NetworkManager.service</span><br></pre></td></tr></table></figure>
<p>在图形界面 Linux 上默认会安装 Dnsmasq 来配置本地自有 DNS 服务器，这有可能会导致 <code>nameserver</code>  被设置为 <code>127.0.0.1</code>，从而导致容器无法解析域名。因此将其关停：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> --now dnsmasq.service</span><br></pre></td></tr></table></figure>
<h3 id="资源使用限定"><a href="#资源使用限定" class="headerlink" title="资源使用限定"></a>资源使用限定</h3><p>默认的 limit 数值较小，手动改 <code>/etc/security/limits.conf</code> 或在 <code>/etc/security/limits.d/</code> 创建自定义配置文件，来修改资源的限定：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Modify shell resource limits</span></span><br><span class="line">cat &gt; /etc/security/limits.d/my-limits.conf &lt;&lt; EOF</span><br><span class="line">*       soft    nproc   131072</span><br><span class="line">*       hard    nproc   131072</span><br><span class="line">*       soft    nofile  131072</span><br><span class="line">*       hard    nofile  131072</span><br><span class="line">root    soft    nproc   131072</span><br><span class="line">root    hard    nproc   131072</span><br><span class="line">root    soft    nofile  131072</span><br><span class="line">root    hard    nofile  131072</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>对 Systemd 的资源使用做设置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Modify systemd resource limits</span></span><br><span class="line">sed -ri <span class="string">'/^DefaultLimit(NOFILE|NPROC)/d'</span> /etc/systemd/&#123;system,user&#125;.conf</span><br><span class="line"></span><br><span class="line">cat &gt;&gt; /etc/systemd/system.conf &lt;&lt; <span class="string">'EOF'</span></span><br><span class="line">DefaultLimitNOFILE=131072</span><br><span class="line">DefaultLimitNPROC=131072</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &gt;&gt; /etc/systemd/user.conf &lt;&lt; <span class="string">'EOF'</span></span><br><span class="line">DefaultLimitNOFILE=131072</span><br><span class="line">DefaultLimitNPROC=131072</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<h3 id="内核参数设置"><a href="#内核参数设置" class="headerlink" title="内核参数设置"></a>内核参数设置</h3><p>设置 iptables 不对 bridge 的数据进行处理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt; EOF &gt; /etc/sysctl.d/docker.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.bridge.bridge-nf-call-arptables = 1</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
<p>修改内核的环境变量配置文件 <code>/etc/default/grub</code>，在 <code>GRUB_CMDLINE_LINUX=</code> 中启用内核的 <code>user_namespaces</code> ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp /boot/grub2/grub.cfg&#123;,.old&#125;;</span><br><span class="line">sed -ri <span class="string">'/GRUB_CMDLINE_LINUX/s#('</span><span class="string">"'"</span><span class="string">'|")$# user_namespace.enable=1 \1#'</span>  /etc/default/grub</span><br><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure>
<p>使用 <code>grubby</code> 命令也可以直接修改 <code>/boot/grub2/grub.cfg</code> 中的 grub 策略：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grubby --args=<span class="string">"user_namespace.enable=1"</span> --update-kernel=<span class="string">"<span class="variable">$(grubby --default-kernel)</span>"</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 这并不会更新 <code>/etc/default/grub</code> ，所以最稳妥的办法还是修改 <code>/etc/default/grub</code> 然后重新生成配置。</p>
<p>配置完成后需要重启系统才能让参数生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl reboot</span><br></pre></td></tr></table></figure>
<h2 id="安装-Docker-1"><a href="#安装-Docker-1" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><p>官方提供了配置检查脚本，用来检查环境是否符合要求：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://raw.githubusercontent.com/docker/docker/master/contrib/check-config.sh -o check-config.sh</span><br><span class="line">bash ./check-config.sh</span><br></pre></td></tr></table></figure>
<p>使用官方脚本安装，为了有更快的速度，可以将镜像下载源指定为 <code>Aliyun</code> ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh &amp;&amp; sh get-docker.sh --mirror Aliyun</span><br></pre></td></tr></table></figure>
<p>安装完成后查看版本，验证安装是否成功：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>
<h2 id="后续配置"><a href="#后续配置" class="headerlink" title="后续配置"></a>后续配置</h2><p>安装 bash 补全包，安装后可以为 <code>systemd</code> 、<code>ip</code> 、 <code>docker</code> 等命令做子命令的补全，当然还可以自定义。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install bash-completion</span><br></pre></td></tr></table></figure>
<p>安装完成后重新登录机器即可生效，如果未生效则可以拷贝 Docker 自己生成的补全脚本到系统的 bash 补全配置目录下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -a /usr/share/bash-completion/completions/docker <span class="variable">$&#123;BASH_COMPLETION_COMPAT_DIR&#125;</span>/</span><br></pre></td></tr></table></figure>
<h2 id="配置-Docker-守护进程"><a href="#配置-Docker-守护进程" class="headerlink" title="配置 Docker 守护进程"></a>配置 Docker 守护进程</h2><p>官方文档：</p>
<ul>
<li><a href="https://docs.docker.com/config/daemon/" target="_blank" rel="noopener">配置并运行Docker</a></li>
</ul>
<ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/dockerd/" target="_blank" rel="noopener">守护进程的命令行选项</a></li>
</ul>
<p>常用配置：</p>
<ul>
<li><p>网络：</p>
<ul>
<li>默认情况下 docker0 网卡分配的 IP 地址是 <code>172.17.0.1</code>，所在的地址段是 <code>172.17.0.0/16</code> ， 如果有冲突可以自行定义。</li>
<li>DNS：如果不想让 Docker 使用主机的 <code>nameserver</code> ，可以使用 <code>dns</code> 来指定自定义的 DNS 服务器。</li>
</ul>
</li>
<li><p>存储驱动：</p>
<ul>
<li>默认存储引擎和受支持的存储引擎列表取决于主机的 Linux 发行版和可用的内核驱动程序，建议使用 <code>overlay2</code>，详情请看 <a href="https://docs.docker.com/storage/storagedriver/" target="_blank" rel="noopener">官方扫盲</a>。</li>
<li>允许覆盖 overlay2 的 Linux 内核版本检查：在 4.0.0 版本内核中，添加了对 overlay2 所需的多个较低目录的支持。但是，可能会修补某些较旧的内核版本，以添加对 OverlayFS 的多个较低目录支持。仅在验证内核中存在此支持后，才应使用此选项。在没有此支持的情况下在内核上应用此选项将导致安装失败。</li>
</ul>
</li>
<li><p>日志驱动：</p>
<ul>
<li>Docker 提供了通过一系列日志记录驱动程序，用来收集和查看主机上运行的所有容器的日志数据。默认的日志记录驱动程序 <code>json-file</code> 将日志数据写入主机文件系统上的 JSON 格式的文件。</li>
<li>日志轮转：随着时间的推移，这些日志文件的大小会扩大，从而可能导致磁盘资源耗尽。要缓解此类问题，请配置备用日志记录驱动程序（例如 Splunk 或 Syslog ），或为默认驱动程序<a href="https://docs.docker.com/config/containers/logging/configure/#configure-the-default-logging-driver" target="_blank" rel="noopener">设置日志轮转</a>。</li>
</ul>
</li>
<li><p>runtime：使用 <code>--exec-opt</code> 标志指定的选项来配置 runtime。所有标志的选项都有 <code>native</code> 前缀，有一个 <code>native.cgroupdriver</code> 选项可用。该选项指定用什么来进行容器的 cgroup 管理。只能指定 <code>cgroupfs</code> 或 <code>systemd</code> 。如果指定 <code>systemd</code> 并且不可用，则系统会出错。如果没有配置 <code>native.cgroupdriver</code> 选项，则使用 <code>cgroupfs</code> 进行管理。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mkdir -pv /etc/docker/</span><br><span class="line">cat &gt;| /etc/docker/daemon.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"bip"</span>: <span class="string">"172.17.0.1/16"</span>,</span><br><span class="line">    <span class="string">"dns"</span>: [</span><br><span class="line">        <span class="string">"8.8.8.8"</span>,</span><br><span class="line">        <span class="string">"8.8.4.4"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"storage-driver"</span>: <span class="string">"overlay2"</span>,</span><br><span class="line">    <span class="string">"storage-opts"</span>: [</span><br><span class="line">        <span class="string">"overlay2.override_kernel_check=true"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"log-driver"</span>: <span class="string">"json-file"</span>,</span><br><span class="line">    <span class="string">"log-opts"</span>: &#123;</span><br><span class="line">        <span class="string">"max-size"</span>: <span class="string">"10m"</span>,</span><br><span class="line">        <span class="string">"max-file"</span>: <span class="string">"5"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"exec-opts"</span>: [</span><br><span class="line">        <span class="string">"native.cgroupdriver=systemd"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<h2 id="配置-Docker-镜像加速器"><a href="#配置-Docker-镜像加速器" class="headerlink" title="配置 Docker 镜像加速器"></a>配置 Docker 镜像加速器</h2><p>国内访问 Docker Hub 下载镜像有时候会比较慢，此时可以配置镜像加速器。国内一些云服务商提供了容器镜像加速服务，例如：</p>
<ul>
<li><p><a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener">阿里云加速器</a></p>
</li>
<li><p><a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">DaoCloud 加速器</a></p>
</li>
</ul>
<p>如果网络质量较好，这一步可以忽略不做。以阿里云为例，以下是配置步骤：</p>
<p>1、注册并登录 “阿里云的容器镜像服务控制台” <a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener">https://cr.console.aliyun.com/</a></p>
<p>2、查看专属的加速器地址。</p>
<p>3、配置自己的 Docker 加速器，注意一定要保证该文件符合 json 规范，否则 Docker 将不能启动。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"registry-mirrors"</span>: [</span><br><span class="line">        <span class="string">"https://sswv6yx0.mirror.aliyuncs.com"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure>
<p>检查加速器是否生效：配置加速器之后，如果拉取镜像仍然十分缓慢，请手动检查加速器配置是否生效，在命令行<br>执行 <code>docker info</code> ，如果从结果中看到了如下内容，说明配置成功：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line"> https://sswv6yx0.mirror.aliyuncs.com/</span><br></pre></td></tr></table></figure>
<h2 id="使用-Systemd-控制-Docker"><a href="#使用-Systemd-控制-Docker" class="headerlink" title="使用 Systemd 控制 Docker"></a>使用 Systemd 控制 Docker</h2><p>将 docker 设置为开机自启，并启动该服务程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> --now docker.service</span><br></pre></td></tr></table></figure>
<p>查看服务的运行状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker.service</span><br></pre></td></tr></table></figure>
<h1 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h1><p>Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。</p>
<h2 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h2><p>Docker 提供了一个官方专业存放镜像的地方，即镜像仓库 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，在这上面有大量的高质量的镜像可以使用。打开 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a> 后点击 “Explore” 即可进入仓库列表页面。</p>
<p><img src="/2019/12/02/152139-Docker入坑指南/02_docker_repository_01.png" alt=""></p>
<p>在搜索框可以输入相关的镜像名称进行搜索，以 Nginx 为例，在搜索到的镜像中会有 “Tags” 按钮，这就是镜像的标签列表，标签表示了不同的版本。</p>
<p>为什么要有标签呢？<code>镜像 = &lt;仓库&gt;:[Tag]</code>。一个 Docker Registry 中可以包含多个仓库 （Repository）；每个仓库可以包含多个标签 （Tag）；每个标签对应一个镜像 （Image）。</p>
<p>在命令行可以使用 <code>docker search</code> 进行搜索，命令基本语法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search [选项] &lt;镜像ID/镜像名称&gt;[:标签]</span><br></pre></td></tr></table></figure>
<p>其中 <code>[]</code> 表示可选，<code>&lt;&gt;</code> 表示必选。镜像名称一般为 “&lt;用户名&gt;/&lt;软件名&gt;”，只有软件名的一般是官方镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker search nginx</span></span><br><span class="line">NAME                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">nginx                             Official build of Nginx.                        12311               [OK]                </span><br><span class="line">jwilder/nginx-proxy               Automated Nginx reverse proxy <span class="keyword">for</span> docker con…   1698                                    [OK]</span><br><span class="line">richarvey/nginx-php-fpm           Container running Nginx + PHP-FPM capable of…   746                                     [OK]</span><br><span class="line">linuxserver/nginx                 An Nginx container, brought to you by LinuxS…   83</span><br></pre></td></tr></table></figure>
<p>从上面的命令执行的结果中，并不能看到镜像的标签，所以要下载特定镜像还需要在网页上搜索查找。</p>
<h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code> 。其命令格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure>
<p>镜像名称的格式：</p>
<ul>
<li><p>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code> 。默认地址是 Docker Hub。</p>
</li>
<li><p>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code> 。对于 Docker Hub，如果不给出用户名，则默认为 library ，也就是官方镜像。</p>
</li>
</ul>
<p>下面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 <code>nginx:latest</code> ，因此将会获取官方镜像 <code>library/nginx</code> 仓库中标签为 <code>latest</code> 的镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx:latest</span><br></pre></td></tr></table></figure>
<p>从下载过程中可以看到分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 sha256 的摘要信息，以确保下载一致性。</p>
<p>有可能你看到的层 ID 以及 sha256 的摘要和这里的不一样。这是因为官方镜像是一直在维护的，有任何新的 bug，或者版本更新，都会进行修复再以原来的标签发布，这样可以确保任何使用这个标签的用户可以获得更安全、更稳定的镜像。</p>
<h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令或 <code>docker images</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">httpd               latest              2ae34abc2ed0        12 days ago         165MB</span><br><span class="line">python              latest              0a3a95c81a2b        2 weeks ago         932MB</span><br><span class="line">mysql               latest              d435eee2caa5        2 weeks ago         456MB</span><br><span class="line">nginx               latest              231d40e811cd        2 weeks ago         126MB</span><br><span class="line">ubuntu              18.04               775349758637        5 weeks ago         64.2MB</span><br><span class="line">ubuntu              latest              775349758637        5 weeks ago         64.2MB</span><br><span class="line">centos              latest              0f3e07c0138f        2 months ago        220MB</span><br><span class="line">hello-world         latest              fce289e99eb9        11 months ago       1.84kB</span><br><span class="line">[root@bogon ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">httpd               latest              2ae34abc2ed0        12 days ago         165MB</span><br><span class="line">python              latest              0a3a95c81a2b        2 weeks ago         932MB</span><br><span class="line">mysql               latest              d435eee2caa5        2 weeks ago         456MB</span><br><span class="line">nginx               latest              231d40e811cd        2 weeks ago         126MB</span><br><span class="line">ubuntu              18.04               775349758637        5 weeks ago         64.2MB</span><br><span class="line">ubuntu              latest              775349758637        5 weeks ago         64.2MB</span><br><span class="line">centos              latest              0f3e07c0138f        2 months ago        220MB</span><br><span class="line">hello-world         latest              fce289e99eb9        11 months ago       1.84kB</span><br></pre></td></tr></table></figure>
<p>不加任何参数则列出所有镜像，也可以指定镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker image ls ubuntu</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              18.04               775349758637        5 weeks ago         64.2MB</span><br><span class="line">ubuntu              latest              775349758637        5 weeks ago         64.2MB</span><br><span class="line">[root@bogon ~]<span class="comment"># docker images ubuntu  </span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              18.04               775349758637        5 weeks ago         64.2MB</span><br><span class="line">ubuntu              latest              775349758637        5 weeks ago         64.2MB</span><br><span class="line">[root@bogon ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>列表包含了 <code>仓库名</code> 、 <code>标签</code> 、 <code>镜像 ID</code> 、 <code>创建时间</code> 以及 <code>所占用的空间</code> 。其中 <code>镜像 ID</code> 是镜像的唯一标识，一个镜像可以对应多个标签。因此，在上面命令执行结果中，可以看到 <code>ubuntu:18.04</code> 和 <code>ubuntu:latest</code> 拥有相同的 ID，因为它们对应的是同一个镜像。</p>
<h3 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h3><p>在 Docker Hub 中显示的镜像的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 <code>docker image ls</code> 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。</p>
<p>另外一个需要注意的问题是， <code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p>
<p>使用 <code>docker system df</code> 命令可以便捷地查看镜像、容器、数据卷所占用的空间。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker system df</span></span><br><span class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</span><br><span class="line">Images              7                   1                   1.894GB             1.798GB (94%)</span><br><span class="line">Containers          2                   0                   28B                 28B (100%)</span><br><span class="line">Local Volumes       0                   0                   0B                  0B</span><br><span class="line">Build Cache         0                   0                   0B                  0B</span><br><span class="line">[root@bogon ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<h3 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h3><p>在镜像列表中，有可能看到特殊的镜像，既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code> 。这种镜像原本是有镜像名和标签的，比如原来为 <code>mongo:3.2</code> ，随着官方镜像维护，发布了新版本后，重新 <code>docker pull mongo:3.2</code> 时，<code>mongo:3.2</code> 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>&lt;none&gt;</code> 。除了 <code>docker pull</code> 可能导致这种情况， <code>docker build</code> 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none&gt;</code> 的镜像。这类无标签镜像也被称为 虚悬镜像 (dangling image) ，可以用下面的命令专门显示这类镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls --filter dangling=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除没有被使用到的镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure>
<h3 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h3><p>为了加速镜像构建、重复利用资源，Docker 会利用中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 <code>docker image ls</code> 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 <code>-a</code> 参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls -a</span><br></pre></td></tr></table></figure>
<p>这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份。删除镜像后，依赖的中间层镜像也会被连带删除。</p>
<h3 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h3><p>不加任何参数的情况下， <code>docker image ls</code> 会列出所有顶级镜像，但是有时候我们只希望列出部分镜像。 <code>docker image ls</code> 有好几个参数可以帮助做到这个事情。</p>
<p>根据仓库名列出镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker image ls ubuntu</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              18.04               775349758637        5 weeks ago         64.2MB</span><br><span class="line">ubuntu              latest              775349758637        5 weeks ago         64.2MB</span><br><span class="line">[root@bogon ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>列出特定的某个镜像，也就是说指定仓库名和标签：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker image ls ubuntu:18.04 </span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              18.04               775349758637        5 weeks ago         64.2MB</span><br><span class="line">[root@bogon ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>除此以外， <code>docker image ls</code> 还支持强大的过滤器参数 <code>--filter</code> ，或者简写 <code>-f</code> 。之前使用过滤器来列出虚悬镜像的用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls --filter dangling=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>如果想要看到在 <code>ubuntu:19.04</code> 之后建立的镜像，可以用下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker image ls --filter since=ubuntu:19.04 </span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">httpd               latest              2ae34abc2ed0        12 days ago         165MB</span><br><span class="line">python              latest              0a3a95c81a2b        2 weeks ago         932MB</span><br><span class="line">mysql               latest              d435eee2caa5        2 weeks ago         456MB</span><br><span class="line">nginx               latest              231d40e811cd        2 weeks ago         126MB</span><br><span class="line">[root@bogon ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>想查看某个位置之前的镜像，只需要把 <code>since</code> 换成 <code>before</code> 即可。此外，如果镜像构建时，定义了 <code>LABEL</code> ，还可以通过 <code>LABEL</code> 来过滤。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls --filter label=com.example.version=0.1</span><br></pre></td></tr></table></figure>
<h3 id="以特定格式显示"><a href="#以特定格式显示" class="headerlink" title="以特定格式显示"></a>以特定格式显示</h3><p>默认情况下， <code>docker image ls</code> 会输出一个完整的表格，但是并非所有时候都会需要这些内容。比如，删除虚悬镜像的时候，需要利用 <code>docker image ls</code> 把所有的虚悬镜像的 ID 列出来，然后才可以交给 <code>docker image rm</code> 命令作为参数来删除指定的这些镜像，这时候就用到了 <code>-q</code> 参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker image ls  -q</span></span><br><span class="line">2ae34abc2ed0</span><br><span class="line">0a3a95c81a2b</span><br><span class="line">d435eee2caa5</span><br><span class="line">231d40e811cd</span><br><span class="line">51b0783967fc</span><br><span class="line">775349758637</span><br><span class="line">775349758637</span><br><span class="line">0f3e07c0138f</span><br><span class="line">fce289e99eb9</span><br><span class="line">[root@bogon ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>--filter</code> 配合 <code>-q</code> 产生出指定范围的 ID 列表，然后送给另一个 docker 命令作为参数，从<br>而针对这组实体成批的进行某种操作。这种做法在 Docker 命令行使用过程中非常常见，不仅仅是<br>镜像命令，在各个命令中都可以使用这类搭配以完成很强大的功能。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker image ls --filter since=nginx:latest </span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">httpd               latest              2ae34abc2ed0        12 days ago         165MB</span><br><span class="line">python              latest              0a3a95c81a2b        2 weeks ago         932MB</span><br><span class="line">mysql               latest              d435eee2caa5        2 weeks ago         456MB</span><br><span class="line">[root@bogon ~]<span class="comment"># docker image ls --filter since=nginx:latest -q</span></span><br><span class="line">2ae34abc2ed0</span><br><span class="line">0a3a95c81a2b</span><br><span class="line">d435eee2caa5</span><br><span class="line">[root@bogon ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>如果只是对表格的结构不满意，希望自己组织列；或者不希望有标题，这样方便其它程序解析结果等，这就用到了 <a href="https://gohugo.io/templates/introduction/" target="_blank" rel="noopener">Go 的模板语法</a>。比如只接列出镜像结果，并且只包含镜像ID和仓库名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker image ls --format "&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;"            </span></span><br><span class="line">2ae34abc2ed0: httpd</span><br><span class="line">0a3a95c81a2b: python</span><br><span class="line">d435eee2caa5: mysql</span><br><span class="line">231d40e811cd: nginx</span><br><span class="line">51b0783967fc: ubuntu</span><br><span class="line">775349758637: ubuntu</span><br><span class="line">775349758637: ubuntu</span><br><span class="line">0f3e07c0138f: centos</span><br><span class="line">fce289e99eb9: hello-world</span><br><span class="line">[root@bogon ~]<span class="comment"># docker image ls --format "&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125; &#123;&#123;.Size&#125;&#125;"</span></span><br><span class="line">2ae34abc2ed0: httpd 165MB</span><br><span class="line">0a3a95c81a2b: python 932MB</span><br><span class="line">d435eee2caa5: mysql 456MB</span><br><span class="line">231d40e811cd: nginx 126MB</span><br><span class="line">51b0783967fc: ubuntu 70MB</span><br><span class="line">775349758637: ubuntu 64.2MB</span><br><span class="line">775349758637: ubuntu 64.2MB</span><br><span class="line">0f3e07c0138f: centos 220MB</span><br><span class="line">fce289e99eb9: hello-world 1.84kB</span><br><span class="line">[root@bogon ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>如果想要以表格等距显示，并且有标题行，和默认一样，但是想定义列：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker image ls --format "table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;\t&#123;&#123;.Size&#125;&#125;"              </span></span><br><span class="line">IMAGE ID            REPOSITORY          TAG                 SIZE</span><br><span class="line">2ae34abc2ed0        httpd               latest              165MB</span><br><span class="line">0a3a95c81a2b        python              latest              932MB</span><br><span class="line">d435eee2caa5        mysql               latest              456MB</span><br><span class="line">231d40e811cd        nginx               latest              126MB</span><br><span class="line">51b0783967fc        ubuntu              19.04               70MB</span><br><span class="line">775349758637        ubuntu              18.04               64.2MB</span><br><span class="line">775349758637        ubuntu              latest              64.2MB</span><br><span class="line">0f3e07c0138f        centos              latest              220MB</span><br><span class="line">fce289e99eb9        hello-world         latest              1.84kB</span><br><span class="line">[root@bogon ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure>
<h3 id="用-ID、镜像名、摘要删除镜像"><a href="#用-ID、镜像名、摘要删除镜像" class="headerlink" title="用 ID、镜像名、摘要删除镜像"></a>用 ID、镜像名、摘要删除镜像</h3><p>其中， <code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code> 、 <code>镜像长 ID</code> 、 <code>镜像名</code> 或者 <code>镜像摘要</code> 。可以用镜像的完整 ID，也称为 <code>长 ID</code> ，来删除镜像，但是更多的时候是用 <code>短 ID</code> 来删除镜像。</p>
<p>默认情况下  <code>docker image ls</code> 列出的是短 ID ，一般取前3个字符以上，只要足够区分于别的镜像即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker image ls redis</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">redis               latest              dcf9ec9265e0        2 weeks ago         98.2MB</span><br><span class="line">redis               alpine              a49ff3e0d85f        2 weeks ago         29.3MB</span><br><span class="line">[root@bogon ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>比如要删除 <code>redis:alpine</code> 镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm a49ff3e0d85f</span><br></pre></td></tr></table></figure>
<p>也可以用 镜像名 ，也就是 <code>&lt;仓库名&gt;:&lt;标签&gt;</code>  来删除镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm redis:latest</span><br></pre></td></tr></table></figure>
<p>当然，更精确的是使用 <code>镜像摘要</code> 删除镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker image ls --digests  --format "table&#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Digest&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;" redis </span></span><br><span class="line">IMAGE ID            DIGEST                                                                    REPOSITORY          TAG</span><br><span class="line">dcf9ec9265e0        sha256:1eedfc017b0cd3e232878ce38bd9328518219802a8ef37fe34f58dcf591688ef   redis               latest</span><br><span class="line">a49ff3e0d85f        sha256:ee13953704783b284c080b5b0abe4620730728054f5c19e9488d7a97ecd312c5   redis               alpine</span><br><span class="line">[root@bogon ~]<span class="comment"># </span></span><br><span class="line">[root@bogon ~]<span class="comment"># docker image rm redis@sha256:ee13953704783b284c080b5b0abe4620730728054f5c19e9488d7a97ecd312c5</span></span><br><span class="line">Untagged: redis@sha256:ee13953704783b284c080b5b0abe4620730728054f5c19e9488d7a97ecd312c5</span><br><span class="line">[root@bogon ~]<span class="comment"># </span></span><br><span class="line">[root@bogon ~]<span class="comment"># docker image ls --digests  --format "table&#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Digest&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;" redis</span></span><br><span class="line">IMAGE ID            DIGEST                                                                    REPOSITORY          TAG</span><br><span class="line">dcf9ec9265e0        sha256:1eedfc017b0cd3e232878ce38bd9328518219802a8ef37fe34f58dcf591688ef   redis               latest</span><br><span class="line">a49ff3e0d85f        &lt;none&gt;                                                                    redis               alpine</span><br></pre></td></tr></table></figure>
<h3 id="Untagged-和-Deleted"><a href="#Untagged-和-Deleted" class="headerlink" title="Untagged 和 Deleted"></a>Untagged 和 Deleted</h3><p>删除行为分为两类，一类是 <code>Untagged</code> ，另一类是 <code>Deleted</code> 。镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker image ls redis</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">redis               latest              dcf9ec9265e0        2 weeks ago         98.2MB</span><br><span class="line">redis               alpine              a49ff3e0d85f        2 weeks ago         29.3MB</span><br><span class="line">[root@bogon ~]</span><br></pre></td></tr></table></figure>
<p>因此当删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足要求的所有镜像标签都取消，这就是我们看到的 Untagged 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 <code>Delete</code> 行行为就不会发生。所以并非所有的 <code>docker rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p>
<p>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变动非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是有时候明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 <code>docker pull</code> 看到的层数不一样的原因。</p>
<p>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。</p>
<h3 id="用-docker-image-ls-命令来配合"><a href="#用-docker-image-ls-命令来配合" class="headerlink" title="用 docker image ls 命令来配合"></a>用 docker image ls 命令来配合</h3><p>使用 <code>docker image ls -q</code> 来配合使用 <code>docker image rm</code> ，可以批量删除镜像。比如，要删除所有仓库名为 <code>redis</code> 的镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm $(docker image ls -q redis)</span><br></pre></td></tr></table></figure>
<p>或者删除所有在 <code>mongo:3.2</code> 之前的镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm $(docker image ls -q --filter before=mongo:3.2)</span><br></pre></td></tr></table></figure>
<h3 id="CentOS-RHEL-的注意事项"><a href="#CentOS-RHEL-的注意事项" class="headerlink" title="CentOS/RHEL 的注意事项"></a>CentOS/RHEL 的注意事项</h3><p>在 Ubuntu/Debian 上有 UnionFS 可以使用，如 <code>aufs</code> 或者 <code>overlay2</code> ，而 CentOS 和 RHEL 的内核中没有相关驱动。因此对于这类系统，一般使用 <code>devicemapper</code> 驱动利用 LVM 的一些机制来模拟分层存储。这样的做法除了性能比较差外，稳定性一般也不好，而且配置相对复杂。Docker 安装在 CentOS/RHEL 上后，会默认选择 <code>devicemapper</code> ，但是为了简化配置，其 <code>devicemapper</code> 是跑在一个稀疏文件模拟的块设备上，也被称为 <code>loop-lvm</code> 。这样的选择是因为不需要额外配置就可以运行 Docker，这是自动配置唯一能做到的事情。但是 <code>loop-lvm</code> 的做法非常不好，其稳定性、性能更差，无论是日志还是 <code>docker info</code> 中都会看到警告信息。官方文档有明确的文章讲解了如何配置块设备给 <code>devicemapper</code> 驱动做存储层的做法，这类做法也被称为配置 <code>direct-lvm</code> 。</p>
<p>除了前面说到的问题外， <code>devicemapper</code> + <code>loop-lvm</code> 还有一个缺陷，因为它是稀疏文件，所以它会不断增长。用户在使用过程中会注意到 <code>/var/lib/docker/devicemapper/devicemapper/data</code> 不断增长，而且无法控制。很多人会希望删<br>除镜像或者可以解决这个问题，结果发现效果并不明显。原因就是这个稀疏文件的空间释放后基本不进行垃圾回收的问题。因此往往会出现即使删除了文件内容，空间却无法回收，只能随着使用这个稀疏文件一直在不断增长。所以对于 CentOS/RHEL 的用户来说，在没有办法使用 UnionFS 的情况下，一定要配置 <code>direct-lvm</code> 给 <code>devicemapper</code> ，无论是为了性能、稳定性还是空间利用率。或许有人注意到了 CentOS 7 中存在被 backports 回来的 <code>overlay</code> 驱动，不过 CentOS 里的这个驱动达不到生产环境使用的稳定程度，所以不推荐使用。</p>
<h1 id="操作容器"><a href="#操作容器" class="headerlink" title="操作容器"></a>操作容器</h1><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（ stopped ）的容器重新启动。</p>
<h3 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h3><p>所需要的命令主要为 <code>docker run</code> 。例如运行一个容器，执行 <code>echo</code> 命令输出一个 “Hello World”，之后终止容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker run centos:latest /bin/echo "Hello World"</span></span><br><span class="line">Hello World</span><br><span class="line">[root@bogon ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>如果要为容器分配一个伪终端，并进入用户交互式的 bash 终端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker run --tty --interactive  centos /bin/bash         </span></span><br><span class="line">[root@876dabff426e /]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>其中， <code>--tty</code> 选项让 Docker 分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>--interactive</code> 则让容器的标准输入保持打开。</p>
<p>在交互模式下，用户可以通过所创建的终端来输入命令，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@876dabff426e /]<span class="comment"># uname -r</span></span><br><span class="line">3.10.0-1062.el7.x86_64</span><br><span class="line">[root@876dabff426e /]<span class="comment"># cat /etc/centos-release</span></span><br><span class="line">CentOS Linux release 8.0.1905 (Core) </span><br><span class="line">[root@876dabff426e /]<span class="comment"># pwd</span></span><br><span class="line">/</span><br><span class="line">[root@876dabff426e /]<span class="comment"># ls</span></span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>
<p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li><p>检查本地是否存在指定的镜像，不存在就从公有仓库下载。</p>
</li>
<li><p>利用镜像创建并启动一个容器。</p>
</li>
<li><p>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层。</p>
</li>
<li><p>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去。</p>
</li>
<li><p>从地址池配置一个 ip 地址给容器。</p>
</li>
<li><p>执行用户指定的应用程序。</p>
</li>
<li><p>执行完毕后容器被终止。</p>
</li>
</ul>
<h3 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h3><p>可以利用 <code>docker container start</code> 命令，指定容器名字或者容器 ID 来直接将一个已经终止的容器启动运行。</p>
<p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker run --tty --interactive centos /bin/bash</span></span><br><span class="line">[root@486ea60a9965 /]<span class="comment"># ps </span></span><br><span class="line">   PID TTY          TIME CMD</span><br><span class="line">     1 pts/0    00:00:00 bash</span><br><span class="line">    14 pts/0    00:00:00 ps</span><br><span class="line">[root@486ea60a9965 /]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>可见，容器中仅运行了指定的 bash 进程。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p>
<h2 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h2><p>多数情况下，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p>
<p>如果不使用 <code>-d</code> 参数运行容器，容器会把输出的结果 (STDOUT) 打印到宿主机上面：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker run centos /bin/bash -c 'for i in &#123;1..10&#125;; do echo $&#123;i&#125;: hello world; sleep 1; done' </span></span><br><span class="line">1: hello world</span><br><span class="line">2: hello world</span><br><span class="line">3: hello world</span><br><span class="line">4: hello world</span><br><span class="line">5: hello world</span><br><span class="line">6: hello world</span><br><span class="line">7: hello world</span><br><span class="line">8: hello world</span><br><span class="line">9: hello world</span><br><span class="line">10: hello world</span><br><span class="line">[root@bogon ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>如果使用了 -d 参数运行容器，此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker container logs</code> 查看)。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment">#  docker run -d centos /bin/bash -c 'for i in &#123;1..10&#125;; do echo $&#123;i&#125;: hello world; sleep 1; done'</span></span><br><span class="line">18bf6e162699c582f52e6b07c5aa1fbaa037db6dbab6ad852efd27a0d25cc22a</span><br><span class="line">[root@bogon ~]<span class="comment"># docker container ls</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">18bf6e162699        centos              <span class="string">"/bin/bash -c 'for i…"</span>   4 seconds ago       Up 3 seconds                            hardcore_edison</span><br><span class="line">[root@bogon ~]<span class="comment"># docker container logs 18bf6e162699</span></span><br><span class="line">1: hello world</span><br><span class="line">2: hello world</span><br><span class="line">3: hello world</span><br><span class="line">4: hello world</span><br><span class="line">5: hello world</span><br><span class="line">6: hello world</span><br><span class="line">7: hello world</span><br><span class="line">8: hello world</span><br><span class="line">9: hello world</span><br><span class="line">10: hello world</span><br><span class="line">[root@bogon ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>： 容器是否会长久运行，和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p>
<p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 或 <code>docker ps</code> 命令来查看容器信息。</p>
<h2 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h2><p>可以使用<code>docker container stop</code> 来终止一个运行中的容器。</p>
<p>此外，当 Docker 容器中指定的应用程序停止运行时，容器也自动终止。终止状态的容器可以用 <code>docker container ls -a</code> 命令看到。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker container ls</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">[root@bogon ~]<span class="comment"># docker container ls -a</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">18bf6e162699        centos              <span class="string">"/bin/bash -c 'for i…"</span>   6 minutes ago       Exited (0) 5 minutes ago                        hardcore_edison</span><br><span class="line">a048af484e83        centos              <span class="string">"/bin/bash -c 'for i…"</span>   8 minutes ago       Exited (0) 7 minutes ago                        goofy_liskov</span><br><span class="line">19a32d81172c        centos              <span class="string">"/bin/bash -c 'for i…"</span>   16 minutes ago      Exited (0) 16 minutes ago                       zen_dubinsky</span><br><span class="line">bfb5bce2a413        centos              <span class="string">"/bin/bash -c 'for i…"</span>   16 minutes ago      Exited (0) 16 minutes ago                       hungry_black</span><br><span class="line">3ebbcd2fdad0        centos              <span class="string">"/bin/bash -c 'for i…"</span>   17 minutes ago      Exited (0) 16 minutes ago                       affectionate_panini</span><br><span class="line">[root@bogon ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。如果使用 <code>docker container restart</code> 命令，则会将一个运行态的容器终止，然后再重新启动它。</p>
<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台运行，某些时候需要进入容器进行操作，这时候就要用到 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，建议使用 <code>docker exec</code> 命令，原因会在下面说明。</p>
<p><strong>attach 命令</strong></p>
<p><code>docker attach</code> 是 Docker 自带的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker run -d --interactive --tty ubuntu</span></span><br><span class="line">251418a512097c21296454a39caee45c882645774827437b9cfde0f23bb94688</span><br><span class="line"></span><br><span class="line">[root@bogon ~]<span class="comment"># docker container ls </span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">251418a51209        ubuntu              <span class="string">"/bin/bash"</span>         36 seconds ago      Up 35 seconds                           festive_agnesi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@bogon ~]<span class="comment"># docker attach 251418a51209</span></span><br><span class="line">root@251418a51209:/<span class="comment"># ls</span></span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@251418a51209:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@bogon ~]<span class="comment"># docker container ls</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">[root@bogon ~]<span class="comment"># docker container ls -a</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS                      PORTS               NAMES</span><br><span class="line">251418a51209        ubuntu              <span class="string">"/bin/bash"</span>              About a minute ago   Exited (0) 19 seconds ago                       festive_agnesi</span><br></pre></td></tr></table></figure>
<p>注意： 如果从这个 stdin 中 exit，会导致容器的停止。</p>
<p><strong>exec 命令</strong></p>
<p>使用 <code>docker exec</code> 命令，后边可以跟多个参数，这里主要说明 <code>--interactive</code> <code>--tty</code> 参数。</p>
<ul>
<li><p>在 <code>exec</code> 后只用 <code>--interactive</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执<br>行结果仍然可以返回。</p>
</li>
<li><p>当 <code>--interactive</code> <code>--tty</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker run -d --interactive --tty ubuntu</span></span><br><span class="line">0df9982d6e2049883dda10f2129e77d90fe9b2c48571202be7e2db5a7293c4ed</span><br><span class="line"></span><br><span class="line">[root@bogon ~]<span class="comment"># docker ps </span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">0df9982d6e20        ubuntu              <span class="string">"/bin/bash"</span>         18 seconds ago      Up 17 seconds                           hopeful_austin</span><br><span class="line"></span><br><span class="line">[root@bogon ~]<span class="comment"># docker exec --interactive 0df9982d6e20 /bin/bash</span></span><br><span class="line">ls</span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">.........</span><br><span class="line"></span><br><span class="line">[root@bogon ~]<span class="comment"># docker exec --interactive --tty 0df9982d6e20 /bin/bash</span></span><br><span class="line">root@0df9982d6e20:/<span class="comment"># ls</span></span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@0df9982d6e20:/<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么建议使用 <code>docker exec</code> 。</p>
<h2 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h2><p><strong>导出容器</strong></p>
<p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker ps -a    </span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                       PORTS               NAMES</span><br><span class="line">0df9982d6e20        ubuntu              <span class="string">"/bin/bash"</span>              5 minutes ago       Up 5 minutes                                     hopeful_austin</span><br><span class="line"></span><br><span class="line">[root@bogon ~]<span class="comment"># docker export 0df9982d6e20 &gt; ubuntu.tar</span></span><br></pre></td></tr></table></figure>
<p>这样将导出容器快照到本地文件。</p>
<p><strong>导入容器快照</strong></p>
<p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker import ubuntu.tar </span></span><br><span class="line">sha256:1c23f8ca16af29220e2b1a02fb24cae5b000e29cb360ee967ce7bc32bfa51b99</span><br><span class="line">[root@bogon ~]<span class="comment"># </span></span><br><span class="line"></span><br><span class="line">[root@bogon ~]<span class="comment"># docker import ubuntu.tar test/ubuntu:v1.0</span></span><br><span class="line">sha256:a3c9818fb4521028df427dd0737a6d6b0404e879bdd472945171b990501dd762</span><br><span class="line"></span><br><span class="line">[root@bogon ~]<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line"><span class="built_in">test</span>/ubuntu         v1.0                a3c9818fb452        6 seconds ago        64.2MB</span><br></pre></td></tr></table></figure>
<p>还可以通过指定 URL 或者某个目录来导入，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：用户既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker
import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p><strong>删除容器</strong></p>
<p>可以使用 <code>docker container rm</code> 来删除一个或多个处于终止状态的容器。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker ps -a --filter exited=0                       </span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">9e0a785c5a9f        centos              <span class="string">"/bin/bash"</span>              15 minutes ago      Exited (0) 15 minutes ago                       beautiful_tereshkova</span><br><span class="line">714d20ff760e        centos              <span class="string">"/bin/bash"</span>              16 minutes ago      Exited (0) 16 minutes ago                       great_bhabha</span><br><span class="line">251418a51209        ubuntu              <span class="string">"/bin/bash"</span>              23 minutes ago      Exited (0) 21 minutes ago                       festive_agnesi</span><br><span class="line">18bf6e162699        centos              <span class="string">"/bin/bash -c 'for i…"</span>   36 minutes ago      Exited (0) 35 minutes ago                       hardcore_edison</span><br><span class="line">a048af484e83        centos              <span class="string">"/bin/bash -c 'for i…"</span>   38 minutes ago      Exited (0) 37 minutes ago                       goofy_liskov</span><br><span class="line">19a32d81172c        centos              <span class="string">"/bin/bash -c 'for i…"</span>   46 minutes ago      Exited (0) 46 minutes ago                       zen_dubinsky</span><br><span class="line">bfb5bce2a413        centos              <span class="string">"/bin/bash -c 'for i…"</span>   46 minutes ago      Exited (0) 46 minutes ago                       hungry_black</span><br><span class="line">3ebbcd2fdad0        centos              <span class="string">"/bin/bash -c 'for i…"</span>   47 minutes ago      Exited (0) 46 minutes ago                       affectionate_panini</span><br><span class="line"></span><br><span class="line">[root@bogon ~]<span class="comment"># docker container rm $(docker ps -aq --filter exited=0)</span></span><br><span class="line">9e0a785c5a9f</span><br><span class="line">714d20ff760e</span><br><span class="line">251418a51209</span><br><span class="line">18bf6e162699</span><br><span class="line">a048af484e83</span><br><span class="line">19a32d81172c</span><br><span class="line">bfb5bce2a413</span><br><span class="line">3ebbcd2fdad0</span><br><span class="line"></span><br><span class="line">[root@bogon ~]<span class="comment"># docker ps -a --filter exited=0                        </span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">[root@bogon ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker ps </span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">0df9982d6e20        ubuntu              <span class="string">"/bin/bash"</span>         15 minutes ago      Up 15 minutes                           hopeful_austin</span><br><span class="line"></span><br><span class="line">[root@bogon ~]<span class="comment"># docker rm -f 0df9982d6e20</span></span><br><span class="line">0df9982d6e20</span><br><span class="line">[root@bogon ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>清理所有处于终止状态的容器用 <code>docker ps -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure>
<h1 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h1><h2 id="利用-commit-理解镜像构成"><a href="#利用-commit-理解镜像构成" class="headerlink" title="利用 commit 理解镜像构成"></a>利用 commit 理解镜像构成</h2><p>注意： <code>docker commit</code> 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 <code>docker commit</code> 定制镜像，定制镜像应该使用 <code>Dockerfile</code> 来完成。</p>
<p>镜像是容器的基础，每次执行 <code>docker run</code> 的时候都会指定哪个镜像作为容器运行的基础。镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。以定制一个 Web 服务器为例，来认识镜像是如何构建的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name WebServer01 -d -p 80:80 nginx</span><br></pre></td></tr></table></figure>
<p>这条命令会用 <code>nginx</code> 镜像启动一个容器，命名为 <code>WebServer01</code> ，并且把宿主机的 80 端口映射到了容器的 80 端口，这样用浏览器访问宿主机就会被映射到容器了。</p>
<p><img src="/2019/12/02/152139-Docker入坑指南/05_docker_image_01.png" alt=""></p>
<p>直接用浏览器访问的会看到默认的 Nginx 欢迎页面。现在，假设想要修改这个欢迎页面，改成欢迎 Docker 的文字，可以使用 <code>docker exec</code> 命令进入容器，修改其内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker exec --interactive --tty WebServer01 /bin/bash</span></span><br><span class="line">root@93cbd0a33ac5:/<span class="comment">#  echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html </span></span><br><span class="line">root@93cbd0a33ac5:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">[root@bogon ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>上面的命令时以交互式终端方式进入 <code>WebServer01</code> 容器，并执行了 <code>/bin/bash</code> 命令，也就是获得一个可操作的 Shell 。然后，我们用 <code>&lt;h1&gt;Hello, Docker!&lt;/h1&gt;</code> 覆盖了 <code>/usr/share/nginx/html/index.html</code> 的内容。再刷新浏览器会发现内容被改变了。</p>
<p><img src="/2019/12/02/152139-Docker入坑指南/05_docker_image_02.png" alt=""></p>
<p>修改了容器的文件，也就是改动了容器的存储层。可以通过 <code>docker diff</code> 命令看到具体的改动。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker diff WebServer01 </span></span><br><span class="line">C /root</span><br><span class="line">A /root/.bash_history</span><br><span class="line">C /usr</span><br><span class="line">C /usr/share</span><br><span class="line">C /usr/share/nginx</span><br><span class="line">C /usr/share/nginx/html</span><br><span class="line">C /usr/share/nginx/html/index.html</span><br><span class="line">C /run</span><br><span class="line">A /run/nginx.pid</span><br><span class="line">C /var</span><br><span class="line">C /var/cache</span><br><span class="line">C /var/cache/nginx</span><br><span class="line">A /var/cache/nginx/fastcgi_temp</span><br><span class="line">A /var/cache/nginx/proxy_temp</span><br><span class="line">A /var/cache/nginx/scgi_temp</span><br><span class="line">A /var/cache/nginx/uwsgi_temp</span><br><span class="line">A /var/cache/nginx/client_temp</span><br></pre></td></tr></table></figure>
<p>现在定制好了变化，我们希望能将其保存下来形成镜像。当运行一个容器的时候（如果不使用卷的话），在容器中做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p>
<p><code>docker commit</code> 的语法格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br></pre></td></tr></table></figure>
<p>可以用下面的命令将容器保存为镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker commit --author "Silence" --message "修改了默认欢迎页" WebServer01 nginx:v1.1</span></span><br><span class="line">sha256:0827c34a921a886018f25687f12587564985805afe4a7d6b38839cfb330b23b7</span><br></pre></td></tr></table></figure>
<p>其中 <code>--author</code> 是指定修改的作者，而 <code>--message</code> 则是记录本次修改的内容。这和 <code>git</code> 版本控制相似，不过这里这些信息可以省略不写。使用 <code>docker image ls</code> 可以看到这个新定制的镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker image ls nginx</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               v1.1                0827c34a921a        17 seconds ago      126MB</span><br><span class="line">nginx               latest              231d40e811cd        2 weeks ago         126MB</span><br><span class="line">[root@bogon ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>还可以用 <code>docker image history</code> 具体查看镜像内的历史记录，如果比较 <code>nginx:latest</code> 的历史记录，可以发现新增了刚刚提交的这一层。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># docker image history nginx:v1.1 </span></span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">0827c34a921a        4 minutes ago       nginx -g daemon off;                            99B                 修改了默认欢迎页</span><br><span class="line">231d40e811cd        2 weeks ago         /bin/sh -c <span class="comment">#(nop)  CMD ["nginx" "-g" "daemon…   0B                  </span></span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c <span class="comment">#(nop)  STOPSIGNAL SIGTERM           0B                  </span></span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c <span class="comment">#(nop)  EXPOSE 80                    0B                  </span></span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c ln -sf /dev/stdout /var/<span class="built_in">log</span>/nginx…   22B                 </span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c <span class="built_in">set</span> -x     &amp;&amp; addgroup --system -…   57.1MB              </span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c <span class="comment">#(nop)  ENV PKG_RELEASE=1~buster     0B                  </span></span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c <span class="comment">#(nop)  ENV NJS_VERSION=0.3.7        0B                  </span></span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c <span class="comment">#(nop)  ENV NGINX_VERSION=1.17.6     0B                  </span></span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c <span class="comment">#(nop)  LABEL maintainer=NGINX Do…   0B                  </span></span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c <span class="comment">#(nop)  CMD ["bash"]                 0B                  </span></span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c <span class="comment">#(nop) ADD file:bc8179c87c8dbb3d9…   69.2MB              </span></span><br><span class="line"></span><br><span class="line">[root@bogon ~]<span class="comment"># docker image history nginx:latest </span></span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">231d40e811cd        2 weeks ago         /bin/sh -c <span class="comment">#(nop)  CMD ["nginx" "-g" "daemon…   0B                  </span></span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c <span class="comment">#(nop)  STOPSIGNAL SIGTERM           0B                  </span></span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c <span class="comment">#(nop)  EXPOSE 80                    0B                  </span></span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c ln -sf /dev/stdout /var/<span class="built_in">log</span>/nginx…   22B                 </span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c <span class="built_in">set</span> -x     &amp;&amp; addgroup --system -…   57.1MB              </span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c <span class="comment">#(nop)  ENV PKG_RELEASE=1~buster     0B                  </span></span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c <span class="comment">#(nop)  ENV NJS_VERSION=0.3.7        0B                  </span></span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c <span class="comment">#(nop)  ENV NGINX_VERSION=1.17.6     0B                  </span></span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c <span class="comment">#(nop)  LABEL maintainer=NGINX Do…   0B                  </span></span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c <span class="comment">#(nop)  CMD ["bash"]                 0B                  </span></span><br><span class="line">&lt;missing&gt;           2 weeks ago         /bin/sh -c <span class="comment">#(nop) ADD file:bc8179c87c8dbb3d9…   69.2MB              </span></span><br><span class="line">[root@bogon ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>新的镜像定制好后，就可以来运行这个镜像了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name WebServer02 -d -p 81:80 nginx:v1.1</span><br></pre></td></tr></table></figure>
<p>这里容器命名为新的服务为 <code>WebServer02</code> ，并且映射宿主机 81 端口到容器的 80 端口。在浏览器直接访问看到的结果，其内容应该和之前修改后的 <code>WebServer01</code> 一样。</p>
<p><img src="/2019/12/02/152139-Docker入坑指南/05_docker_image_03.png" alt=""></p>
<h2 id="慎用-docker-commit"><a href="#慎用-docker-commit" class="headerlink" title="慎用 docker commit"></a>慎用 docker commit</h2><p>使用 <code>docker commit</code> 命令虽然可以比较直观地帮助理解镜像分层存储的概念，但是生产环境中并不会这样使用。</p>
<p>首先，如果仔细观察之前的 <code>docker diff WebServer01</code> 的结果，会发现除了真正想要修改的 <code>/usr/share/nginx/html/index.html</code> 文件外，由于命令的执行，还有很多文件被改动或添加了。这仅仅是最简单的操作，如果是安装软件包、编译构建，就会有大量的无关内容被添加进来，如果不小心清理，将会导致镜像非常臃肿。</p>
<p>此外，使用 <code>docker commit</code> 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为黑箱镜像，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体在操作的。虽然 <code>docker diff</code> 或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦的。</p>
<p>而且，按照镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 <code>docker commit</code> 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。</p>
<h2 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h2><p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p>
<p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。还以定制 Nginx 镜像为例，现在使用 Dockerfile 来定制。</p>
<p>在一个空白目录中，建立一个文本文件，并命名为 <code>Nginx-Dockerfile</code> ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># mkdir -pv mynginx</span></span><br><span class="line">mkdir: created directory ‘mynginx’</span><br><span class="line">[root@bogon ~]<span class="comment"># cd mynginx</span></span><br><span class="line">[root@bogon mynginx]<span class="comment"># &gt; Nginx-Dockerfile</span></span><br></pre></td></tr></table></figure>
<p>其内容为：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="comment"># 指定基础镜像，即当前新镜像是基于哪个镜像的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span> Silence</span><br><span class="line"><span class="comment"># 指定作者(维护者)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span></span><br><span class="line"><span class="bash"><span class="comment"># 指定构建过程中要运行的命令</span></span></span><br></pre></td></tr></table></figure>
<p><strong>FROM 指定基础镜像</strong></p>
<p>定制镜像，是以一个镜像为基础，在其之上进行定制。就像之前运行了一个 <code>nginx</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定基础镜像，因此一个 Dockerfile 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p>
<p>在 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <a href="https://hub.docker.com/_/nginx" target="_blank" rel="noopener">nginx</a> 、 <a href="https://hub.docker.com/_/redis" target="_blank" rel="noopener">redis</a> 、 <a href="https://hub.docker.com/_/mongo" target="_blank" rel="noopener">mongo</a> 、 <a href="https://hub.docker.com/_/mysql" target="_blank" rel="noopener">mysql</a> 、 <a href="https://hub.docker.com/_/httpd" target="_blank" rel="noopener">httpd</a> 、 <a href="https://hub.docker.com/_/php" target="_blank" rel="noopener">php</a> 、 <a href="https://hub.docker.com/_/tomcat" target="_blank" rel="noopener">tomcat</a> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 <a href="https://hub.docker.com/_/node" target="_blank" rel="noopener">node</a> 、 <a href="https://hub.docker.com/_/openjdk" target="_blank" rel="noopener">openjdk</a> 、 <a href="https://hub.docker.com/_/python" target="_blank" rel="noopener">python</a> 、 <a href="https://hub.docker.com/_/ruby" target="_blank" rel="noopener">ruby</a> 、 <a href="https://hub.docker.com/_/golang" target="_blank" rel="noopener">golang</a> 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 <a href="https://hub.docker.com/_/ubuntu" target="_blank" rel="noopener">ubuntu</a> 、 <a href="https://hub.docker.com/_/debian" target="_blank" rel="noopener">debian</a> 、 <a href="https://hub.docker.com/_/centos" target="_blank" rel="noopener">centos</a> 、 <a href="https://hub.docker.com/_/fedora" target="_blank" rel="noopener">fedora</a> 、 <a href="https://hub.docker.com/_/alpine" target="_blank" rel="noopener">alpine</a> 等，这些操作系统的软件库为提供了更广阔的扩展空间。</p>
<p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code> 。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br></pre></td></tr></table></figure>
<p>如果以 <code>scratch</code> 为基础镜像，意味着不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p>
<p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 swarm 、 coreos/etcd 。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧。使用 Go 语言 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p>
<p><strong>RUN 执行命令</strong></p>
<p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力， <code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p>
<ul>
<li><p>shell 格式： <code>RUN &lt;命令&gt;</code> ，就像直接在命令行中输入的命令一样。例如  <code>RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html</code></p>
</li>
<li><p>exec 格式： <code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code> ，这更像是函数调用中的格式。</p>
</li>
</ul>
<p><code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么也就可以像 Shell 脚本一样把每个命令对应一个 <code>RUN</code> 。比如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:jessie</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></span><br><span class="line"><span class="bash">RUN apt-get install -y gcc libc6-dev make</span></span><br><span class="line"><span class="bash">RUN wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-3.2.5.tar.gz"</span></span></span><br><span class="line"><span class="bash">RUN mkdir -p /usr/src/redis</span></span><br><span class="line"><span class="bash">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span></span><br><span class="line"><span class="bash">RUN make -C /usr/src/redis</span></span><br><span class="line"><span class="bash">RUN make -C /usr/src/redis install</span></span><br></pre></td></tr></table></figure>
<p>Dockerfile 中每一个指令都会建立一层， <code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，都会新建立一层，在此之上执行这些命令，执行结束后， <code>commit</code> 这一层的修改，构成新的镜像。</p>
<p>上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 </p>
<p>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</p>
<p>上面的 <code>Dockerfile</code> 正确的写法应该是这样：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:jessie</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> buildDeps=<span class="string">'gcc libc6-dev make'</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-3.2.5.tar.gz"</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; mkdir -p /usr/src/redis \</span></span><br><span class="line"><span class="bash">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span></span><br><span class="line"><span class="bash">    &amp;&amp; make -C /usr/src/redis \</span></span><br><span class="line"><span class="bash">    &amp;&amp; make -C /usr/src/redis install \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm redis.tar.gz \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -r /usr/src/redis \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span></span><br></pre></td></tr></table></figure>
<p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 对一一对应不同的命令，而是仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。将之前的 7 层，简化为了1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p>
<p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p>
<p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，因为镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>
<p><strong>构建镜像</strong></p>
<p>回到之前定制的 nginx 镜像的 Dockerfile 来构建这个镜像。在 Dockerfile 文件所在目录执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build --file ./Nginx-Dockerfile  --tag <span class="string">'nginx:v3'</span> .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/3 : FROM nginx</span><br><span class="line"> ---&gt; f7bb5701a33c</span><br><span class="line">Step 2/3 : MAINTAINER Silence</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 5c2f0d4390e4</span><br><span class="line">Step 3/3 : RUN <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 59e17fb13c2b</span><br><span class="line">Removing intermediate container 59e17fb13c2b</span><br><span class="line"> ---&gt; 96de03b40a2f</span><br><span class="line">Successfully built 96de03b40a2f</span><br><span class="line">Successfully tagged nginx:v3</span><br></pre></td></tr></table></figure>
<p>在 <code>Step 3</code> 中，如同之前所说， <code>RUN</code> 指令启动了一个容器 <code>59e17fb13c2b</code> ，执行了所要求的命令，并最后提交了这一层 <code>96de03b40a2f</code> ，随后删除了所用到的这个容器 <code>59e17fb13c2b</code> 。</p>
<p>这里使用了 <code>docker image build</code> 命令进行镜像构建。其格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build [选项] &lt;上下文路径/URL/-&gt;</span><br></pre></td></tr></table></figure>
<p>在这里指定了最终镜像的名称 <code>--tag nginx:v3</code> ，构建成功后就可以运行这个镜像了。</p>
<p><strong>镜像构建上下文（Context）</strong></p>
<p>如果注意，会看到 <code>docker image build</code> 命令最后有一个 <code>.</code> ，这个 <code>.</code> 和 <code>./</code> 相同，表示的是当前目录。这其实是在指定上下文路径。那么什么是上下文呢？</p>
<p>首先要理解 <code>docker image build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">Docker Remote API</a>，而 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让操作远程服务器的 Docker 引擎变得轻而易举。</p>
<p>当进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、 <code>ADD</code> 指令等。而 <code>docker image build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种 客户端/服务端 的架构中，如何才能让服务端获得本地文件呢？</p>
<p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径， <code>docker image build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<p>如果在 Dockerfile 中这么写：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> ./package.json /app/</span></span><br></pre></td></tr></table></figure>
<p>这并不是要复制执行 <code>docker image build</code> 命令所在的目录下的 <code>package.json</code> ，也不是复制 Dockerfile 所在目录下的 <code>package.json</code> ，而是复制指定的上下文（<strong>context</strong>） 目录下的 <code>package.json</code> 。</p>
<p>因此， <code>COPY</code> 这类指令中的源文件的路径不管看上去是相对路径还是绝对路径，其实都是 <strong>相对路径</strong>，是相对于上下文路径来说的。很多时候，<code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作，都是因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p>
<p>如果观察 <code>docker  image build</code> 输出，其实可以看到这个发送上下文的过程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build --file ./Nginx-Dockerfile  --tag <span class="string">'nginx:v3'</span> ./</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br></pre></td></tr></table></figure>
<p>如此一来，<code>docker image build</code> 就会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p>
<p>理解构建上下文对于镜像构建是很重要的， 可以避免犯一些不应该的错误。 比如有些人在发现 <code>COPY /opt/xxxx /app</code> 不工作后， 于是干脆将 Dockerfile 放到了硬盘根目录去构建， 结果发现 <code>docker image build</code> 执行后， 在发送一个几十 GB 的东西， 极为缓慢而且很容易构建失败。 那是因为这种做法是在让 <code>docker image build</code> 打包整个硬盘， 这显然是错误的用法。</p>
<p>一般情况下，应该将 <code>Dockerfile</code> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code> ，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p>
<p>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p>
<p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code> ，而且并不要求必须位于上下文目录中，比如可以用 <code>--file ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code> 。</p>
<p><strong>其它 docker image build 的用法</strong></p>
<ul>
<li>从 URL 构建，比如可以直接从 Git repo 中构建：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build https://github.com/twang2218/gitlab-ce-zh.git\<span class="comment">#:8.14</span></span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM gitlab/gitlab-ce:8.14.0-ce.0</span><br><span class="line">8.14.0-ce.0: Pulling from gitlab/gitlab-ce</span><br><span class="line">aed15891ba52: Already exists</span><br><span class="line">773ae8583d14: Already exists</span><br></pre></td></tr></table></figure>
<p>这行命令指定了构建所需的 Git repo，并且指定默认的 <code>master</code> 分支，构建目录为 <code>/8.14/</code> ，然后 Docker 就会自己去 <code>git clone</code> 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p>
<ul>
<li>用给定的 <strong>tar</strong> 压缩包构建：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build http://server/context.tar.gz</span><br></pre></td></tr></table></figure>
<p>如果所给出的 URL 不是个 Git repo，而是个 <code>tar</code> 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，并把它作为上下文，开始构建。</p>
<ul>
<li>从标准输入中读取 Dockerfile 进行构建：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build - &lt; Dockerfile</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">cat Dockerfile | docker build -</span><br></pre></td></tr></table></figure>
<p>如果标准输入传入的是文本文件，则将其视为 <code>Dockerfile</code> ，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 <code>COPY</code> 进镜像。</p>
<ul>
<li>从标准输入中读取上下文压缩包进行构建：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build - &lt; context.tar.gz</span><br></pre></td></tr></table></figure>
<p>如果发现标准输入的文件格式是 <code>gzip</code> 、 <code>bzip2</code> 以及 <code>xz</code> 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p>
<h2 id="Dockerfile-指令详解"><a href="#Dockerfile-指令详解" class="headerlink" title="Dockerfile 指令详解"></a>Dockerfile 指令详解</h2><h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h3><p>格式：</p>
<ul>
<li><code>COPY &lt;源路径&gt;... &lt;目标路径&gt;</code></li>
<li><code>COPY [&quot;&lt;源路径1&gt;&quot;, &quot;&lt;源路径2&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li>
</ul>
<p>和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。<code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json /usr/src/app/</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <a href="https://golang.org/pkg/path/filepath/#Match" target="_blank" rel="noopener">filepath.Match</a> 规则，如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> hom* /mydir/</span></span><br><span class="line"><span class="bash">COPY hom?.txt /mydir/</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p>
<h3 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h3><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</p>
<p>比如 <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code> ，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。下载后的文件权限自动设置为 <code>600</code> ，如果这并不是想要的权限，那么还需要增加额外的一层 <code>RUN</code> 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 <code>RUN</code> 指令进行解压缩。所以不如直接使用 <code>RUN</code> 指令，然后使用 <code>wget</code> 或者 <code>curl</code> 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p>
<p>如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code> , <code>bzip2</code> 以及 <code>xz</code> 的情况下， <code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</span></span><br></pre></td></tr></table></figure>
<p>但在某些情况下，如果只是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 <code>ADD</code> 命令了。</p>
<p>在 Docker 官方的 <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank" rel="noopener">Dockerfile 最佳实践文档</a> 中要求，尽可能的使用 <code>COPY</code> ，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</p>
<p>另外需要注意的是， <code>ADD</code> 指令会让镜像构建缓存失效，从而可能会使镜像构建变得比较缓慢。</p>
<p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code> 。</p>
<h3 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h3><p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p>
<ul>
<li><code>shell</code> 格式： <code>CMD &lt;命令&gt;</code></li>
<li><code>exec</code> 格式： <code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li>
<li>参数列表格式： <code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code> 。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li>
</ul>
<p>容器不是虚拟机，说到底就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。</p>
<p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如， <code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code> ，如果直接 <code>docker run --interactive --tty ubuntu</code> 的话，会直接进入 <code>bash</code> 。也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code> 。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p>
<p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>&quot;</code> ，而不要使用单引号。</p>
<p>如果使用 shell 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$HOME</span></span></span><br></pre></td></tr></table></figure>
<p>在实际执行中，会将其变更为：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo <span class="variable">$HOME</span>"</span> ]</span></span><br></pre></td></tr></table></figure>
<p>这就是可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p>
<p>提到 CMD 就不得不提容器中应用在前台执行和后台执行的问题。Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。</p>
<p>如果将 CMD 写为：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> service nginx start</span></span><br></pre></td></tr></table></figure>
<p>然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p>
<p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<p>而使用 <code>service nginx start</code> 命令，则是希望 upstart 来以后台守护进程形式启动 <code>nginx</code> 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginxstart&quot;]</code> ，因此主进程实际上是 <code>sh</code> 。那么当 <code>service nginx start</code> 命令结束后， <code>sh</code> 也就结束了， <code>sh</code> 作为主进程退出了，自然就会令容器退出。</p>
<p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"nginx"</span>, <span class="string">"-g"</span>, <span class="string">"daemon off;"</span>]</span></span><br></pre></td></tr></table></figure>
<h3 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h3><p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。<code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。 <code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。</p>
<p>当指定了 <code>ENTRYPOINT</code> 后， <code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">ENTRYPOINT</span><span class="bash">&gt; <span class="string">"&lt;CMD&gt;"</span></span></span><br></pre></td></tr></table></figure>
<p>那么有了 <code>CMD</code> 后，为什么还要有 <code>ENTRYPOINT</code> 呢？这种 <code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code> 有什么好处么？来看几个场景。</p>
<p><strong>场景一：让镜像变成像命令一样使用</strong></p>
<p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 <code>CMD</code> 来实现：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install -y curl \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="bash">	</span></span><br><span class="line"><span class="bash">CMD [ <span class="string">"curl"</span>, <span class="string">"-s"</span>, <span class="string">"https://ip.cn"</span> ]</span></span><br></pre></td></tr></table></figure>
<p>假如使用 <code>docker image build --file ./Dockerfile.myip --tag myip .</code> 来构建镜像的话，如果需要查询当前公网 IP，只需要执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip</span><br><span class="line">&#123;<span class="string">"ip"</span>: <span class="string">"1.202.112.148"</span>, <span class="string">"country"</span>: <span class="string">"北京市"</span>, <span class="string">"city"</span>: <span class="string">"电信"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>看起来好像可以直接把镜像当做命令使用了，不过命令总会有参数，如果现在希望加参数呢？比如从上面的 <code>CMD</code> 中可以看到实质的命令是 <code>curl</code> ，那么如果现在希望显示 HTTP 头信息，就需要加上 <code>-i</code> 参数。那么可以直接加 <code>-i</code> 参数给 <code>docker run myip</code> 么？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip -i</span><br><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:346: starting container process caused <span class="string">"exec: \"-i\": executable file not found in <span class="variable">$PATH</span>"</span>: unknown.</span><br><span class="line">ERRO[0000] error waiting <span class="keyword">for</span> container: context canceled</span><br></pre></td></tr></table></figure>
<p>可以看到可执行文件找不到的报错， <code>executable file not found</code> 。之前说过，跟在镜像名后面的是 <code>command</code> ，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了原来的 <code>CMD</code> ，而不是添加在原来的 <code>curl -s https://ip.cn</code> 后面。而 <code>-i</code> 根本不是命令，所以自然找不到。</p>
<p>如果希望加入 <code>-i</code> 这参数，就必须重新完整的输入这个命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip curl -s https://ip.cn -i</span><br></pre></td></tr></table></figure>
<p>这样就非常不人性化，而使用 <code>ENTRYPOINT</code> 就可以解决这个问题。现在重新用 <code>ENTRYPOINT</code> 来实现这个镜像：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install -y curl \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get purge -y --auto-remove </span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">ENTRYPOINT [ <span class="string">"curl"</span>, <span class="string">"-s"</span>, <span class="string">"https://ip.cn"</span> ]</span></span><br></pre></td></tr></table></figure>
<p>删除之前的残留，重新构建镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker container rm $(docker container ps -a | awk <span class="string">'/myip/&#123;print $1&#125;'</span>)</span><br><span class="line">2244e4afa733</span><br><span class="line">3795eaaaaa15</span><br><span class="line">96dbcb291be5</span><br><span class="line">ef39e73b52b5</span><br><span class="line"></span><br><span class="line">$ docker image rm myip</span><br><span class="line">Untagged: myip:latest</span><br><span class="line">Deleted: sha256:f27178606c7dcd69f942d85049ad05298f97cfa5831909079faf845fe934906c</span><br><span class="line">Deleted: sha256:baebe74eefc04cf55256aa4d6400a0b1f2ce2f7ac1d3a707c924505fe1ddc8f8</span><br><span class="line">Deleted: sha256:b4fba85e9cb69380a6ef088b8224332989989ac306e069cdefa562b741942a10</span><br><span class="line"></span><br><span class="line">$ docker image build --file ./Dockerfile.myip --tag <span class="string">'myip'</span> .</span><br></pre></td></tr></table></figure>
<p>再次尝试直接使用 <code>-i</code> 选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip</span><br><span class="line">&#123;<span class="string">"ip"</span>: <span class="string">"1.202.112.148"</span>, <span class="string">"country"</span>: <span class="string">"北京市"</span>, <span class="string">"city"</span>: <span class="string">"电信"</span>&#125;</span><br><span class="line"></span><br><span class="line">$ docker run myip -i</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Fri, 03 Jan 2020 05:19:52 GMT</span><br><span class="line">Content-Type: application/json; charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Set-Cookie: __cfduid=d8a583dfdf42b5b551f86b83368b6264d1578028792; expires=Sun, 02-Feb-20 05:19:52 GMT; path=/; domain=.ip.cn; HttpOnly; SameSite=Lax</span><br><span class="line">CF-Cache-Status: DYNAMIC</span><br><span class="line">Expect-CT: max-age=604800, report-uri=<span class="string">"https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct"</span></span><br><span class="line">Server: cloudflare</span><br><span class="line">CF-RAY: 54f2852f6ddae7fd-LAX</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">"ip"</span>: <span class="string">"1.202.112.148"</span>, <span class="string">"country"</span>: <span class="string">"北京市"</span>, <span class="string">"city"</span>: <span class="string">"电信"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这次成功了。这是因为当存在 <code>ENTRYPOINT</code> 后， <code>CMD</code> 的内容将会作为参数传给 <code>ENTRYPOINT</code> ，而这里 <code>-i</code> 就是新的 <code>CMD</code> ，因此会作为参数传给 <code>curl</code> ，从而达到了预期的效果。</p>
<p><strong>场景二：应用运行前的准备工作</strong></p>
<p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 <code>mysql</code> 服务器运行之前解决。</p>
<p>此外，可能希望避免使用 <code>root</code> 用户去启动服务，从而提高安全性，而在启动服务前还需要以 <code>root</code> 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 <code>root</code> 身份执行，方便调试等。</p>
<p>这些准备工作是和容器 <code>CMD</code> 无关的，无论 <code>CMD</code> 是什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 <code>ENTRYPOINT</code> 中去执行，而这个脚本会将接到的参数（也就是 <code>&lt;CMD&gt;</code> ）作为命令，在脚本最后执行。比如官方镜像 <code>redis</code> 中就是这么做的：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine:<span class="number">3.4</span></span><br><span class="line"><span class="comment"># .........</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> addgroup -S redis &amp;&amp; adduser -S -G redis redis</span></span><br><span class="line"><span class="bash"><span class="comment"># .........</span></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY docker-entrypoint.sh /usr/<span class="built_in">local</span>/bin/</span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"docker-entrypoint.sh"</span>]</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">EXPOSE 6379</span></span><br><span class="line"><span class="bash">CMD [ <span class="string">"redis-server"</span> ]</span></span><br></pre></td></tr></table></figure>
<p>可以看到其中为 redis 服务创建了 redis 用户，并在最后指定了 <code>ENTRYPOINT</code> 为 <code>docker-entrypoint.sh</code> 脚本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># first arg is `-f` or `--some-option`</span></span><br><span class="line"><span class="comment"># or first arg is `something.conf`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;1#-&#125;</span>"</span> != <span class="string">"<span class="variable">$1</span>"</span> ] || [ <span class="string">"<span class="variable">$&#123;1%.conf&#125;</span>"</span> != <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">set</span> -- redis-server <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># allow the container to be started with `--user`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">'redis-server'</span> -a <span class="string">"<span class="variable">$(id -u)</span>"</span> = <span class="string">'0'</span> ]; <span class="keyword">then</span></span><br><span class="line">	find . \! -user redis -<span class="built_in">exec</span> chown redis <span class="string">'&#123;&#125;'</span> +</span><br><span class="line">	<span class="built_in">exec</span> gosu redis <span class="string">"<span class="variable">$0</span>"</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure>
<p>该脚本的内容就是根据 <code>CMD</code> 的内容来判断，如果是 <code>redis-server</code> 的话，则切换到 <code>redis</code> 用户身份启动服务器，否则依旧使用 <code>root</code> 身份执行。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it redis id</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></table></figure>
<h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><p>格式有两种：</p>
<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li>
</ul>
<p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 <code>RUN</code> , 还是容器内运行时的应用程序，都可以直接使用这里定义的环境变量。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> VERSION=<span class="number">1.0</span> DEBUG=on \</span><br><span class="line">NAME=<span class="string">"Happy Feet"</span></span><br></pre></td></tr></table></figure>
<p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 <code>node</code> 镜像 <code>Dockerfile</code> 中，就有类似这样的代码：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> NODE_VERSION <span class="number">7.2</span>.<span class="number">0</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl -SLO <span class="string">"https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz"</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; curl -SLO <span class="string">"https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/SHASUMS256.txt.asc"</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \</span></span><br><span class="line"><span class="bash">    &amp;&amp; grep <span class="string">" node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz\$"</span> SHASUMS256.txt | sha256sum -c - \</span></span><br><span class="line"><span class="bash">    &amp;&amp; tar -xJf <span class="string">"node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz"</span> -C /usr/<span class="built_in">local</span> --strip-components=1 \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm <span class="string">"node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz"</span> SHASUMS256.txt.asc SHASUMS256.txt \</span></span><br><span class="line"><span class="bash">    &amp;&amp; ln -s /usr/<span class="built_in">local</span>/bin/node /usr/<span class="built_in">local</span>/bin/nodejs</span></span><br></pre></td></tr></table></figure>
<p>在这里先定义了环境变量 <code>NODE_VERSION</code> ，其后的 <code>RUN</code> 这层里，多次使用 <code>$NODE_VERSION</code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 <code>7.2.0</code> 即可， <code>Dockerfile</code> 构建维护变得更轻松了。</p>
<p>下列指令可以支持环境变量展开：</p>
<p><code>ADD</code> 、 <code>COPY</code> 、 <code>ENV</code> 、 <code>EXPOSE</code> 、 <code>LABEL</code> 、 <code>USER</code> 、 <code>WORKDIR</code> 、 <code>VOLUME</code> 、 <code>STOPSIGNAL</code> 、 <code>ONBUILD</code> 。</p>
<p>环境变量可以使用的地方很多，通过环境变量，可以让一份 <code>Dockerfile</code> 制作更多的镜像，只需使用不同的环境变量即可。</p>
<h3 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h3><p>格式： <code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p>
<p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是， <code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p>
<p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker image build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p>
<p>在 1.13 之前的版本，要求 <code>--build-arg</code> 中的参数名，必须在 <code>Dockerfile</code> 中用 <code>ARG</code> 定义过了，换句话说，就是 <code>--build-arg</code> 指定的参数，必须在 <code>Dockerfile</code> 中使用了。如果对应参数没有被使用，则会报错退出构建。从 1.13 开始，这种严格的限制被放开，不再报错退出，而是显示警告信息，并继续构建。这对于使用 CI 系统，用同样的构建流程构建不同的 <code>Dockerfile</code> 的时候比较有帮助，避免构建命令必须根据每个 <code>Dockerfile</code> 的内容修改。</p>
<h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>格式为：</p>
<ul>
<li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li>
<li><code>VOLUME &lt;路径&gt;</code></li>
</ul>
<p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /data</span></span><br></pre></td></tr></table></figure>
<p>这里的 <code>/data</code> 目录就会在运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v mydata:/data xxxx</span><br></pre></td></tr></table></figure>
<p>在这行命令中，就使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置。</p>
<h3 id="EXPOSE-声明暴露的端口"><a href="#EXPOSE-声明暴露的端口" class="headerlink" title="EXPOSE 声明暴露的端口"></a>EXPOSE 声明暴露的端口</h3><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></p>
<p><code>EXPOSE</code> 指令是声明运行时容器提供的服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 <code>Dockerfile</code> 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是<code>docker run -P</code>  时，会自动随机映射 <code>EXPOSE</code> 的端口。</p>
<p>此外，在早期 Docker 版本中还有一个特殊的用处。以前所有容器都运行于默认桥接网络中，因此所有容器互相之间都可以直接访问，这样存在一定的安全性问题。于是有了一个 Docker 引擎参数 <code>--icc=false</code> ，当指定该参数后，容器间将默认无法互访，除非互相间使用了 <code>--links</code> 参数的容器才可以互通，并且只有镜像中 <code>EXPOSE</code> 所声明的端口才可以被访问。这个<code>--icc=false</code> 的用法，在引入了 <code>docker network</code> 后已经基本不用了，通过自定义网络可以很轻松的实现容器间的互联与隔离。</p>
<p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code> ，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
<h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h3><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code> 。</p>
<p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在， <code>WORKDIR</code> 会自动建立目录。</p>
<p>不应该把 <code>Dockerfile</code> 看成是在写 Shell 脚本，因为可能会导致出现下面这样的错误：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /app</span></span><br><span class="line"><span class="bash">RUN <span class="built_in">echo</span> <span class="string">"hello"</span> &gt; world.txt</span></span><br></pre></td></tr></table></figure>
<p>如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code> 。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 <code>Dockerfile</code> 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 <code>Dockerfile</code> 构建分层存储的概念不了解所导致的错误。</p>
<p>每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p>
<h3 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h3><p>格式：<code>USER &lt;用户名&gt;</code></p>
<p><code>USER</code> 指令和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层。 <code>WORKDIR</code> 是改变工作目录， <code>USER</code> 则是改变之后层的执行 <code>RUN</code> , <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。当然，和 <code>WORKDIR</code> 一样， <code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> groupadd -r redis &amp;&amp; useradd -r -g redis redis</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">USER redis</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN [ <span class="string">"redis-server"</span> ]</span></span><br></pre></td></tr></table></figure>
<p>如果以 <code>root</code> 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不使用 <code>su</code> 或者 <code>sudo</code> ，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 <a href="https://github.com/tianon/gosu" target="_blank" rel="noopener">gosu</a> 。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> groupadd -r redis &amp;&amp; useradd -r -g redis redis</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 下载 gosu</span></span></span><br><span class="line"><span class="bash">RUN wget -O /usr/<span class="built_in">local</span>/bin/gosu <span class="string">"https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64"</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; chmod +x /usr/<span class="built_in">local</span>/bin/gosu \</span></span><br><span class="line"><span class="bash">    &amp;&amp; gosu nobody <span class="literal">true</span></span></span><br><span class="line"><span class="bash">    </span></span><br><span class="line"><span class="bash"><span class="comment"># 设置 CMD，并以另外的用户执行</span></span></span><br><span class="line"><span class="bash">CMD [ <span class="string">"exec"</span>, <span class="string">"gosu"</span>, <span class="string">"redis"</span>, <span class="string">"redis-server"</span> ]</span></span><br></pre></td></tr></table></figure>
<h3 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a>HEALTHCHECK 健康检查</h3><p>格式：</p>
<ul>
<li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code> ：设置检查容器健康状况的命令。</li>
<li><code>HEALTHCHECK NONE</code> ：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令。</li>
</ul>
<p><code>HEALTHCHECK</code> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。<br>在没有 <code>HEALTHCHECK</code> 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</p>
<p>而自 1.12 之后，Docker 提供了 <code>HEALTHCHECK</code> 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。</p>
<p>当在一个镜像指定了 <code>HEALTHCHECK</code> 指令后，用其启动容器，初始状态会为 <code>starting</code> ，在 <code>HEALTHCHECK</code> 指令检查成功后变为 <code>healthy</code> ，如果连续一定次数失败，则会变为 <code>unhealthy</code> 。</p>
<p><code>HEALTHCHECK</code> 支持下列选项：</p>
<ul>
<li><code>--interval=&lt;间隔&gt;</code> ：两次健康检查的间隔，默认为 30 秒；</li>
<li><code>--timeout=&lt;时长&gt;</code> ：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</li>
<li><code>--retries=&lt;次数&gt;</code> ：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code> ，默认 3次。</li>
</ul>
<p>和 <code>CMD</code> , <code>ENTRYPOINT</code> 一样， <code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。</p>
<p>在 <code>HEALTHCHECK [选项] CMD</code> 后面的命令，格式和 <code>ENTRYPOINT</code> 一样，分为 <code>shell</code> 格式，和 <code>exec</code> 格式。命令的返回值决定了该次健康检查的成功与否：<code>0</code> ：成功； <code>1</code> ：失败； <code>2</code> ：保留，不要使用这个值。</p>
<p>假设有个镜像是个最简单的 Web 服务，现在希望增加健康检查来判断其 Web 服务是否在正常工作，可以用 <code>curl</code> 来帮助判断，其 <code>Dockerfile</code> 的 <code>HEALTHCHECK</code> 可以这么写：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">HEALTHCHECK --interval=5s --timeout=3s \</span></span><br><span class="line"><span class="bash">    CMD curl -fs http://localhost/ || <span class="built_in">exit</span> 1</span></span><br></pre></td></tr></table></figure>
<p>这里为了试验，设置了每 5 秒检查一次，实际应该相对较长，如果健康检查命令超过 3 秒没响应就视为失败，并且使用 <code>curl -fs http://localhost/ || exit 1</code> 作为健康检查命令。</p>
<p>使用 <code>docker image build</code> 来构建这个镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build --file ./Dockerfile.mynginx --tag <span class="string">'mynginx:v1'</span> .</span><br></pre></td></tr></table></figure>
<p>构建好了后，启动一个容器，并查看状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -d   --name web01 -p 80:80  mynginx:v1 &amp;&amp; docker container ls</span><br></pre></td></tr></table></figure>
<p>当运行该镜像后，通过 <code>docker container ls</code> 看到最初的状态为 <code>(health: starting)</code> 。在等待几秒钟后，再次 <code>docker container ls</code> ，就会看到健康状态变化为了 <code>(healthy)</code>。如果健康检查连续失败超过了重试次数，状态就会变为 <code>(unhealthy)</code> 。</p>
<p>为了帮助排障，健康检查命令的输出（包括 <code>stdout</code> 以及 <code>stderr</code> ）都会被存储于健康状态里，可以用 <code>docker container inspect</code>  来查看。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container inspect --format <span class="string">'&#123;&#123;json .State.Health&#125;&#125;'</span> web01 | python -m json.tool</span><br></pre></td></tr></table></figure>
<h3 id="ONBUILD-为他人做嫁衣裳"><a href="#ONBUILD-为他人做嫁衣裳" class="headerlink" title="ONBUILD 为他人做嫁衣裳"></a>ONBUILD 为他人做嫁衣裳</h3><p>格式： <code>ONBUILD &lt;其它指令&gt;</code> 。</p>
<p><code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code> , <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p>
<p><code>Dockerfile</code> 中的其它指令都是为了定制当前镜像而准备的，唯有 <code>ONBUILD</code> 是为了帮助别人定制自己而准备的。</p>
<p>假设要制作 Node.js 所写的应用的镜像。而 Node.js 使用 <code>npm</code> 进行包管理，所有依赖、配置、启动信息等会放到 <code>package.json</code> 文件里。在拿到程序代码后，需要先进行 <code>npm install</code> 才可以获得所有需要的依赖。然后就可以通过 <code>npm start</code> 来启动应用。因此，一般情况下，应该这样写 <code>Dockerfile</code> ：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /app</span></span><br><span class="line"><span class="bash">WORKDIR /app</span></span><br><span class="line"><span class="bash">COPY ./package.json /app</span></span><br><span class="line"><span class="bash">RUN [ <span class="string">"npm"</span>, <span class="string">"install"</span> ]</span></span><br><span class="line"><span class="bash">COPY . /app/</span></span><br><span class="line"><span class="bash">CMD [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span></span><br></pre></td></tr></table></figure>
<p>把这个 <code>Dockerfile</code> 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 Dockerfile 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难。</p>
<p>如果第一个 Node.js 项目在开发过程中，发现这个 <code>Dockerfile</code> 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 Dockerfile ，再次构建，问题解决。第一个项目没问题了，但是第二个项目呢？虽然最初 <code>Dockerfile</code> 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 <code>Dockerfile</code> ，而第二个项目的 <code>Dockerfile</code> 就会被自动修复。</p>
<p>那么可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 <code>Dockerfile</code> 的变化，重新构建后就继承了基础镜像的更新。那么上面的这个 <code>Dockerfile</code> 就会变为：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /app</span></span><br><span class="line"><span class="bash">WORKDIR /app</span></span><br><span class="line"><span class="bash">CMD [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span></span><br></pre></td></tr></table></figure>
<p>这里把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 mynode ，各个项目内的自己的 <code>Dockerfile</code> 就变为：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> my-node</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./package.json /app</span></span><br><span class="line"><span class="bash">RUN [ <span class="string">"npm"</span>, <span class="string">"install"</span> ]</span></span><br><span class="line"><span class="bash">COPY . /app/</span></span><br></pre></td></tr></table></figure>
<p>基础镜像变化后，各个项目都用这个 <code>Dockerfile</code> 重新构建镜像，会继承基础镜像的更新。那么，问题解决了么？没有。准确说，只解决了一半。如果这个 <code>Dockerfile</code> 里面有些东西需要调整呢？比如所有的项目中 <code>npm install</code> 都需要加一些参数，这一行 <code>RUN</code> 是不可能放入基础镜像的，因为涉及到了当前项目的 <code>./package.json</code> ，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 <code>Dockerfile</code> 的前 4 条指令的变化问题，而后面三条指令的变化则完全没办法处理。</p>
<p><code>ONBUILD</code> 可以解决这个问题。用 <code>ONBUILD</code> 重新写一下基础镜像的 <code>Dockerfile</code> :</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /app</span></span><br><span class="line"><span class="bash">WORKDIR /app</span></span><br><span class="line"><span class="bash">ONBUILD COPY ./package.json /app</span></span><br><span class="line"><span class="bash">ONBUILD RUN [ <span class="string">"npm"</span>, <span class="string">"install"</span> ]</span></span><br><span class="line"><span class="bash">ONBUILD COPY . /app/</span></span><br><span class="line"><span class="bash">CMD [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span></span><br></pre></td></tr></table></figure>
<p>回到原始的 <code>Dockerfile</code> ，这次将项目相关的指令加上 <code>ONBUILD</code> ，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 <code>Dockerfile</code> 就变成了简单地：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> my-node</span><br></pre></td></tr></table></figure>
<p>是的，只有这么一行。当在各个项目目录中，用这个只有一行的 Dockerfile 构建镜像时，之前基础镜像的那三行 <code>ONBUILD</code> 就会开始执行，成功地将当前项目的代码复制进镜像、并且针对本项目执行 <code>npm install</code> ，生成应用镜像。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li>Dockerfie 官方文档：<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/</a></li>
<li>Dockerfile 最佳实践文档：<a href="https://docs.docker.com/engine/userguide/engimage/dockerfile_best-practices/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/engimage/dockerfile_best-practices/</a></li>
<li>Docker 官方镜像 Dockerfile ：<a href="https://github.com/docker-library/docs" target="_blank" rel="noopener">https://github.com/docker-library/docs</a></li>
</ul>
<h2 id="多阶段构建"><a href="#多阶段构建" class="headerlink" title="多阶段构建"></a>多阶段构建</h2><h3 id="之前的做法"><a href="#之前的做法" class="headerlink" title="之前的做法"></a>之前的做法</h3><p>在 Docker 17.05 版本之前，构建 Docker 镜像时，通常会采用两种方式：</p>
<h3 id="全部放入一个-Dockerfile"><a href="#全部放入一个-Dockerfile" class="headerlink" title="全部放入一个 Dockerfile"></a>全部放入一个 Dockerfile</h3><p>一种方式是将所有的构建过程编包含在一个 Dockerfile 中，包括项目及其依赖库的编译、测试、打包等流程，这里可能会带来的一些问题：</p>
<ul>
<li>Dockerfile 特别长，可维护性降低</li>
<li>镜像层次多，镜像体积较大，部署时间变长</li>
<li>源代码存在泄露的风险</li>
</ul>
<p>例如，编写 <code>app.go</code> 文件，该程序输出 <code>Hello World!</code> ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写 <code>Dockerfile.one</code> 文件：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.9</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk --no-cache add git ca-certificates</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">WORKDIR /go/src/github.com/go/helloworld/</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY app.go .</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN go get -d -v github.com/go-sql-driver/mysql \</span></span><br><span class="line"><span class="bash">    &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . \</span></span><br><span class="line"><span class="bash">    &amp;&amp; cp /go/src/github.com/go/helloworld/app /root</span></span><br><span class="line"><span class="bash">    </span></span><br><span class="line"><span class="bash">WORKDIR /root/</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">CMD [<span class="string">"./app"</span>]</span></span><br></pre></td></tr></table></figure>
<p>构建镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build --tag <span class="string">'go/helloworld:1'</span> --file Dockerfile.one .</span><br></pre></td></tr></table></figure>
<h3 id="分散到多个-Dockerfile"><a href="#分散到多个-Dockerfile" class="headerlink" title="分散到多个 Dockerfile"></a>分散到多个 Dockerfile</h3><p>另一种方式，就是事先在一个 Dockerfile 将项目及其依赖库编译测试打包好后，再将其拷贝到运行环境中，这种方式需要我们编写两个 <code>Dockerfile</code> 和一些编译脚本才能将其两个阶段自动整合起来，这种方式虽然可以很好地规避第一种方式存在的风险，但明显部署过程较复杂。</p>
<p>例如，编写 <code>Dockerfile.build</code> 文件：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.9</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk --no-cache add git</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">WORKDIR /go/src/github.com/go/helloworld/</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY app.go .</span></span><br><span class="line"><span class="bash">RUN go get -d -v github.com/go-sql-driver/mysql \</span></span><br><span class="line"><span class="bash">    &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br></pre></td></tr></table></figure>
<p>编写 Dockerfile.copy 文件：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">WORKDIR /root/</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY app .</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">CMD [<span class="string">"./app"</span>]</span></span><br></pre></td></tr></table></figure>
<p>新建 <code>build.sh</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'Building go/helloworld:build'</span></span><br><span class="line"></span><br><span class="line">docker build --tag go/helloworld:build . --file Dockerfile.build</span><br><span class="line"></span><br><span class="line">docker create --name extract go/helloworld:build</span><br><span class="line">docker cp extract:/go/src/github.com/go/helloworld/app ./app</span><br><span class="line">docker rm -f extract</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'Building go/helloworld:2'</span></span><br><span class="line"></span><br><span class="line">docker build --no-cache -t go/helloworld:2 . -f Dockerfile.copy</span><br><span class="line">rm ./app</span><br></pre></td></tr></table></figure>
<p>现在运行脚本即可构建镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x build.sh</span><br><span class="line">$ ./build.sh</span><br></pre></td></tr></table></figure>
<p>对比两种方式生成的镜像大小</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY     TAG         IMAGE         ID  CREATED  SIZE</span><br><span class="line">go/helloworld  2           f7cf3465432c  22  seconds  ago   6.47MB</span><br><span class="line">go/helloworld  1           f55d3e16affc  2   minutes  ago   295MB</span><br></pre></td></tr></table></figure>
<h3 id="使用多阶段构建"><a href="#使用多阶段构建" class="headerlink" title="使用多阶段构建"></a>使用多阶段构建</h3><p>从 Docker v17.05 开始支持多阶段构建 ( <code>multistage builds</code> )。使用多阶段构建就可以很容易解决前面提到的问题，并且只需要编写一个 Dockerfile ：</p>
<p>例如：</p>
<p>编写 Dockerfile 文件</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.9</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk --no-cache add git</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">WORKDIR /go/src/github.com/go/helloworld/</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN go get -d -v github.com/go-sql-driver/mysql</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY app.go .</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">FROM alpine:latest</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN apk --no-cache add ca-certificates</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">WORKDIR /root/</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY --from=0 /go/src/github.com/go/helloworld/app .</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">CMD [<span class="string">"./app"</span>]</span></span><br></pre></td></tr></table></figure>
<p>构建镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t go/helloworld:3 .</span><br></pre></td></tr></table></figure>
<p>对比三个镜像大小</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY     TAG         IMAGE         ID  CREATED  SIZE</span><br><span class="line">go/helloworld  3           d6911ed9c846  7   seconds  ago   6.47MB</span><br><span class="line">go/helloworld  2           f7cf3465432c  22  seconds  ago   6.47MB</span><br><span class="line">go/helloworld  1           f55d3e16affc  2   minutes  ago   295MB</span><br></pre></td></tr></table></figure>
<p>很明显使用多阶段构建的镜像体积小，同时也完美解决了上边提到的问题。</p>
<h3 id="其它制作镜像的方式"><a href="#其它制作镜像的方式" class="headerlink" title="其它制作镜像的方式"></a>其它制作镜像的方式</h3><p>除了标准的使用 Dockerfile 生成镜像的方法外，由于各种特殊需求和历史原因，还提供了一些其它方法用以生成镜像。</p>
<h4 id="从-rootfs-压缩包导入"><a href="#从-rootfs-压缩包导入" class="headerlink" title="从 rootfs 压缩包导入"></a>从 rootfs 压缩包导入</h4><p>格式： <code>docker import [选项] &lt;文件&gt;|&lt;URL&gt;|- [&lt;仓库名&gt;[:&lt;标签&gt;]]</code></p>
<p>压缩包可以是本地文件、远程 Web 文件，甚至是从标准输入中得到。压缩包将会在镜像 <code>/</code> 目录展开，并直接作为镜像第一层提交。</p>
<p>比如要创建一个 <a href="https://openvz.org" target="_blank" rel="noopener">OpenVZ</a> 的 Ubuntu 14.04 <a href="https://wiki.openvz.org/Download/template/precreated" target="_blank" rel="noopener">模板</a> 的镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker import \</span><br><span class="line">    http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz \</span><br><span class="line">    openvz/ubuntu:14.04 </span><br><span class="line">Downloading from http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-mi nimal.tar.gz</span><br><span class="line">sha256:f477a6e18e989839d25223f301ef738b69621c4877600ae6467c4e5289822a79B/78.42 MB</span><br></pre></td></tr></table></figure>
<p>这条命令自动下载了 <code>ubuntu-14.04-x86_64-minimal.tar.gz</code> 文件，并且作为根文件系统展开导入，并保存为镜像 <code>openvz/ubuntu:14.04</code> 。</p>
<p>导入成功后，可以看到这个导入的镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls openvz/ubuntu</span><br><span class="line">REPOSITORY     TAG         IMAGE         ID  CREATED  SIZE</span><br><span class="line">openvz/ubuntu  14.04       f477a6e18e98  55  seconds  ago   214.9MB</span><br><span class="line">MB</span><br></pre></td></tr></table></figure>
<p>如果查看其历史的话，会看到描述中有导入的文件链接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">history</span> openvz/ubuntu:14.04</span><br><span class="line">IMAGE               CREATED             CREATED BY       SIZE           COMMENT</span><br><span class="line">f477a6e18e98        About a minute ago                   214.9 MB       Imported from http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz</span><br></pre></td></tr></table></figure>
<h4 id="docker-save-和-docker-load"><a href="#docker-save-和-docker-load" class="headerlink" title="docker save 和 docker load"></a>docker save 和 docker load</h4><p>Docker 还提供了 <code>docker load</code> 和 <code>docker save</code> 命令，用以将镜像保存为一个 <code>tar</code> 文件，然后传输到另一个位置上，再加载进来。这是在没有 Docker Registry 时的做法，现在已经不推荐，镜像迁移应该直接使用 Docker Registry，无论是直接使用 Docker Hub 还是使用内网私有 Registry 都可以。</p>
<p><strong>保存镜像</strong></p>
<p>使用 <code>docker save</code> 命令可以将镜像保存为归档文件。比如保存 <code>ubuntu</code> 镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls ubuntu</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              latest              775349758637        2 months ago        64.2MB</span><br></pre></td></tr></table></figure>
<p>保存镜像的命令为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image save ubuntu | gzip &gt; ubuntu-latest.tar.gz</span><br></pre></td></tr></table></figure>
<p>然后将 <code>ubuntu-latest.tar.gz</code> 文件复制到到了另一个机器上，用下面这个命令加载镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker load -i ubuntu-latest.tar.gz</span><br><span class="line">Loaded image: ubuntu:latest</span><br></pre></td></tr></table></figure>
<h2 id="镜像的实现原理"><a href="#镜像的实现原理" class="headerlink" title="镜像的实现原理"></a>镜像的实现原理</h2><p>Docker 镜像是怎么实现增量的修改和维护的？</p>
<p>每个镜像都由很多层次构成，Docker 使用 <a href="https://en.wikipedia.org/wiki/UnionFS" target="_blank" rel="noopener">Union FS</a> 将这些不同的层结合到一个镜像中去。</p>
<p>通常 Union FS 有两个用途, 一方面可以实现不借助 LVM、RAID 将多个 disk 挂到同一个目录下，另一个更常用的就是将一个只读的分支和一个可写的分支联合在一起，Live CD 正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作。</p>
<p>Docker 在 AUFS 上构建的容器也是利用了类似的原理。</p>
<h1 id="访问仓库"><a href="#访问仓库" class="headerlink" title="访问仓库"></a>访问仓库</h1><p>仓库（ <code>Repository</code> ）是集中存放镜像的地方。</p>
<p>一个容易混淆的概念是注册服务器（ <code>Registry</code> ）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 <code>dl.dockerpool.com/ubuntu</code> 来说， <code>dl.dockerpool.com</code> 是注册服务器地址， <code>ubuntu</code> 是仓库名。</p>
<p>大部分时候，并不需要严格区分这两者的概念。</p>
<h2 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h2><p>目前 Docker 官方维护了一个公共仓库 <a href="https://hub.docker.com" target="_blank" rel="noopener">Docker Hub</a>，其中已经包括了数量超过 15,000 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p>
<p><strong>注册</strong></p>
<p>可以在 <a href="https://hub.docker.com/signup" target="_blank" rel="noopener">https://hub.docker.com/signup</a> 免费注册一个 Docker 账号。</p>
<p>登录</p>
<p>可以通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。通过 <code>docker logout</code> 退出登录。</p>
<p><strong>拉取镜像</strong></p>
<p>通过 <code>docker search</code> 命令来查找官方仓库中的镜像，并利用 <code>docker pull</code> 命令来将它下载到本地。</p>
<p>例如以 <code>centos</code> 为关键词进行搜索：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker search centos</span><br><span class="line">NAME                               DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">centos                             The official build of CentOS.                   5758                [OK]                </span><br><span class="line">ansible/centos7-ansible            Ansible on Centos7                              126                                     [OK]</span><br><span class="line">jdeathe/centos-ssh                 OpenSSH / Supervisor / EPEL/IUS/SCL Repos - …   114                                     [OK]</span><br><span class="line">consol/centos-xfce-vnc             Centos container with <span class="string">"headless"</span> VNC session…   107                                     [OK]</span><br><span class="line">centos/mysql-57-centos7            MySQL 5.7 SQL database server                   67                                      </span><br><span class="line">imagine10255/centos6-lnmp-php56    centos6-lnmp-php56                              57                                      [OK]</span><br><span class="line">tutum/centos                       Simple CentOS docker image with SSH access      44                                      </span><br><span class="line">centos/postgresql-96-centos7       PostgreSQL is an advanced Object-Relational …   39                                      </span><br><span class="line">kinogmt/centos-ssh                 CentOS with SSH                                 29                                      [OK]</span><br></pre></td></tr></table></figure>
<p>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建、是否自动创建。</p>
<p>官方的镜像说明是官方项目组创建和维护的，automated 资源允许用户验证镜像的来源和内容。</p>
<p>根据是否是官方提供，可将镜像资源分为两类。</p>
<p>一种是类似 <code>centos</code> 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。</p>
<p>还有一种类型，比如 <code>tianon/centos</code> 镜像，它是由 Docker 的用户创建并维护的，往往带有用户名称前缀。可以通过前缀 <code>username/</code> 来指定使用某个用户提供的镜像，比如 <code>tianon</code> 用户</p>
<p>另外，在查找的时候通过 <code>--filter=stars=N</code> 参数可以指定仅显示收藏数量为 N 以上的镜像。</p>
<p>下载官方 centos 镜像到本地。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull centos</span><br><span class="line">Pulling repository centos</span><br><span class="line">0b443ba03958: Download complete</span><br><span class="line">539c0211cd76: Download complete</span><br><span class="line">511136ea3c5a: Download complete</span><br><span class="line">7064731afe90: Download complete</span><br></pre></td></tr></table></figure>
<p><strong>推送镜像</strong></p>
<p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub。以下命令中的 <code>username</code> 请替换为你的 Docker 账号用户名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag ubuntu:17.10 username/ubuntu:17.10</span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">$ docker push username/ubuntu:17.10</span><br><span class="line">$ docker search username</span><br></pre></td></tr></table></figure>
<p><strong>自动创建</strong></p>
<p>自动创建（Automated Builds）功能对于需要经常升级镜像内程序来说，十分方便。</p>
<p>有时候，用户创建了镜像，安装了某个软件，如果软件发布新版本则需要手动更新镜像。</p>
<p>而自动创建允许用户通过 Docker Hub 指定跟踪一个目标网站（目前支持 GitHub 或 BitBucket ）上的项目，一旦项目发生新的提交或者创建新的标签（tag），Docker Hub 会自动构建镜像并推送到 Docker Hub 中。</p>
<p>要配置自动创建，包括如下的步骤：</p>
<ul>
<li><p>创建并登录 Docker Hub，以及目标网站；</p>
</li>
<li><p>在目标网站中连接帐户到 Docker Hub；</p>
</li>
<li><p>在 Docker Hub 中 配置一个自动创建；</p>
</li>
<li><p>选取一个目标网站中的项目（需要含 Dockerfile ）和分支；</p>
</li>
<li><p>指定 Dockerfile 的位置，并提交创建。</p>
</li>
</ul>
<p>之后，可以在 Docker Hub 的 自动创建页面中跟踪每次创建的状态。</p>
<h2 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h2><p>有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。</p>
<p><a href="https://github.com/docker/distribution" target="_blank" rel="noopener">docker-registry</a> 是官方提供的工具，可以用于构建私有的镜像仓库。</p>
<p><strong>安装运行 docker-registry</strong></p>
<p>安装运行 docker-registry 可以通过获取官方 registry 镜像来运行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 5000:5000 --restart=always --name registry registry</span><br></pre></td></tr></table></figure>
<p>这将使用官方的 <code>registry</code> 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code> 目录下。可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 <code>/opt/data/registry</code> 目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -v /opt/data/registry:/var/lib/registry \</span><br><span class="line">    registry</span><br></pre></td></tr></table></figure>
<p><strong>在私有仓库上传、搜索、下载镜像</strong></p>
<p>创建好私有仓库之后，就可以使用 <code>docker tag</code> 来标记一个镜像，然后推送它到仓库。例如私有仓库地址为 <code>127.0.0.1:5000</code> 。</p>
<p>先在本机查看已有的镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls ubuntu</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              latest              775349758637        2 months ago        64.2MB</span><br></pre></td></tr></table></figure>
<p>使用 <code>docker tag</code> 将 <code>ubuntu:latest</code> 这个镜像标记为 <code>127.0.0.1:5000/ubuntu:latest</code> 。</p>
<p>格式为 <code>docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</code> 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu                  latest              775349758637        2 months ago        64.2MB</span><br><span class="line">127.0.0.1:5000/ubuntu   latest              775349758637        2 months ago        64.2MB</span><br></pre></td></tr></table></figure>
<p>使用 <code>docker push</code> 上传标记的镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker push 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">The push refers to repository [127.0.0.1:5000/ubuntu]</span><br><span class="line">373a30c24545: Pushed</span><br><span class="line">a9148f5200b0: Pushed</span><br><span class="line">cdd3de0940ab: Pushed</span><br><span class="line">fc56279bbb33: Pushed</span><br><span class="line">b38367233d37: Pushed</span><br><span class="line">2aebd096e0e2: Pushed</span><br><span class="line">latest: digest: sha256:fe4277621f10b5026266932ddf760f5a756d2facd505a94d2da12f4f52f71f5a size: 1568</span><br></pre></td></tr></table></figure>
<p>用 curl 查看仓库中的镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl 127.0.0.1:5000/v2/_catalog</span><br><span class="line">&#123;<span class="string">"repositories"</span>:[<span class="string">"ubuntu"</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到 <code>{&quot;repositories&quot;:[&quot;ubuntu&quot;]}</code> ，表明镜像已经被成功上传了。先删除已有镜像，再尝试从私有仓库中下载这个镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">$ docker pull 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">$ docker image ls</span><br></pre></td></tr></table></figure>
<p>注意事项</p>
<p>如果不想使用 <code>127.0.0.1:5000</code> 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。就得把例如 <code>192.168.199.100:5000</code> 这样的内网地址作为私有仓库地址，这时会发现无法成功推送镜像。</p>
<p>这是因为 Docker 默认不允许非 <code>HTTPS</code> 方式推送镜像。可以通过 Docker 的配置选项来取消这个限制，或者配置能够通过 <code>HTTPS</code> 访问的私有仓库。</p>
<ul>
<li>Ubuntu 14.04, Debian 7 Wheezy</li>
</ul>
<p>对于使用 upstart 的系统而言，编辑 /etc/default/docker 文件，在其中的 <code>DOCKER_OPTS</code> 中增加如下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS=<span class="string">"--registry-mirror=https://registry.docker-cn.com --insecure-registries=192.168.199.100:5000"</span></span><br></pre></td></tr></table></figure>
<p>重新启动服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service docker restart</span><br></pre></td></tr></table></figure>
<ul>
<li>Ubuntu 16.04+, Debian 8+, centos 7</li>
</ul>
<p>对于使用 systemd 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在需要新建该文件）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"registry-mirror"</span>: [</span><br><span class="line">        <span class="string">"https://registry.docker-cn.com"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"insecure-registries"</span>: [</span><br><span class="line">        <span class="string">"192.168.199.100:5000"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件必须符合 <code>json</code> 文件规范，否则 docker 服务将无法启动。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>
<h2 id="私有仓库高级配置"><a href="#私有仓库高级配置" class="headerlink" title="私有仓库高级配置"></a>私有仓库高级配置</h2>
      
    </div>

    

    
    
    

    

    
      
    
    
      <div>
        <div id="reward-container">
  <div>有钱任性，请我吃包辣条</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">

    
      
      
        
      
      <div style="display: inline-block">
        <img src="/images/wechatpay.jpg" alt="Silence 微信支付">
        <p>微信支付</p>
      </div>
    
      
      
        
      
      <div style="display: inline-block">
        <img src="/images/alipay.jpg" alt="Silence 支付宝">
        <p>支付宝</p>
      </div>
    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        
          
        
        <div class="post-tags">
          
            <a href="/tags/grub2/" rel="tag"><i class="fa fa-tag"></i> grub2</a>
          
            <a href="/tags/Docker/" rel="tag"><i class="fa fa-tag"></i> Docker</a>
          
            <a href="/tags/DevOps/" rel="tag"><i class="fa fa-tag"></i> DevOps</a>
          
            <a href="/tags/CI-CD/" rel="tag"><i class="fa fa-tag"></i> CI/CD</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/20/134123-Python中的必考问题3/" rel="next" title="Python中的必考问题3">
                <i class="fa fa-chevron-left"></i> Python中的必考问题3
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Silence">
            
              <p class="site-author-name" itemprop="name">Silence</p>
              <div class="site-description motion-element" itemprop="description">书山有路勤为径，学海无涯苦作舟</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">139</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">35</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/linuxgeeks" title="GitHub &rarr; https://github.com/linuxgeeks" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:yourname@gmail.com" title="E-Mail &rarr; mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.ibm.com/developerworks/cn/" title="https://www.ibm.com/developerworks/cn/" rel="noopener" target="_blank">IBM developerWorks</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://iissnan.com/progit/" title="http://iissnan.com/progit/" rel="noopener" target="_blank">Pro Git</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.freeoa.net/index/" title="http://www.freeoa.net/index/" rel="noopener" target="_blank">freeOA</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.ttlsa.com/" title="http://www.ttlsa.com/" rel="noopener" target="_blank">运维生存时间</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.361way.com/" title="http://www.361way.com/" rel="noopener" target="_blank">运维之路</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.ipcpu.com" title="http://www.ipcpu.com" rel="noopener" target="_blank">网络之路</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.yiibai.com/" title="http://www.yiibai.com/" rel="noopener" target="_blank">易百教程</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.centoscn.com/" title="http://www.centoscn.com/" rel="noopener" target="_blank">CentOS中文站</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.linuxprobe.com/" title="http://www.linuxprobe.com/" rel="noopener" target="_blank">Linux就该这么学</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.netingcn.com/" title="http://www.netingcn.com/" rel="noopener" target="_blank">网络进行时</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.ruanyifeng.com/blog/" title="http://www.ruanyifeng.com/blog/" rel="noopener" target="_blank">阮一峰的网络日志</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.liaoxuefeng.com" title="https://www.liaoxuefeng.com" rel="noopener" target="_blank">廖雪峰的官方网站</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://yihui.name/cn/" title="https://yihui.name/cn/" rel="noopener" target="_blank">谢益辉的博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://coolshell.cn" title="https://coolshell.cn" rel="noopener" target="_blank">酷壳</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://zhangguanzhang.github.io" title="https://zhangguanzhang.github.io" rel="noopener" target="_blank">张馆长的博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://kuops.com" title="https://kuops.com" rel="noopener" target="_blank">kuops</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.jinbuguo.com/" title="http://www.jinbuguo.com/" rel="noopener" target="_blank">金步国作品集</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.sa-log.com" title="http://www.sa-log.com" rel="noopener" target="_blank">王帅的博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://thief.one" title="https://thief.one" rel="noopener" target="_blank">nMask</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://arvon.top" title="https://arvon.top" rel="noopener" target="_blank">Arvon</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://kionf.com" title="https://kionf.com" rel="noopener" target="_blank">Kionf</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.the5fire.com" title="https://www.the5fire.com" rel="noopener" target="_blank">the5fire</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker-简介"><span class="nav-number">1.</span> <span class="nav-text">Docker 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是-Docker-？"><span class="nav-number">1.1.</span> <span class="nav-text">什么是 Docker ？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器和虚拟机"><span class="nav-number">1.2.</span> <span class="nav-text">容器和虚拟机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要使用-Docker-？"><span class="nav-number">1.3.</span> <span class="nav-text">为什么要使用 Docker ？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器技术对比传统虚拟机总结"><span class="nav-number">1.4.</span> <span class="nav-text">容器技术对比传统虚拟机总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基本概念"><span class="nav-number">2.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#安装-Docker"><span class="nav-number">3.</span> <span class="nav-text">安装 Docker</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#系统环境的配置"><span class="nav-number">3.1.</span> <span class="nav-text">系统环境的配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#运行环境配置"><span class="nav-number">3.1.1.</span> <span class="nav-text">运行环境配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#系统服务配置"><span class="nav-number">3.1.2.</span> <span class="nav-text">系统服务配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#资源使用限定"><span class="nav-number">3.1.3.</span> <span class="nav-text">资源使用限定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内核参数设置"><span class="nav-number">3.1.4.</span> <span class="nav-text">内核参数设置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安装-Docker-1"><span class="nav-number">3.2.</span> <span class="nav-text">安装 Docker</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#后续配置"><span class="nav-number">3.3.</span> <span class="nav-text">后续配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置-Docker-守护进程"><span class="nav-number">3.4.</span> <span class="nav-text">配置 Docker 守护进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置-Docker-镜像加速器"><span class="nav-number">3.5.</span> <span class="nav-text">配置 Docker 镜像加速器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-Systemd-控制-Docker"><span class="nav-number">3.6.</span> <span class="nav-text">使用 Systemd 控制 Docker</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用镜像"><span class="nav-number">4.</span> <span class="nav-text">使用镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#查找镜像"><span class="nav-number">4.1.</span> <span class="nav-text">查找镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取镜像"><span class="nav-number">4.2.</span> <span class="nav-text">获取镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#列出镜像"><span class="nav-number">4.3.</span> <span class="nav-text">列出镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#镜像体积"><span class="nav-number">4.3.1.</span> <span class="nav-text">镜像体积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚悬镜像"><span class="nav-number">4.3.2.</span> <span class="nav-text">虚悬镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中间层镜像"><span class="nav-number">4.3.3.</span> <span class="nav-text">中间层镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#列出部分镜像"><span class="nav-number">4.3.4.</span> <span class="nav-text">列出部分镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#以特定格式显示"><span class="nav-number">4.3.5.</span> <span class="nav-text">以特定格式显示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除本地镜像"><span class="nav-number">4.4.</span> <span class="nav-text">删除本地镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用-ID、镜像名、摘要删除镜像"><span class="nav-number">4.4.1.</span> <span class="nav-text">用 ID、镜像名、摘要删除镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Untagged-和-Deleted"><span class="nav-number">4.4.2.</span> <span class="nav-text">Untagged 和 Deleted</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用-docker-image-ls-命令来配合"><span class="nav-number">4.4.3.</span> <span class="nav-text">用 docker image ls 命令来配合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CentOS-RHEL-的注意事项"><span class="nav-number">4.4.4.</span> <span class="nav-text">CentOS/RHEL 的注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#操作容器"><span class="nav-number">5.</span> <span class="nav-text">操作容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#启动容器"><span class="nav-number">5.1.</span> <span class="nav-text">启动容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#新建并启动"><span class="nav-number">5.1.1.</span> <span class="nav-text">新建并启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启动已终止容器"><span class="nav-number">5.1.2.</span> <span class="nav-text">启动已终止容器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#后台运行"><span class="nav-number">5.2.</span> <span class="nav-text">后台运行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#终止容器"><span class="nav-number">5.3.</span> <span class="nav-text">终止容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进入容器"><span class="nav-number">5.4.</span> <span class="nav-text">进入容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#导出和导入容器"><span class="nav-number">5.5.</span> <span class="nav-text">导出和导入容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除"><span class="nav-number">5.6.</span> <span class="nav-text">删除</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#构建镜像"><span class="nav-number">6.</span> <span class="nav-text">构建镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#利用-commit-理解镜像构成"><span class="nav-number">6.1.</span> <span class="nav-text">利用 commit 理解镜像构成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#慎用-docker-commit"><span class="nav-number">6.2.</span> <span class="nav-text">慎用 docker commit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-Dockerfile-定制镜像"><span class="nav-number">6.3.</span> <span class="nav-text">使用 Dockerfile 定制镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dockerfile-指令详解"><span class="nav-number">6.4.</span> <span class="nav-text">Dockerfile 指令详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#COPY-复制文件"><span class="nav-number">6.4.1.</span> <span class="nav-text">COPY 复制文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ADD-更高级的复制文件"><span class="nav-number">6.4.2.</span> <span class="nav-text">ADD 更高级的复制文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMD-容器启动命令"><span class="nav-number">6.4.3.</span> <span class="nav-text">CMD 容器启动命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ENTRYPOINT-入口点"><span class="nav-number">6.4.4.</span> <span class="nav-text">ENTRYPOINT 入口点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ENV-设置环境变量"><span class="nav-number">6.4.5.</span> <span class="nav-text">ENV 设置环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ARG-构建参数"><span class="nav-number">6.4.6.</span> <span class="nav-text">ARG 构建参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VOLUME-定义匿名卷"><span class="nav-number">6.4.7.</span> <span class="nav-text">VOLUME 定义匿名卷</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EXPOSE-声明暴露的端口"><span class="nav-number">6.4.8.</span> <span class="nav-text">EXPOSE 声明暴露的端口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WORKDIR-指定工作目录"><span class="nav-number">6.4.9.</span> <span class="nav-text">WORKDIR 指定工作目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#USER-指定当前用户"><span class="nav-number">6.4.10.</span> <span class="nav-text">USER 指定当前用户</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HEALTHCHECK-健康检查"><span class="nav-number">6.4.11.</span> <span class="nav-text">HEALTHCHECK 健康检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ONBUILD-为他人做嫁衣裳"><span class="nav-number">6.4.12.</span> <span class="nav-text">ONBUILD 为他人做嫁衣裳</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考文档"><span class="nav-number">6.4.13.</span> <span class="nav-text">参考文档</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多阶段构建"><span class="nav-number">6.5.</span> <span class="nav-text">多阶段构建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#之前的做法"><span class="nav-number">6.5.1.</span> <span class="nav-text">之前的做法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全部放入一个-Dockerfile"><span class="nav-number">6.5.2.</span> <span class="nav-text">全部放入一个 Dockerfile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分散到多个-Dockerfile"><span class="nav-number">6.5.3.</span> <span class="nav-text">分散到多个 Dockerfile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用多阶段构建"><span class="nav-number">6.5.4.</span> <span class="nav-text">使用多阶段构建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其它制作镜像的方式"><span class="nav-number">6.5.5.</span> <span class="nav-text">其它制作镜像的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#从-rootfs-压缩包导入"><span class="nav-number">6.5.5.1.</span> <span class="nav-text">从 rootfs 压缩包导入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#docker-save-和-docker-load"><span class="nav-number">6.5.5.2.</span> <span class="nav-text">docker save 和 docker load</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#镜像的实现原理"><span class="nav-number">6.6.</span> <span class="nav-text">镜像的实现原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#访问仓库"><span class="nav-number">7.</span> <span class="nav-text">访问仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker-Hub"><span class="nav-number">7.1.</span> <span class="nav-text">Docker Hub</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#私有仓库"><span class="nav-number">7.2.</span> <span class="nav-text">私有仓库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#私有仓库高级配置"><span class="nav-number">7.3.</span> <span class="nav-text">私有仓库高级配置</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">文章总结于网络，转载请注明出处</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.2.0</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.2.0"></script>



  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  


  <script src="/js/next-boot.js?v=7.2.0"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').not('.gist .highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      const selection = document.getSelection();
      const selected = selection.rangeCount > 0 ? selection.getRangeAt(0) : false;
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
      if (selected) {
        selection.removeAllRanges();
        selection.addRange(selected);
      }
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
